<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring Bean的生命周期</title>
      <link href="/2020/06/13/spring-bean-lifecycle/"/>
      <url>/2020/06/13/spring-bean-lifecycle/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文从源码（SpringBoot 2.3.0版本）入手，学习教材上所说的Bean的生命周期的4个阶段：</p><ol><li>Bean定义</li><li>Bean初始化</li><li>Bean的生存期</li><li>Bean的销毁</li></ol><p>其中，Bean初始化阶段涉及的内容较多，如依赖注入，BeanPostProcessor、Aware接口的调用，比较复杂，这里先给个结论。</p><p>Bean初始化过程中的生命周期：</p><ol><li>调用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()</li><li>Bean实例化(Instantiation)</li><li>调用InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()</li><li>调用AutowiredAnnotationBeanPostProcessor.postProcessProperties()，完成依赖注入，是一个递归过程</li><li>调用BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</li><li>调用每个BeanPostProcessor.postProcessBeforeInitialization()，当BeanPostProcessor=ApplicationContextAwareProcessor时，调用ApplicationContextAware.setApplicationContext()</li><li>调用InitializingBean.afterPropertiesSet()</li><li>调用@Bean的init-method方法</li><li>调用每个BeanPostProcessor.postProcessAfterInitialization()</li></ol><h1 id="Bean定义"><a href="#Bean定义" class="headerlink" title="Bean定义"></a>Bean定义</h1><p>在SpringBoot启动时，根据<code>@ComponentScan</code>指定的包路径（默认是当前包及其子包）扫描，把Bean的定义保存到IoC容器中。</p><p>SpringBoot Web应用使用的IoC容器为<code>AnnotationConfigServletWebServerApplicationContext</code>，这个容器包含一个属性：DefaultListableBeanFactory。<code>DefaultListableBeanFactory</code>是<code>BeanFactory</code>的实现类之一，它的作用就是保存bean定义和实例化bean。</p><p>在启动类SpringApplication.run()方法中，先确定使用的IoC容器为<code>AnnotationConfigServletWebServerApplicationContext</code>，然后调用此容器的refresh()方法，对<code>DefaultListableBeanFactory</code>进行配置，将Bean定义添加到<code>DefaultListableBeanFactory</code>的<code>beanDefinitionMap</code>中。</p><p>下面是主要的一些源码展示，这些方法间的调用链可以debug查看。</p><p>SpringApplication.run()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 指定IoC容器为AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">context = createApplicationContext(); </span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line"><span class="comment">// 刷新容器，调用了AnnotationConfigServletWebServerApplicationContext.refresh()方法</span></span><br><span class="line">refreshContext(context);</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassPathBeanDefinitionScanner.doScan()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123; <span class="comment">// basePackages=启动类所在包</span></span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); <span class="comment">// 所有Bean类的定义，如HelloController、HelloServiceImpl</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">definitionHolder =</span><br><span class="line">AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">beanDefinitions.add(definitionHolder);</span><br><span class="line">registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry); <span class="comment">// 把Bean的定义添加到this.registry=DefaultListableBeanFactory中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultListableBeanFactory部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAutowireCapableBeanFactory</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ConfigurableListableBeanFactory</span>, <span class="title">BeanDefinitionRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line"><span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition); <span class="comment">//添加Bean定义到beanDefinitionMap</span></span><br><span class="line">List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">removeManualSingletonName(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Still in startup registration phase</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition); <span class="comment">//添加Bean定义到beanDefinitionMap</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">removeManualSingletonName(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步，IoC容器中只有Bean的定义，还没有Bean的实例化对象。</p><h1 id="Bean初始化"><a href="#Bean初始化" class="headerlink" title="Bean初始化"></a>Bean初始化</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Bean的初始化阶段的主要工作，就是实例化Bean再初始化Bean，初始化过程中就包含依赖注入。</p><p>默认配置的、单例且非懒加载的Bean，会在Bean定义步骤完成后立即初始化。</p><p>入口在IoC容器基类<code>AbstractApplicationContext.finishBeanFactoryInitialization()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单例且非懒加载的bean，beanFactory=DefaultListableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要工作的是<code>AbstractAutowireCapableBeanFactory.doCreateBean()</code>方法，这个类是<code>DefaultListableBeanFactory</code>的基类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// bean实例化</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 下面两行都是bean的初始化</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面介绍Bean初始化阶段的详细过程。</p><h2 id="Bean实例化-Instantiation"><a href="#Bean实例化-Instantiation" class="headerlink" title="Bean实例化(Instantiation)"></a>Bean实例化(Instantiation)</h2><p>在<code>AbstractAutowireCapableBeanFactory.doCreateBean()</code>方法中，<code>createBeanInstance()</code>方法负责Bean的实例化，实例化后的bean对象的属性还是空的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 用bean的构造器创建bean对象，放在instanceWrapper内，此时bean对象的属性还是空的</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean初始化-Initialization"><a href="#Bean初始化-Initialization" class="headerlink" title="Bean初始化(Initialization)"></a>Bean初始化(Initialization)</h2><p>在<code>AbstractAutowireCapableBeanFactory.doCreateBean()</code>方法中，<code>populateBean()</code>方法和<code>initializeBean()</code>方法完成Bean的属性赋值（包括依赖注入），和Bean的一些扩展接口的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 下面两行都是bean的初始化</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper); <span class="comment">// 属性赋值，包括依赖注入</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);<span class="comment">// 调用Bean的一些扩展接口，如BeanPostProcessor接口和Aware接口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>populateBean()</code>方法中完成依赖注入，如把personServiceImpl注入到personController中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 稍微提一下，这里的autowired是@Bean注解的autowired属性值，不是bean的依赖属性上的@Autowired注解</span></span><br><span class="line"><span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="comment">// InstantiationAwareBeanPostProcessor接口是BeanPostProcessor接口的子类，下面会介绍</span></span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 当bp=AutowiredAnnotationBeanPostProcessor时，这步会注入bean的依赖，如把personServiceImpl注入到personController中</span></span><br><span class="line"> <span class="comment">// 在初始化personServiceImpl这个bean时，会递归调用到上面的doCreateBean()方法，且会递归把personMapper注入到personServiceImpl中</span></span><br><span class="line"> <span class="comment">// 因此整个注入是一个递归调用的过程</span></span><br><span class="line">PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line">pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pvs = pvsToUse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上大致介绍了Bean的初始化阶段的主要工作，即实例化Bean再依赖注入。但在这个阶段，还涉及到<code>BeanPostProcessor</code>接口和<code>*Aware</code>接口的调用。下面介绍这两类接口的作用和调用时机。</p><h2 id="调用扩展接口"><a href="#调用扩展接口" class="headerlink" title="调用扩展接口"></a>调用扩展接口</h2><h3 id="BeanPostProcessor接口"><a href="#BeanPostProcessor接口" class="headerlink" title="BeanPostProcessor接口"></a>BeanPostProcessor接口</h3><p>BeanPostProcessor是Spring IOC容器给我们提供的一个扩展接口。接口声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在Bean的 InitializingBean.afterPropertiesSet()方法或<span class="doctag">@Bean</span>(init-method)属性定义的方法 执行前被调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在Bean的 InitializingBean.afterPropertiesSet()方法或<span class="doctag">@Bean</span>(init-method)属性定义的方法 执行后被调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了BeanPostProcessor接口的类，被扫描进IoC容器后，在所有Bean的初始化前后都会被调用，即它对所有Bean都生效，有点像AOP。它有个子接口<code>InstantiationAwareBeanPostProcessor</code>。</p><h4 id="InstantiationAwareBeanPostProcessor接口"><a href="#InstantiationAwareBeanPostProcessor接口" class="headerlink" title="InstantiationAwareBeanPostProcessor接口"></a>InstantiationAwareBeanPostProcessor接口</h4><p><code>InstantiationAwareBeanPostProcessor</code>接口继承自<code>BeanPostProcessor</code>接口，它不仅继承了<code>BeanPostProcessor</code>接口会在Bean<strong>初始化</strong>前后调用的两个方法，还增加了会在Bean<strong>实例化</strong>前后调用的两个方法。所以这两个方法也在Bean的生命周期内。具体的调用时机在下面介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bean实例化前调用</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bean实例化后调用</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Aware接口"><a href="#Aware接口" class="headerlink" title="Aware接口"></a>Aware接口</h3><p>Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源，Aware之前的名字就是可以拿到什么资源，例如BeanNameAware可以拿到BeanName，以此类推。<br>比较常见的Aware接口有BeanNameAware、BeanFactoryAware、ApplicationContextAware。</p><h4 id="ApplicationContextAware接口"><a href="#ApplicationContextAware接口" class="headerlink" title="ApplicationContextAware接口"></a>ApplicationContextAware接口</h4><p>ApplicationContextAware接口可以用来获取ApplicationContext，即IoC容器。我们已知<code>ApplicationContext</code>包含<code>BeanFactory</code>接口的getBean()方法，因此我们在服务中可以借助它直接获取Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在项目中，经常遇到要随时获取Bean的情况，这时就可以写一个工具类解决：ApplicationContextUtil。这个工具类就是使用了ApplicationContextAware接口的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.context = applicationContext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过name获取 Bean.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> context.getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过class获取Bean.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> context.getBean(clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过name,以及Clazz返回指定的Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> context.getBean(name, clazz);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们定义的这个Bean，ApplicationContextUtil，它的setApplicationContext()方法是在何时被调用的？答案在下面“调用时机”一节中。</p><h3 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h3><h4 id="BeanFactory注册BeanPostProcessor接口"><a href="#BeanFactory注册BeanPostProcessor接口" class="headerlink" title="BeanFactory注册BeanPostProcessor接口"></a>BeanFactory注册BeanPostProcessor接口</h4><p>在AnnotationConfigServletWebServerApplicationContext.refresh()方法中（在Bean定义阶段中有提到），会给要使用的BeanFactory=DefaultListableBeanFactory注册BeanPostProcessor接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">/*省略其他代码*/</span></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">// 这里会添加几个指定的BeanPostProcessor</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">// 这里会注册自定义的BeanPostProcessor</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用BeanPostProcessor和Aware接口方法"><a href="#调用BeanPostProcessor和Aware接口方法" class="headerlink" title="调用BeanPostProcessor和Aware接口方法"></a>调用BeanPostProcessor和Aware接口方法</h4><p>在Bean初始化阶段的initializeBean()方法中，顺序调用了BeanPostProcessor和Aware接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean); <span class="comment">// 调用Aware接口方法，见下方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 执行每个BeanPostProcessor的postProcessBeforeInitialization()方法</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);<span class="comment">// 调用afterPropertiesSet()和init-method方法，见下方</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 执行每个BeanPostProcessor的postProcessAfterInitialization()方法</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断bean是否实现了BeanNameAware等接口的方法，若实现就调用</span></span><br><span class="line"><span class="comment">// ApplicationContextAware接口的调用不在这里，后面介绍</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">ClassLoader bcl = getBeanClassLoader();</span><br><span class="line"><span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断bean是否实现了InitializingBean接口，若实现就调用afterPropertiesSet()，然后反射调用init-method()方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line"><span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="keyword">throw</span> pae.getException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">String initMethodName = mbd.getInitMethodName();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">!(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看到，每初始化一个Bean。就会遍历调用所有的BeanPostProcessor接口方法，即BeanPostProcessor接口方法对所有Bean都有效。而Aware接口是由Bean自己实现的，初始化某个Bean时，会调用Bean自己的Aware接口方法，因此Aware接口方法只针对一个Bean有效。</p><h4 id="ApplicationContextAware接口的调用"><a href="#ApplicationContextAware接口的调用" class="headerlink" title="ApplicationContextAware接口的调用"></a>ApplicationContextAware接口的调用</h4><p>ApplicationContextAware接口的调用点如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean); <span class="comment">// 这里没有调用ApplicationContextAware</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 这里调用了ApplicationContextAware</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在applyBeanPostProcessorsBeforeInitialization()方法中，会遍历执行BeanFactory的所有<code>BeanPostProcessor.postProcessBeforeInitialization()</code>方法，当遍历到<code>ApplicationContextAwareProcessor.postProcessBeforeInitialization()</code>方法时，它的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (acc != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">invokeAwareInterfaces(bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, acc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeAwareInterfaces(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext); <span class="comment">// 当bean实现了ApplicationContextAware，调用setApplicationContext()方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于这个<code>ApplicationContextAwareProcessor</code>是何时添加到BeanFactory的，答案在上面介绍的“BeanFactory注册BeanPostProcessor接口”的prepareBeanFactory()方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InstantiationAwareBeanPostProcessor接口的调用"><a href="#InstantiationAwareBeanPostProcessor接口的调用" class="headerlink" title="InstantiationAwareBeanPostProcessor接口的调用"></a>InstantiationAwareBeanPostProcessor接口的调用</h4><p>介绍<code>InstantiationAwareBeanPostProcessor</code>接口时，提到它扩展的两个方法：postProcessBeforeInstantiation()、postProcessAfterInstantiation()，分别在Bean<strong>实例化</strong>前后调用。具体的调用点如下。</p><p>postProcessBeforeInstantiation()的调用点在<code>AbstractAutowireCapableBeanFactory.createBean()</code>，在doCreateBean()方法之前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line"><span class="comment">// 这里是调用点，见下方</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 可以看到，它的调用点在doCreateBean()之前，说明此时还没有实例化bean</span></span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hasInstantiationAwareBeanPostProcessors=true时，执行postProcessBeforeInstantiation()方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">Object bean = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line"><span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>postProcessAfterInstantiation()的调用点，是我们熟悉的populateBean()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在populateBean()方法最前，此时bean已实例化但还未依赖注入</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line"><span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean初始化阶段总结"><a href="#Bean初始化阶段总结" class="headerlink" title="Bean初始化阶段总结"></a>Bean初始化阶段总结</h2><p>在Bean初始化过程中的生命周期是这样的：</p><ol start="0"><li>BeanFactory注册BeanPostProcessor接口</li><li>调用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()</li><li>createBeanInstance()进行Bean实例化</li><li>populateBean()<ol><li>调用InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()</li><li>调用AutowiredAnnotationBeanPostProcessor.postProcessProperties()，完成依赖注入，是一个递归过程</li></ol></li><li>initializeBean()<ol><li>调用BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</li><li>调用每个BeanPostProcessor.postProcessBeforeInitialization()，当BeanPostProcessor=ApplicationContextAwareProcessor时，调用ApplicationContextAware.setApplicationContext()</li><li>调用InitializingBean.afterPropertiesSet()</li><li>调用@Bean的init-method方法</li><li>调用每个BeanPostProcessor.postProcessAfterInitialization()</li></ol></li></ol><h1 id="Bean的生存期"><a href="#Bean的生存期" class="headerlink" title="Bean的生存期"></a>Bean的生存期</h1><p>Bean的生存期就是SpringBoot程序启动后，我们使用Bean的过程，这里不介绍了。</p><h1 id="Bean的销毁"><a href="#Bean的销毁" class="headerlink" title="Bean的销毁"></a>Bean的销毁</h1><p>当Bean实现了<code>DisposableBean</code>接口，在IoC容器启动时会被扫描到并注册，当IoC容器关闭时会对Bean进行销毁，此时会调用Bean的自定义销毁方法destory()。</p><p>如这样一个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"destory HelloWorldController"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IoC容器启动时，<code>AbstractAutowireCapableBeanFactory.doCreateBean()</code>方法中，会把实现了DisposableBean的Bean注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd); <span class="comment">// 注册DisposableBean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IoC容器关闭时，如下面代码，会对Bean进行销毁，此时会通过BeanFactory调用Bean的自定义销毁方法destory()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(BeanConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(context.getBean(HelloWorldController<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">context.close();<span class="comment">// IoC容器关闭</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultSingletonBeanRegistry.destroyBean()</code>方法（DefaultSingletonBeanRegistry是DefaultListableBeanFactory的间接基类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyBean</span><span class="params">(String beanName, @Nullable DisposableBean bean)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Trigger destruction of dependent beans first...</span></span><br><span class="line">Set&lt;String&gt; dependencies;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;</span><br><span class="line"><span class="comment">// Within full synchronization in order to guarantee a disconnected Set</span></span><br><span class="line">dependencies = <span class="keyword">this</span>.dependentBeanMap.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dependencies != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Retrieved dependent beans for bean '"</span> + beanName + <span class="string">"': "</span> + dependencies);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String dependentBeanName : dependencies) &#123;</span><br><span class="line">destroySingleton(dependentBeanName); <span class="comment">// 销毁bean依赖的bean</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually destroy the bean now...</span></span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">bean.destroy(); <span class="comment">// 调用DisposableBean.destory()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Destruction of bean with name '"</span> + beanName + <span class="string">"' threw an exception"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IoC原理</title>
      <link href="/2020/05/31/spring-ioc/"/>
      <url>/2020/05/31/spring-ioc/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring IoC是一种通过<strong>描述</strong>来生成或者获取对象的技术，和我们平时在需要时直接new一个对象是不一样的，它就是通过你给的针对对象的描述，如对象的名字或者类型，来生成（也叫实例化）（若已生成，就直接取）这个对象。在Spring中，这些被管理的对象叫作<code>Bean</code>。Spring会统一管理这些Bean，包括Bean之间的依赖关系，负责管理这些Bean的是<code>IoC容器</code>。</p><blockquote><p>IoC（控制反转）的意思就是，原本是我们自己控制对象，现在变成由Spring控制，我们需要对象的时候要从容器中取。</p></blockquote><p>文中出现的Spring源码都是SpringBoot 2.3.0版本。</p><h1 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h1><p>IoC容器，在程序中就是实现了<code>BeanFactory</code>接口的类。<code>BeanFactory</code>接口中提供了用name和requiredType获取Bean的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**其他方法和属性省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationContext</code>接口间接继承了<code>BeanFactory</code>接口，它包含<code>BeanFactory</code>接口的所有方法，还提供了额外功能，Spring将它作为默认的启动容器。</p><p>当我们用<code>SpringApplication.run(XXXApplication.class, args);</code>启动时，Spring就会根据依赖的jar包来指定要使用的IoC容器，看SpringApplication类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line"><span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line"><span class="keyword">case</span> SERVLET:</span><br><span class="line">contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> REACTIVE:</span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"Unable create a default ApplicationContext, please specify an ApplicationContextClass"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webApplicationType</code>的值由依赖的jar包决定，默认值是SERVLET，所以IoC容器一般是DEFAULT_SERVLET_WEB_CONTEXT_CLASS=<code>AnnotationConfigServletWebServerApplicationContext</code>，这个类间接实现了<code>ApplicationContext</code>接口。</p><h1 id="用注解装配Bean"><a href="#用注解装配Bean" class="headerlink" title="用注解装配Bean"></a>用注解装配Bean</h1><p>SpringBoot多是用注解把Bean装配到IoC容器中，但也可以使用XML配置文件来装配，这里只介绍注解的方式。</p><h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"><span class="comment">// 内容省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlMultipleDemoApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(MysqlMultipleDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类加上@Component注解后，在SpringBoot启动时，它就会被扫描进IoC容器，原因就是SpringBoot启动类的注解<code>@SpringBootApplication</code>里面包含了<code>@ComponentScan</code>注解，而<code>@ComponentScan</code>的作用就是扫描类当前包及其子包下的被<code>@Component</code>修饰的类。<code>@ComponentScan</code>也可以指定要扫描的包路径。<br>顺便一提，我们熟悉的@Controller、@Service，以及下面说到的@Configuration都包含了@Component注解，所以这些注解修饰的类都会被装配到IoC容器中。</p><h2 id="Configuration和-Bean组合"><a href="#Configuration和-Bean组合" class="headerlink" title="@Configuration和@Bean组合"></a>@Configuration和@Bean组合</h2><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">ApplicationContextUtil <span class="title">applicationContextUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ApplicationContextUtil();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就在IoC容器中生成了一个叫”applicationContextUtil”的Bean。Bean的名字可以在@Bean注解中指定，不指定就为方法名。在一个@Configuration类中，可以写多个@Bean。</p><h2 id="上面两种方法的区别"><a href="#上面两种方法的区别" class="headerlink" title="上面两种方法的区别"></a>上面两种方法的区别</h2><p>从效果上来说没有区别，都可以装配Bean。但后者有一个专门的使用场景，就是装配依赖jar包中的Bean。如上面的示例代码，若<code>ApplicationContextUtil</code>是依赖包中的类，不在自己程序中，就只能用@Configuration和@Bean装配。</p><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>类之间免不了有依赖关系，如我们经常在Service类中这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">personMapper.insertPerson(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就说明PersonServiceImpl类依赖PersonMapper类，但这个PersonMapper的实例对象不是我们自己new的，是通过@Autowired注解，让IoC容器为我们注入的，因此称之为<strong>“依赖注入”</strong>。</p><blockquote><p>这里有个疑问，PersonMapper一般是接口，无实现类，也没有@Component修饰，为什么会被装配到IoC容器中？<br>答案是，Mybatis为每个Mapper接口实现了一个动态代理类（即Mapper接口的实现类），这些动态代理类会被<code>MapperFactoryBean</code>保存起来。<code>MapperFactoryBean</code>作为接口类型被添加到IoC容器中，当需要依赖注入Mapper接口的Bean时，调用<code>MapperFactoryBean</code>的getObject()方法得到Mapper的代理类。<br>这其中的原理足够再写一篇文章，这里就不展开介绍，具体内容可以上网搜索“mapper接口依赖注入”。</p></blockquote><h2 id="Autowired和-Resource"><a href="#Autowired和-Resource" class="headerlink" title="@Autowired和@Resource"></a>@Autowired和@Resource</h2><p>@Autowired和@Resource两个注解的作用都是找到对应的Bean注入到依赖它的类中。区别是：</p><ol><li>@Autowired是Spring注解，@Resource是JDK注解</li><li>@Autowired先按类型注入，找不到再按名称注入，@Resource相反</li></ol><h2 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h2><h3 id="设值注入（set注入）"><a href="#设值注入（set注入）" class="headerlink" title="设值注入（set注入）"></a>设值注入（set注入）</h3><p>设值注入是指IoC容器通过set方法来注入被依赖对象。这种注入方式简单、直观。<br>把上面的PersonServiceImpl代码改为这样就是设值注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersonMapper</span><span class="params">(PersonMapper personMapper)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.personMapper = personMapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">personMapper.insertPerson(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><p>利用构造器来设置依赖对象的方式，被称为构造注入。通俗来说，就是驱动Spring在底层以反射方式执行带指定参数的构造器，当执行带参数的构造器时，就可利用构造器参数对成员变量执行初始化。<br>PersonServiceImpl代码改为这样就是构造注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PersonServiceImpl</span><span class="params">(@Autowired PersonMapper personMapper)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.personMapper = personMapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">personMapper.insertPerson(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Primary和-Quelifier"><a href="#Primary和-Quelifier" class="headerlink" title="@Primary和@Quelifier"></a>@Primary和@Quelifier</h2><p>这两个注解解决了一个问题：当@Autowired按类型寻找Bean，找到了多个符合条件的Bean时，应该注入哪一个？<br>举个例子，SpringBoot的官方给出的“在项目中配置多个数据源”的示例代码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.first"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">firstDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.first.configuration"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">firstDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstDataSourceProperties().initializeDataSourceBuilder().type(HikariDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.second"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">secondDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.second.configuration"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">secondDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> secondDataSourceProperties().initializeDataSourceBuilder().type(BasicDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了两个名字不同但类型相同的DataSourceProperties Bean，当有个Bean不指定名字地要求注入它依赖的DataSourceProperties对象，IoC容器就会优先注入被<code>@Primary</code>修饰的那个DataSourceProperties Bean。</p><p>当然我们更希望由自己决定注入哪一个Bean，这样更准确。这时就用<code>@Quelifier</code>注解指定要注入的Bean的名字。使用方法类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">ds1TransactionManager</span><span class="params">(@Qualifier(<span class="string">"firstDataSource"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h1><p>用<code>@Scope</code>注解可以指定Bean的作用域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig1</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="function">MyBean1 <span class="title">myBean1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyBean1 myBean1 = <span class="keyword">new</span> MyBean1();</span><br><span class="line">myBean1.setName(<span class="string">"hello1"</span>);</span><br><span class="line"><span class="keyword">return</span> myBean1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>@Scope</code>注解源码，可以看到它支持的作用域定义在<code>ConfigurableBeanFactory</code>和<code>WebApplicationContext</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scope &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"scopeName"</span>)</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specifies the name of the scope to use for the annotated component/bean.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Defaults to an empty string (&#123;<span class="doctag">@code</span> ""&#125;) which implies</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConfigurableBeanFactory#SCOPE_SINGLETON SCOPE_SINGLETON&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableBeanFactory#SCOPE_PROTOTYPE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableBeanFactory#SCOPE_SINGLETON</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.WebApplicationContext#SCOPE_SESSION</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line"><span class="function">String <span class="title">scopeName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ScopedProxyMode <span class="title">proxyMode</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ConfigurableBeanFactory</code>接口中，有两个作用域：单例和原型，它们在所有Spring IoC容器都可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableBeanFactory</span> <span class="keyword">extends</span> <span class="title">HierarchicalBeanFactory</span>, <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for the standard singleton scope: &#123;<span class="doctag">@value</span>&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Custom scopes can be added via &#123;<span class="doctag">@code</span> registerScope&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerScope</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_SINGLETON = <span class="string">"singleton"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for the standard prototype scope: &#123;<span class="doctag">@value</span>&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Custom scopes can be added via &#123;<span class="doctag">@code</span> registerScope&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerScope</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_PROTOTYPE = <span class="string">"prototype"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其他属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>WebApplicationContext</code>接口中，有三个作用域：request、session、application。它们只在实现了<code>WebApplicationContext</code>接口的容器中可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for request scope: "request".</span></span><br><span class="line"><span class="comment"> * Supported in addition to the standard scopes "singleton" and "prototype".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_REQUEST = <span class="string">"request"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for session scope: "session".</span></span><br><span class="line"><span class="comment"> * Supported in addition to the standard scopes "singleton" and "prototype".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_SESSION = <span class="string">"session"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for the global web application scope: "application".</span></span><br><span class="line"><span class="comment"> * Supported in addition to the standard scopes "singleton" and "prototype".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_APPLICATION = <span class="string">"application"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其他属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="request-session-application"><a href="#request-session-application" class="headerlink" title="request session application"></a>request session application</h2><p>单例和原型的含义大家都熟悉，这里先介绍下另外三个作用域。</p><ol><li>request: 在一次HTTP请求中，bean是单例的，再来一个HTTP请求就再实例化一个bean（容器中有保留一份bean定义，用bean定义实例化bean）。不同的HTTP请求的bean实例不同，自然也不会互相影响。HTTP请求结束bean实例就销毁</li><li>session: 和request作用于类似，但是范围是一次HTTP session</li><li>application: 在一个ServletContext中，bean是单例的。和singleton的区别是，singleton是指在一个IoC容器中bean是单例的。</li></ol><blockquote><p>ServletContext是什么？<br>一个Java Web应用都有一个ServletContext，这个应用里的所有servlet都可通过ServletContext获取初始化参数（web.xml中的<context-param>节点定义的配置）、文件路径等等，同时servlet之间还可通过ServletContext.set/getAttribute()修改和访问共有的属性。ServletContext是servlet之间，以及项目容器（如Tomcat）和WEB项目之间的桥梁。</p></blockquote><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式是是一个很出名的设计模式，常见的是懒汉式和饿汉式，但Spring采用的是登记式，且Spring允许你设置是否用懒加载（默认不用）。<br>饿汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式（线程安全）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登记式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放beanName和bean实例的map，就像bean的登记表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; registry = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Object object = registry.get(<span class="string">"singleton"</span>);</span><br><span class="line"><span class="keyword">if</span>(object == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registry.put(<span class="string">"singleton"</span>, <span class="keyword">new</span> Singleton());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">object = registry.get(<span class="string">"singleton"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (Singleton) object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这种方式的好处在于，不要求单例类的构造方法是private。因此尽管我们的controller、service未声明private构造方法，在Spring中依然可以是单例。</p><h3 id="Spring单例模式的实现"><a href="#Spring单例模式的实现" class="headerlink" title="Spring单例模式的实现"></a>Spring单例模式的实现</h3><p>Spring中的单例的概念是，在一个IoC容器中，一个Bean定义只有一个实例。上面说到Spring的单例模式是登记式，有一个bean的“登记表”，保存beanName和bean实例，当登记表中不存在bean实例，就立即创建一个并“登记”，若已有bean实例就直接返回。</p><p>“登记表”的接口<code>SingletonBeanRegistry</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the given existing object as singleton in the bean registry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the (raw) singleton object registered under the given name.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Object <span class="title">getSingleton</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其他方法，没有属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“登记表”的接口实现类<code>DefaultSingletonBeanRegistry</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面3个Map都是用于缓存</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登记表</span></span><br><span class="line"><span class="comment">/** Set of registered singletons, containing the bean names in registration order. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">Assert.notNull(singletonObject, <span class="string">"Singleton object must not be null"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">Object oldObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (oldObject != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not register object ["</span> + singletonObject +</span><br><span class="line"><span class="string">"] under bean name '"</span> + beanName + <span class="string">"': there is already object ["</span> + oldObject + <span class="string">"] bound"</span>);</span><br><span class="line">&#125;</span><br><span class="line">addSingleton(beanName, singletonObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);<span class="comment">// 加入缓存</span></span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.registeredSingletons.add(beanName); <span class="comment">// 登记</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getSingleton方法1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);<span class="comment">// 从缓存中取</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject(); <span class="comment">// 有工厂就用工厂实例化</span></span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);<span class="comment">// 加入缓存</span></span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getSingleton方法2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName); <span class="comment">// 从缓存中取</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line"><span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line"><span class="string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">beforeSingletonCreation(beanName);</span><br><span class="line"><span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject(); <span class="comment">// 从第二个参数取</span></span><br><span class="line">newSingleton = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line"><span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">ex.addRelatedCause(suppressedException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">afterSingletonCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">addSingleton(beanName, singletonObject); <span class="comment">// 加入缓存并登记</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 其他属性和方法省略 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，bean实例是何时被注册的？在IoC容器启动和程序中使用ApplicationContext.getBean()方法时。</p><p>IoC容器启动时，调用入口在IoC容器基类<code>AbstractApplicationContext.finishBeanFactoryInitialization()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单例且非懒加载的bean，beanFactory=DefaultListableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中使用ApplicationContext.getBean()方法时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">assertBeanFactoryActive();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个调用点，都会进入到AbstractBeanFactory.doGetBean()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName); <span class="comment">//调用getSingleton方法1</span></span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">//调用getSingleton方法2，后一个参数是createBean()方法返回的bean实例（且已初始化）</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可对比看下原型作用域，就是一次getBean就会调用createBean()方法返回bean实例（且已初始化）</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring为什么默认单例模式"><a href="#Spring为什么默认单例模式" class="headerlink" title="Spring为什么默认单例模式"></a>Spring为什么默认单例模式</h3><p><strong>单例bean的优势：</strong></p><ol><li><p>减少了新生成实例的消耗 新生成实例消耗包括两方面，第一spring会通过反射或者cglib来生成bean实例这都是耗性能的操作，第二给对象分配内存也会涉及复杂算法</p></li><li><p>减少jvm垃圾回收 由于不会给每个请求都新生成bean实例，所以自然回收的对象少了</p></li><li><p>可以快速获取到bean 因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快</p></li></ol><p><strong>单例bean的劣势：</strong><br>单例的bean一个很大的劣势就是他不能做到线程安全。由于所有请求都共享一个bean实例，当bean是有状态（即属性）且状态会被修改时，在并发场景下容易出现问题。而原型的bean则不会有这个问题（但也有例外，比如他被单例bean依赖），因为给每个请求都新创建实例。<br>这也是为什么我们声明的bean，如controller、service，基本不会去修改它的状态。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot配置数据源</title>
      <link href="/2020/05/30/springboot-datasource-config/"/>
      <url>/2020/05/30/springboot-datasource-config/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为工作项目的新需求涉及到在SpringBoot中配置多个MySQL数据库，为了理解如何配置，学习了SpringBoot自动配置数据源的原理，在此记录。这篇文章先介绍SpringBoot配置单个数据源的原理，再介绍多个数据源的配置方法。</p><h1 id="SpringBoot配置单个数据源"><a href="#SpringBoot配置单个数据源" class="headerlink" title="SpringBoot配置单个数据源"></a>SpringBoot配置单个数据源</h1><h2 id="未指定spring-datasource-type时，SpringBoot的默认数据源"><a href="#未指定spring-datasource-type时，SpringBoot的默认数据源" class="headerlink" title="未指定spring.datasource.type时，SpringBoot的默认数据源"></a>未指定spring.datasource.type时，SpringBoot的默认数据源</h2><p>以下面application.yml为例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server.port:</span> <span class="number">18081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span> </span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>执行Junit Test看下SpringBoot使用的默认数据源是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MysqlDemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dataSource: "</span> + dataSource.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在未指定spring.datasource.type的情况下，SpringBoot会使用默认数据源，在1.X版本中，默认数据源是org.apache.tomcat.jdbc.pool.DataSource；在2.X版本中，默认数据源是com.zaxxer.hikari.HikariDataSource。</p><blockquote><p>以下源码版本都是SpringBoot 2.3.0</p></blockquote><p>SpringBoot是怎么指定数据源的？道理在<code>DataSourceConfiguration</code>这个类，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createDataSource</span><span class="params">(DataSourceProperties properties, Class&lt;? extends DataSource&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (T) properties.initializeDataSourceBuilder().type(type).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tomcat Pool DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(org.apache.tomcat.jdbc.pool.DataSource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">DataSource</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.type"</span>, havingValue = <span class="string">"org.apache.tomcat.jdbc.pool.DataSource"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.tomcat"</span>)</span><br><span class="line">org.apache.tomcat.jdbc.pool.<span class="function">DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">org.apache.tomcat.jdbc.pool.DataSource dataSource = createDataSource(properties,</span><br><span class="line">org.apache.tomcat.jdbc.pool.DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">DatabaseDriver databaseDriver = DatabaseDriver.fromJdbcUrl(properties.determineUrl());</span><br><span class="line">String validationQuery = databaseDriver.getValidationQuery();</span><br><span class="line"><span class="keyword">if</span> (validationQuery != <span class="keyword">null</span>) &#123;</span><br><span class="line">dataSource.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">dataSource.setValidationQuery(validationQuery);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hikari DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(HikariDataSource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">DataSource</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.type"</span>, havingValue = <span class="string">"com.zaxxer.hikari.HikariDataSource"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hikari</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.hikari"</span>)</span><br><span class="line"><span class="function">HikariDataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">HikariDataSource dataSource = createDataSource(properties, HikariDataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(properties.getName())) &#123;</span><br><span class="line">dataSource.setPoolName(properties.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DBCP DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(org.apache.commons.dbcp2.BasicDataSource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">DataSource</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.type"</span>, havingValue = <span class="string">"org.apache.commons.dbcp2.BasicDataSource"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dbcp2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.dbcp2"</span>)</span><br><span class="line">org.apache.commons.dbcp2.<span class="function">BasicDataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> createDataSource(properties, org.apache.commons.dbcp2.BasicDataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generic DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(DataSource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.type"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前三个内部类Tomcat、Hikari、Dbcp2上的注解：</p><ol><li>@Configuration(proxyBeanMethods = false)：会装配Bean的配置类</li><li>@ConditionalOnClass(XXX.class)：给定的XXX.class在系统中存在时，就实例化当前Bean</li><li>@ConditionalOnMissingBean(DataSource.class)：若IOC容器中还不存在DataSource这个Bean，就在IOC容器中实例化DataSource Bean</li><li>@ConditionalOnProperty(name = “spring.datasource.type”, havingValue = “XXX”,matchIfMissing = true)：配置中，是否有<code>spring.datasource.type=XXX</code>的配置。<code>matchIfMissing = true</code>表示，即使没有指定配置，该配置类也生效</li></ol><p>因此，以Tomcat类为例，这些注解表示，若系统存在<code>org.apache.tomcat.jdbc.pool.DataSource.class</code>，即使没有配置<code>spring.datasource.type=org.apache.tomcat.jdbc.pool.DataSource</code>，也是使用<code>org.apache.tomcat.jdbc.pool.DataSource</code>作为数据源。</p><p>当我们指定了spring.datasource.type时，就使最后一个类Generic生效，它会初始化spring.datasource.type配置项指定的数据源。</p><blockquote><p>PS：为什么1.X和2.X两个版本默认的数据源不同？<br>因为在<code>spring-boot-start-jdbc 1.X</code>中，默认引入依赖<code>tomcat-jdbc</code>；而在<code>spring-boot-start-jdbc 2.X</code>中，默认引入依赖<code>HikariCP</code></p></blockquote><h2 id="指定spring-datasource-type，使用Druid数据源"><a href="#指定spring-datasource-type，使用Druid数据源" class="headerlink" title="指定spring.datasource.type，使用Druid数据源"></a>指定spring.datasource.type，使用Druid数据源</h2><p>application.yml更新为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server.port:</span> <span class="number">18081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span> </span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>再执行上面的Junit Test，可以看到dataSource换成了com.alibaba.druid.pool.DruidDataSource。这个就是由上面的<code>DataSourceConfiguration</code>类下的<code>Generic</code>初始化的。</p><h2 id="配置Druid数据库连接池参数并使其生效"><a href="#配置Druid数据库连接池参数并使其生效" class="headerlink" title="配置Druid数据库连接池参数并使其生效"></a>配置Druid数据库连接池参数并使其生效</h2><p>application.yml更新为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">filters:</span> <span class="string">stat</span></span><br><span class="line">    <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">initialSize:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">minIdle:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">    <span class="attr">validationQuery:</span> <span class="string">select</span> <span class="string">'x'</span></span><br><span class="line">    <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">maxOpenPreparedStatements:</span> <span class="number">20</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">server.port:</span> <span class="number">18081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span> </span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>但是，通过运行下面的Junit Test，我们可以看到，数据库连接池的属性如maxActive并没有生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MysqlDemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dataSource: "</span> + dataSource.getClass());</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(<span class="string">"connection: "</span> + connection);</span><br><span class="line">        <span class="keyword">if</span>(dataSource <span class="keyword">instanceof</span> DruidDataSource) &#123;</span><br><span class="line">        DruidDataSource dDataSource = (DruidDataSource) dataSource;</span><br><span class="line">        System.out.println(<span class="string">"maxActive: "</span> + dDataSource.getMaxActive());</span><br><span class="line">        System.out.println(<span class="string">"minIdle: "</span> + dDataSource.getMinIdle());</span><br><span class="line">        &#125;</span><br><span class="line">        connection.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们配置的是maxActive=20，minIdle=1，打印出来的是maxActive=8，minIdle=0。<br>什么原因呢？我们先看上面那个<code>DataSourceConfiguration</code>类下的<code>Generic</code>的方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>DataSourceProperties</code>类的源码，它用注解<code>@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</code>把”spring.datasource”下的属性映射到自己的同名属性中了，但在这个类中，和我们配置项同名的只有url、username、password、driver-class-name、type这5个属性，并没有maxActive这样的数据库连接池属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProperties</span> <span class="keyword">implements</span> <span class="title">BeanClassLoaderAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fully qualified name of the connection pool implementation to use. By default, it</span></span><br><span class="line"><span class="comment"> * is auto-detected from the classpath.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? extends DataSource&gt; type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String driverClassName;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC URL of the database.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Login username of the database.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Login password of the database.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*省略其他属性*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize a &#123;<span class="doctag">@link</span> DataSourceBuilder&#125; with the state of this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> DataSourceBuilder&#125; initialized with the customizations defined on</span></span><br><span class="line"><span class="comment"> * this instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> DataSourceBuilder&lt;?&gt; initializeDataSourceBuilder() &#123;</span><br><span class="line"><span class="keyword">return</span> DataSourceBuilder.create(getClassLoader()).type(getType()).driverClassName(determineDriverClassName())</span><br><span class="line">.url(determineUrl()).username(determineUsername()).password(determinePassword());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*省略其他方法*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@ConfigurationProperties(prefix=”spring.datasource”)注解表示把”spring.datasource”下的属性映射到实体类的同名属性上。具体可以上网搜索<code>@ConfigurationProperties</code>的原理。</p></blockquote><p>再查看<code>DataSourceBuilder</code>类build()方法源码，可以看到这里只是反射调用DruidDataSource()构造函数，建立DruidDataSource对象，没有给这个对象属性赋值。DruidDataSource中的maxActive属性是有默认值的，这个默认值就是我们打印出的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Class&lt;? extends DataSource&gt; type = getType();</span><br><span class="line">DataSource result = BeanUtils.instantiateClass(type);</span><br><span class="line">maybeGetDriverClassName();</span><br><span class="line">bind(result);</span><br><span class="line"><span class="keyword">return</span> (T) result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么怎样让我们的配置生效呢？SpringBoot的官方文档给了我们三种方法。<br>新建一个配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  第一种</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  第二种</span></span><br><span class="line"><span class="comment">//@Bean</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties("spring.datasource")</span></span><br><span class="line"><span class="comment">//public DataSource dataSource() &#123;</span></span><br><span class="line"><span class="comment">//    return DataSourceBuilder.create().type(DruidDataSource.class).build();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  第三种</span></span><br><span class="line"><span class="comment">//@Bean</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties(prefix = "spring.datasource")</span></span><br><span class="line"><span class="comment">//public DataSource dataSource(</span></span><br><span class="line"><span class="comment">//DataSourceProperties properties) &#123;</span></span><br><span class="line"><span class="comment">//return properties.initializeDataSourceBuilder().type(DruidDataSource.class).build();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种方法都能使我们的配置生效。第二种和第三种方法的里面就是反射调用DruidDataSource()构造函数。因为<code>@ConfigurationProperties</code>注解的作用，我们的配置属性被映射到了DruidDataSource对象属性上，即使DruidDataSource是通过反射建立的也会生效。</p><p>关于第三种方法，若我们的url、username、password、driver-class-name、type五个配置和别的数据库连接池配置是分开的，例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">druid:</span> </span><br><span class="line">  <span class="attr">filters:</span> <span class="string">stat</span></span><br><span class="line">  <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">initialSize:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxWait:</span> <span class="number">60000</span></span><br></pre></td></tr></table></figure><p>第三种方法就应该这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">dataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"druid"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> properties.initializeDataSourceBuilder().type(DruidDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因就是，”spring.datasource.*“属性只映射到<code>DataSourceProperties</code>对象，properties反射创建DruidDataSource对象后，”druid.*“属性才映射到DruidDataSource对象。</p><h1 id="SpringBoot-Mybatis配置多个数据源"><a href="#SpringBoot-Mybatis配置多个数据源" class="headerlink" title="SpringBoot+Mybatis配置多个数据源"></a>SpringBoot+Mybatis配置多个数据源</h1><p>这里指的是配置多个Mysql数据源。<br>配置文件application.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">db1:</span> </span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">db2:</span> </span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test2?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">filters:</span> <span class="string">stat</span></span><br><span class="line">    <span class="attr">minIdle:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">initialSize:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span>  </span><br><span class="line">    <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">3000000</span></span><br><span class="line">    <span class="attr">validationQuery:</span> <span class="string">select</span> <span class="string">'x'</span>  </span><br><span class="line">    <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">maxOpenPreparedStatements:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>理解了配置单个数据源的方法后，很容易写出多个数据源的配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.db1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">ds1DataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">ds1DataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ds1DataSourceProperties().initializeDataSourceBuilder().type(DruidDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.db2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">ds2DataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">ds2DataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ds2DataSourceProperties().initializeDataSourceBuilder().type(DruidDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用Junit Test验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MysqlMultipleDemoApplicationTests</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Object ds1DataSource = ApplicationContextUtil.getBean(<span class="string">"ds1DataSource"</span>);</span><br><span class="line"><span class="keyword">if</span>(ds1DataSource <span class="keyword">instanceof</span> DruidDataSource) &#123;</span><br><span class="line">DruidDataSource ds = (DruidDataSource) ds1DataSource;</span><br><span class="line">System.out.println(ds.getUrl());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object ds2DataSource = ApplicationContextUtil.getBean(<span class="string">"ds2DataSource"</span>);</span><br><span class="line"><span class="keyword">if</span>(ds2DataSource <span class="keyword">instanceof</span> DruidDataSource) &#123;</span><br><span class="line">DruidDataSource ds = (DruidDataSource) ds2DataSource;</span><br><span class="line">System.out.println(ds.getUrl());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的内容与我们的配置相对应。</p><p>如果是用JdbcTemplate，给不同的JdbcTemplate指定不同的数据源即可。但现在项目多是用Mybatis，有多个数据源存在时，需要把mapper.xml和mapper.java文件与数据源对应起来。<br>新建两个数据库的Mybatis配置类：<br>1.MybatisConfigDB1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// basePackages为要扫描的mapper.java所在包</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages =<span class="string">"com.example.demo.mysql.multiple.dao.test"</span>, sqlSessionTemplateRef  = <span class="string">"ds1SqlSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfigDB1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主数据源 ds1数据源</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"ds1SqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">ds1SqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"ds1DataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSessionFactoryBean sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactory.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactory.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().</span><br><span class="line">                        getResources(<span class="string">"classpath:mapper/test/*.xml"</span>));<span class="comment">// mapper.xml目录</span></span><br><span class="line">        sqlSessionFactory.setTypeAliasesPackage(<span class="string">"com.example.demo.mysql.multiple.domain.test"</span>);<span class="comment">//实体类所在包，用于生成实体类别名</span></span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ds1TransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">ds1TransactionManager</span><span class="params">(@Qualifier(<span class="string">"ds1DataSource"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ds1SqlSessionTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">ds1SqlSessionTemplate</span><span class="params">(@Qualifier(<span class="string">"ds1SqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.MybatisConfigDB2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages =<span class="string">"com.example.demo.mysql.multiple.dao.test2"</span>, sqlSessionTemplateRef  = <span class="string">"ds2SqlSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfigDB2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ds2数据源</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"ds2SqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">ds1SqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"ds2DataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSessionFactoryBean sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactory.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactory.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().</span><br><span class="line">                        getResources(<span class="string">"classpath:mapper/test2/*.xml"</span>));  </span><br><span class="line">        sqlSessionFactory.setTypeAliasesPackage(<span class="string">"com.example.demo.mysql.multiple.domain.test2"</span>);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ds2TransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">ds1TransactionManager</span><span class="params">(@Qualifier(<span class="string">"ds2DataSource"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ds2SqlSessionTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">ds1SqlSessionTemplate</span><span class="params">(@Qualifier(<span class="string">"ds2SqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以自己写个Junit Test验证，看每个数据源下的mapper.java和mapper.xml是否有效。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> 实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL笔记</title>
      <link href="/2020/05/16/mysql-note/"/>
      <url>/2020/05/16/mysql-note/</url>
      
        <content type="html"><![CDATA[<h1 id="CHAR和VARCHAR的区别"><a href="#CHAR和VARCHAR的区别" class="headerlink" title="CHAR和VARCHAR的区别"></a>CHAR和VARCHAR的区别</h1><ol><li>CHAR(m)所占字节数都是m个字节，这表示CHAR(m)是固定长度；VARCHAR(m)所占字节数是实际长度+1个字节</li><li>VARCHAR多出的一个字节是用来保存实际长度值</li><li>因为CHAR无论存储的数据长度本身是多少，都会占用固定的长度，因此存储空间会有一定的浪费；VARCHAR由于是可变长度，更节约存储空间</li><li>VARCHAR的缺点是影响性能，若UPDATE后VARCHAR列的字符串长度变长了，就需要重新分配存储空间</li><li>对于InnoDB引擎，VARCHAR的性能影响可以忽略，具体见下面存储引擎的介绍</li></ol><h1 id="DATETIME和TIMESTAMP的区别"><a href="#DATETIME和TIMESTAMP的区别" class="headerlink" title="DATETIME和TIMESTAMP的区别"></a>DATETIME和TIMESTAMP的区别</h1><ol><li>TIMESTAMP类型的字段在insert和update时可指定更新为当前时间</li><li>TIMESTAMP类型显示的时间与系统时间所处的时区有关。例如，系统时间设为东八区时，显示的值为’2018-05-24 14:59:59’；系统时间设为东九区时，显示的值为’2018-05-24 15:59:59’<br>DATETIME类型只显示插入时的时间，即显示的时间不考虑时区变化</li><li>TIMESTAMP表示的日期范围比DATETIME要短得多</li></ol><h1 id="时间类型DATETIME直接相减的结果"><a href="#时间类型DATETIME直接相减的结果" class="headerlink" title="时间类型DATETIME直接相减的结果"></a>时间类型DATETIME直接相减的结果</h1><p>如语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  create_time, update_time, update_time-create_time <span class="keyword">as</span> pay_time <span class="keyword">from</span> t_order;</span><br></pre></td></tr></table></figure><p>这样写是错的！<br>因为，mysql在时间相减时，做了个转换，但不是UNIX_TIMESTAMP(create_time)这样的转换，而是把DATETIME直接转成了整数，如create_time=’2020-05-15 08:55:25’转成了20200515085525，因此得到的是两个无意义的整数相减的结果。<br>因此，对于时间类型的相减，正确处理应该是 UNIX_TIMESTAMP(update_time)-UNIX_TIMESTAMP(create_time)</p><h2 id="HAVING和WHERE的不同使用场景"><a href="#HAVING和WHERE的不同使用场景" class="headerlink" title="HAVING和WHERE的不同使用场景"></a>HAVING和WHERE的不同使用场景</h2><p>WHERE 就用在普通的SELECT语句作为查询条件，而 HAVING 用在聚合函数的字段上。如语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> currency_type, <span class="keyword">sum</span>(amount) <span class="keyword">as</span> total_amount <span class="keyword">from</span> t_order <span class="keyword">where</span> merchant_id=<span class="string">'123456'</span> <span class="keyword">group</span> <span class="keyword">by</span> currency_type <span class="keyword">having</span> total_amount&gt;<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h1><ul><li><p>UNIX_TIMESTAMP() 返回秒数，也可以带上时间。示例：<br>SELECT UNIX_TIMESTAMP(‘2020-06-16’); == 1592265600<br>SELECT UNIX_TIMESTAMP(‘2020-06-16 02:00:00’); == 1592272800</p></li><li><p>FROM_UNIXTIME() 输入秒数返回日期字符串，日期格式可指定<br>SELECT FROM_UNIXTIME(1592265600); == 2020-06-16 00:00:00<br>SELECT FROM_UNIXTIME(1592265600, ‘%Y-%m-%d’); == 2020-06-16</p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务的四要素ACID的含义是：</p><ul><li>原子性（Atomicity）：要么全部完成，要么全部不完成</li><li>一致性（Consistency）：一个事务单元需要提交之后才会被其他事务可见</li><li>隔离性（Isolation）：并发事务之间不会互相影响，设立了不同程度的<strong>隔离级别</strong>，通过适度的破坏一致性，得以提高性能</li><li>持久性（Durability）：事务提交后即持久化到磁盘不会丢失</li></ul><p>其中，隔离级别包括：</p><ul><li>读未提交（Read Uncommitted）：可以读取未提交的记录，会出现脏读，幻读，不可重复读，所有并发问题都可能遇到</li><li>读已提交（Read Committed）：事务中只能看到已提交的修改，不会出现脏读现象，但是会出现幻读，不可重复读（大多数数据库的默认隔离级别都是 RC，但是MySQL InnoDb默认是 RR）</li><li>可重复读（Repeatable Read）：MySQL InnoDb 默认的隔离级别，解决了不可重复读问题，但是仍然存在幻读问题</li><li>序列化（Serializable）：最高隔离级别，啥并发问题都没有</li></ul><p>MySQL对事务的处理默认是“自动提交模式”。当你用<code>SHOW GLOBAL VARIABLES LIKE &#39;%autocommit%&#39;</code>可以查看autocommit开关是否打开，默认是打开的。这意味着，MySQL会在每条SQL执行完后自动提交事务，即一条SQL就是一个事务。</p><p>当你需要让多条SQL在一个事务中，需要先把autocommit开关关闭，再用SQL关键字：BEGIN、COMMIT、ROLLBACK手动开始、提交、回滚事务。需要注意，只有InnoDB引擎的表才支持事务，即在事务中只能操作InnoDB表。</p><p>和数据库有关的几个理论缩写：ACID、CAP、BASE。他们的区别可以看这篇博客：<a href="https://www.cnblogs.com/minikobe/p/11137256.html" target="_blank" rel="noopener">https://www.cnblogs.com/minikobe/p/11137256.html</a> 。总的来说，ACID不考虑数据库是否是分布式的，都要求强一致性。CAP和BASE考虑的是分布式数据库在一致性问题上的取舍。</p><h2 id="相关博客"><a href="#相关博客" class="headerlink" title="相关博客"></a>相关博客</h2><p>事务与隔离级别：<a href="https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html" target="_blank" rel="noopener">https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html</a></p><p>菜鸟教程，手动处理事务的SQL：<a href="https://www.runoob.com/mysql/mysql-transaction.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-transaction.html</a></p><p>ACID、CAP、BASE的介绍：<a href="https://www.cnblogs.com/minikobe/p/11137256.html" target="_blank" rel="noopener">https://www.cnblogs.com/minikobe/p/11137256.html</a></p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>关系数据库表是用于存储和组织信息的数据结构。我们在实际开发过程中，可能需要各种各样的表，如查询快且少更新的表、经常更新的表。表的用途上的区别，就是对数据处理上的区别。对于MySQL来说，它提供了很多种类型的存储引擎，我们可以根据对数据处理的需求，选择不同的存储引擎，从而最大限度的利用MySQL强大的功能。</p><p>MySQL存储引擎包括：InnoDB、CSV、MyISAM、MEMORY等等。使用<code>SHOW ENGINES</code>命令可以查看你的Mysql支持的所有存储引擎。</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>特点：</p><ul><li>支持行级锁（也支持表级锁）</li><li>支持事务</li><li>支持外键（MySQL支持事务和外键的存储引擎只有InnoDB）</li><li>支持AUTO_INCREMENT列</li><li>数据和索引放在同一个文件<br>创建InnoDB表时，在”MYSQL_HOME/data/db_name”文件夹下，新增2个文件：<br>table_name.frm -&gt; 存储表定义<br>table_name.ibd -&gt; 存储数据和索引</li><li>InnoDB要求表中一定有主键ID。若用户未指定，InnoDB会自动指定</li><li>使用B+Tree索引，聚集索引</li></ul><blockquote><p>问题一：为什么InnoDB一定要有主键？什么是聚集索引？答案在“InnoDB的B+Tree索引”。</p></blockquote><p>应用场景：</p><ul><li>要求事务安全</li></ul><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>特点：</p><ul><li>只支持表级锁</li><li>不支持事务和外键</li><li>支持AUTO_INCREMENT列</li><li>数据和索引分开放在两个文件<br>创建MyISAM表时，在”MYSQL_HOME/data/db_name”文件夹下，新增3个文件：<br>table_name.frm -&gt; 存储表定义<br>table_name.MYD -&gt; 存储数据<br>table_name.MYI -&gt; 存储索引</li><li>支持3种表：静态表、动态表、压缩表<ul><li>静态表：记录都是固定长度，存储非常迅速，容易缓存，出现故障容易恢复；但是占用的空间比较多。PS：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。</li><li>动态表：记录不是固定长度的，占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能</li><li>压缩表：因为每个记录是被单独压缩的，所以只有非常小的访问开支</li></ul></li><li>表中可以没有主键ID</li><li>使用B+Tree索引，非聚集索引</li></ul><p>应用场景：</p><ul><li>不要求事务安全</li><li>要求SELECT效率高</li><li>要求INSERT效率高</li><li>不经常UPDATE的表</li></ul><blockquote><p>问题二：为什么MyISAM用于不经常UPDATE的表？答案在“MyISAM的锁机制”</p></blockquote><p>要对比这两者的性能，需要先了解它们在锁机制和索引上的区别。</p><h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><p>锁的分类：</p><ul><li>表级锁：保证同一时刻只有一个线程操作<strong>该表</strong>，避免冲突<ul><li>读锁：也叫共享锁（S锁）。不拒绝其他对<strong>同张表</strong>的读请求，会拒绝对<strong>同张表</strong>的写请求。持有该锁的线程只能进行读操作</li><li>写锁：也叫排它锁（X锁）。拒绝对<strong>同张表</strong>的所有请求。持有该锁的线程可以进行读、写操作</li></ul></li><li>行级锁：保证同一时刻只有一个线程操作<strong>该记录</strong>，避免冲突<ul><li>读锁：也叫共享锁（S锁）。不拒绝其他对<strong>同条记录</strong>的读请求，会拒绝对<strong>同条记录</strong>的写请求。持有该锁的线程只能进行读操作</li><li>写锁：也叫排它锁（X锁）。拒绝对<strong>同条记录</strong>的所有请求。持有该锁的线程可以进行读、写操作</li></ul></li></ul><p>总之，在同一级中，读锁与写锁互斥，不能同时存在。写锁与其他写锁互斥，读锁与其他读锁兼容。读锁不阻碍读请求，阻碍写请求。写锁阻碍所有读写请求。</p><h2 id="MyISAM的锁机制"><a href="#MyISAM的锁机制" class="headerlink" title="MyISAM的锁机制"></a>MyISAM的锁机制</h2><p>MyISAM只支持表级锁。</p><p>什么时候锁：</p><ul><li>执行SELECT前，会自动给所有涉及到的表加读锁</li><li>执行INSERT、UPDATE、DELETE前，会自动给所有涉及到的表加写锁</li></ul><p>锁调度：</p><ul><li>线程到来时，该表已经被锁的话，锁会放入锁等待队列中</li><li>写锁优先。同时有两个线程对同一张表分别请求读锁与写锁，先加写锁。在锁等待队列中，即使读锁请求时间更早，写锁也会放到读锁之前（用户可以修改这个规则）</li></ul><blockquote><p>此处可回答问题二：为什么MyISAM用于不经常UPDATE的表？<br>因为经常性的UPDATE会不断请求表写锁，写锁优先，会导致SELECT操作阻塞，所以MyISAM表不适合经常UPDATE。</p></blockquote><p>MyISAM不会出现死锁，原因：因为MyISAM总是一次性获得所需的全部锁，例如SELECT两张表时要求一次性获得这两张表的读锁，不能全部获得就等待，直到可以全部获得为止。（可对比下面的“InnoDB为什么会出现死锁”）</p><h2 id="InnoDB的锁机制"><a href="#InnoDB的锁机制" class="headerlink" title="InnoDB的锁机制"></a>InnoDB的锁机制</h2><p>InnoDB支持行级锁、表级锁。但InnoDB的表级锁属于<strong>意向锁</strong>，和MyISAM的表级锁有点不同。</p><p>什么时候锁：</p><ul><li>行读锁：SELECT语句显式加行读锁(SELECT … LOCK IN SHARE MODE)（普通SELECT语句不会加任何锁）</li><li>行写锁：执行INSERT、UPDATE、DELETE前，会自动给所有涉及到的行加行写锁；SELECT语句显式加行写锁(SELECT … FOR UPDATE)</li><li>表读锁：也叫意向共享锁（IS锁）。给行加行读锁前，先加表读锁</li><li>表写锁：也叫意向排他锁（IX锁）。给行加行写锁前，先加表写锁</li></ul><p>总之，一个事务要查询某一行，不需要任何锁；一个事务要修改某一行，需要行写锁+表写锁。</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>行锁这个名字听起来像是这个锁加在某个数据行上，实际上在InnoDB中，行锁是加在索引上的。</p><p>这意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁（非意向锁）！</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>意向锁的含义是，MySQL察觉到事务有意向对表中的某条记录加读锁/写锁，就给整张表加个表锁。但这个表锁的兼容性和MyISAM的表级锁不同。</p><h4 id="意向锁的兼容性"><a href="#意向锁的兼容性" class="headerlink" title="意向锁的兼容性"></a>意向锁的兼容性</h4><ol><li>意向锁之间：<ol><li>IS和IS兼容</li><li>IS和IX兼容</li><li>IX和IX兼容</li></ol></li><li>意向锁IX、IS和<strong>行级</strong>S锁、X锁之间：全部互相兼容！</li><li>意向锁IX、IS和<strong>表级</strong>S锁、X锁之间：<ol><li>IS和S兼容</li><li>IS和X互斥</li><li>IX和S互斥</li><li>IX和X互斥</li></ol></li></ol><p>这里所说的不同种类的锁兼容的含义是，一张表可以同时加上这些互相兼容的锁。例如“IS和IX兼容”是指，一张表中可以同时存在多个IS锁和多个IX锁。</p><h3 id="意向锁的作用"><a href="#意向锁的作用" class="headerlink" title="意向锁的作用"></a>意向锁的作用</h3><p>第一，在没有意向锁存在的情况下，当事务A准备给t_order表加表读锁（非意向锁）时，需要确认：</p><ol><li>当前表没有被加表写锁</li><li>当前表中没有记录被加行写锁</li></ol><p>为了确认第2点，事务A需要检查每一行记录的锁，效率很低。有了意向锁之后，事务A准备给t_order表加表读锁（非意向锁）时，只需要确认：</p><ol><li>当前表没有被加IX锁</li></ol><p>若确认当前表存在IX锁，事务A就能得知当前表中一定存在行写锁，就不需要检查每行记录，只需等待IX锁释放就行。</p><p>第二，意向锁之间的互相兼容，可以提高并发性能，也能保证并发环境下的事务隔离。举个例子，<br>事务A执行SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>此时t_order表存在两把锁：表上的IX锁、id=1的记录上的X锁。</p><p>事务B执行SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>因为IX锁可以兼容，所以事务B也可以给t_order表加上IX锁，再因为id=10的记录上不存在X锁，所以事务B不需要等事务A释放锁。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>InnoDB为什么会发生死锁？</p><p>在InnoDB中，锁是<strong>逐步获得</strong>的，这就决定了在InnoDB中发生死锁是可能的。</p><p>举例，下面这句SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> score = <span class="number">100</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>这一条SQL就是一个事务，这条SQL会更新满足条件的多条记录。找到第一条记录时，会给第一条记录上锁，第一条记录更新完成后，找到第二条记录并加锁，第二条更新完成再给第三条加锁，以此类推。</p><p>若这句SQL和上面那句同时开始：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> score = <span class="number">100</span> <span class="keyword">where</span> age &gt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>假设第一条SQL的加锁顺序：id = 15 -&gt; 18 -&gt; 20，第二条SQL的加锁顺序（age为普通索引，所以会用行锁）：(age, id) = (24, 18) -&gt; (24, 20) -&gt; (25, 15) -&gt; (25, 49)。其中，对 id 的加锁顺序为 id = 18 -&gt; 20 -&gt; 15 -&gt; 49。可以看到事务A先锁15，再锁18，而事务B先锁18，再锁15，从而形成死锁。</p><h2 id="推荐博客"><a href="#推荐博客" class="headerlink" title="推荐博客"></a>推荐博客</h2><p>常见的锁类型，还介绍了索引结构：<a href="https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html" target="_blank" rel="noopener">https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html</a></p><p>意向锁的作用：<a href="https://juejin.im/post/5b85124f5188253010326360" target="_blank" rel="noopener">https://juejin.im/post/5b85124f5188253010326360</a></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引就好比一本书的目录，它会让你更快的找到内容。但目录（索引）并不是越多越好，假如这本书1000页，有500页是目录，它当然效率低，目录是要占纸张的，而索引是要占磁盘空间的。</p><p>索引用于快速找出在某个列中有一特定值的行。如果不使用索引，MySQL必须从第1条记录开始然后读完整个表直到找出相关的行。表越大，花费的时间越多。如果表中查询的列有一个索引，MySQL能快速到达一个位置去搜寻数据文件的中间，没有必要看所有数据。（这里的原理见下面B+TREE索引的介绍）</p><p>索引是帮助MySQL高效获取数据的<strong>数据结构</strong>。</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul><li>普通索引：最基本的索引，没有任何限制</li><li>唯一索引（约束）：与”普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。可指定多个列构成一个唯一索引</li><li>主键索引（约束）：它是一种特殊的唯一索引，不允许有空值</li><li>全文索引：仅可用于MyISAM表，针对较大的数据，生成全文索引很耗时间和空间</li><li>组合索引：遵循“最左”原则。创建组合索引时应该将最常用作查询条件的列放在最左边，依次递减</li></ul><h2 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h2><p><strong>单列索引：</strong><br>    SELECT UPDATE DELETE语句中WHERE条件带上索引列<br>    SELECT语句的ORDER BY/GROUP BY带上索引列</p><p><strong>组合索引：</strong><br>    SELECT UPDATE DELETE语句中WHERE条件中一定要包含最左边的索引列</p><p><strong>注意：</strong></p><ol><li>若where条件中用到索引，则order by不会再用索引</li><li>order by不使用普通索引和组合索引</li><li>模糊查询中，若查询条件这样写：… where name like ‘%cai%’，则不会用到索引（原因是%放在最前）</li><li>mysql认为全文扫描比使用索引快时，即使where条件有索引也不会用索引，例如：在一张共100条记录的表中select前90条记录<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_order <span class="keyword">where</span> <span class="keyword">id</span>&lt;=<span class="number">90</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h2><p>B+Tree是BTree的变种，MySQL的BTree索引就使用它来作为数据结构。MyISAM表、InnoDB表的索引就是用B+Tree存储，一个索引就是一个B+Tree。在B+Tree中，非叶子节点只保存key与指针，叶子节点的两个域分别是key与data。</p><h3 id="MyISAM的B-Tree索引"><a href="#MyISAM的B-Tree索引" class="headerlink" title="MyISAM的B+Tree索引"></a>MyISAM的B+Tree索引</h3><p>在MyISAM的B+Tree中，叶子节点的data域存放的是<strong>数据记录的地址</strong>，这是因为MyISAM的索引和数据是分两个文件存放的。</p><p>下面是MyISAM索引的原理图。</p><p>主键索引（key为主键列值）：</p><img src="/2020/05/16/mysql-note/myisam_primary_key.png" class="" title="MyISAM主键索引"><p>普通索引（key为普通索引列值）：</p><img src="/2020/05/16/mysql-note/myisam_key.png" class="" title="MyISAM普通索引"><p>MyISAM的主键索引和普通索引在结构上没有任何区别，只是主键索引要求key是唯一的，而普通索引的key可以重复。<br>因此，MyISAM中索引检索的算法是：首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><h3 id="InnoDB的B-Tree索引"><a href="#InnoDB的B-Tree索引" class="headerlink" title="InnoDB的B+Tree索引"></a>InnoDB的B+Tree索引</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p>第一，MyISAM的data域仅保存数据记录的地址。而InnoDB的数据和索引存放在一个文件里，数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了<strong>完整的数据记录</strong>，key是主键列值。</p><img src="/2020/05/16/mysql-note/innodb_primary_key.png" class="" title="InnoDB主键索引"><p>这种索引就叫<strong>聚集索引</strong>，即数据和主键聚在一起。正因为InnoDB的数据文件要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><blockquote><p>这里就回答了问题一：为什么InnoDB一定要有主键？什么是聚集索引？</p></blockquote><p>第二，InnoDB的普通索引data域存储相应记录主键的值而不是地址</p><img src="/2020/05/16/mysql-note/innodb_key.png" class="" title="InnoDB普通索引"><p>这样导致使用普通索引搜索需要检索两遍索引：首先检索普通索引获得主键，然后用主键到主索引中检索获得记录。</p><p>知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整（如主键最大是id=500，现在要插入id=400），十分低效，而使用自增字段作为主键则是一个很好的选择。另外，若使用int型字段做主键，InnoDB也会强制要求该字段设置AUTO_INCREMENT。</p><h1 id="MyISAN和InnoDB的对比"><a href="#MyISAN和InnoDB的对比" class="headerlink" title="MyISAN和InnoDB的对比"></a>MyISAN和InnoDB的对比</h1><p>在介绍MyISAM时说了它的INSERT效率高，一个原因是它不像InnoDB要检查外键约束，还要维护事务，减少了一部分开销。另一个原因是，B+Tree结构在插入新记录时要分裂调整，但MyISAM的data域存的是数据的物理地址，和InnoDB的data域就是记录相比，内容较小，分裂调整的速度更快。但是，MyISAM的INSERT效率不一定就比InnoDB高，一个是因为MyISAM的表锁，一个是因为InnoDB如果使用自增主键，B+Tree的调整就不会那么麻烦。</p><blockquote><p>什么是页？<br>“页”是指存储引擎从磁盘读取数据时，每次可以读取多少数据。换个说法，存储引擎每次从磁盘中读取一整页的数据，这“一整页的数据”有多少。为什么一次读取可以读到多条数据？这是因为B+Tree的一个叶子节点上就有多条数据，所以当查找到这个叶子节点时，就可以把这个叶子节点上的所有数据一次性读出来。</p></blockquote><blockquote><p>InnoDB插入数据会进行什么分裂调整？<br>因为InnoDB的数据位置是按照主键的顺序安排的，主键相近的，数据会在一个叶子节点上。若主键不是规律自增的，就会在插入时要B+Tree重新调整主键位置，即调整了数据的位置，原本靠在一起的数据也许会被分开。靠在一起的数据在一个叶子节点上，即在一个“页”上，所以这就导致了“页”的分裂。而如果主键自增，那么每次插入都是在B+Tree的最后新增数据，不会改变前面数据的位置，不用进行页分裂。</p></blockquote><p>另外，在查询效率上，也不能确定MyISAM和InnoDB谁更高，只能说各自都有优势。MyISAM的主键索引和普通索引的data域都是数据的物理地址，而InnoDB用普通索引检索时要搜两遍索引。但是，MyISAM和InnoDB的缓存机制不同，MyISAM只缓存索引，InnoDB缓存索引和数据。因此，MyISAM每次查找就要从磁盘里拿数据，而InnoDB首先从内存里获取数据，如果没有再到磁盘里拿。InnoDB内存里的数据不是一下子就缓存。InnoDB在一次IO读取中，就会把这个节点上的所有数据缓存，若下次查找的数据还在这个节点上，就可以直接从缓存中取了。如果InnoDB内存足够大，查询足够多，InnoDB速率可能会超过MyISAM。</p><p>再者，如果InnoDB用主键进行范围查找，效率是很高的，因为它相近的数据都因为主键的原因在一个“页”上，这就是聚集索引，而MyISAM的主键不是聚集索引，数据的物理地址并不会靠在一起。</p><p>但是，需要注意的是，InnoDB查找时用到了索引，才会加行锁，否则是加表锁。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法谜题》笔记</title>
      <link href="/2020/05/16/algorithmic-puzzles-note/"/>
      <url>/2020/05/16/algorithmic-puzzles-note/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　《算法谜题》中的题目，主要目的在于训练一种思维方式。这篇博客就是整理这本书中一些我认为有意思的题目。</p><h1 id="三阶幻方"><a href="#三阶幻方" class="headerlink" title="三阶幻方"></a>三阶幻方</h1><p>将1~9这9个不同的数字填入3x3的幻方，使得每行、每列、每条对角线的和相等。</p><h2 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h2><p>第一个格子可填9个数，第二个格子可填8个数，第三个格子可填7个数，以此类推，产生的可能解有9!（9的阶乘）个。对于n阶幻方，可能解数量是 (n^2)! 个。</p><h2 id="缩小范围的解法"><a href="#缩小范围的解法" class="headerlink" title="缩小范围的解法"></a>缩小范围的解法</h2><p>按以下步骤进行：</p><ol><li>这个每行、每列、每条对角线的和（称为幻和）等于15：1加到9的总和为45，3行，每行和为15</li><li>中间格子应该填5：经过中间格子的有4条线（横竖2条，斜的2条），这4条线上数字总和=15*4=45+中间格*3=15*3+中间格*3，即15=中间格*3，因此中间格=5</li><li>4组数字对(1,9) (2,8) (3,7) (4,6)，2条对角线上应该填偶数对(2,8) (4,6)：因为幻和15为奇数，所以在不经过中间格的4条线上的数字组合必须为2个偶数+1个奇数（2奇+1偶=偶），只有当对角线上都是偶数时才满足这个条件</li></ol><p>按照以上步骤，就可以得到三阶幻方的一种答案，其他答案就是由这个答案镜面翻转得到（三阶幻方一共有8个答案）。</p><h2 id="楼梯法"><a href="#楼梯法" class="headerlink" title="楼梯法"></a>楼梯法</h2><p>世界上已经有很多构造奇数阶幻方的方法了，如楼梯法、杨辉法，其中楼梯法比较适合写程序（楼梯法的介绍可以上网查）。<br>下面是实现构造k阶奇数幻方的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSquareOdd</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[][] sq = <span class="keyword">new</span> <span class="keyword">int</span>[k][k];</span><br><span class="line"><span class="comment">// 第一个数填在第一行中间</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>; <span class="comment">// 行</span></span><br><span class="line"><span class="keyword">int</span> y = k / <span class="number">2</span>; <span class="comment">// 列</span></span><br><span class="line"><span class="keyword">int</span> total = k * k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= total; i++) &#123; <span class="comment">// 按照顺序填数</span></span><br><span class="line">sq[x][y] = i;</span><br><span class="line"><span class="comment">// 下一个数填在当前位置的右上格子</span></span><br><span class="line"><span class="keyword">int</span> nextX = (x - <span class="number">1</span> + k) % k; <span class="comment">// 行-1</span></span><br><span class="line"><span class="keyword">int</span> nextY = (y + <span class="number">1</span>) % k; <span class="comment">// 列+1</span></span><br><span class="line"><span class="keyword">if</span> (sq[nextX][nextY] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 右上格子已经有数字，则填在当前位置的下一格（行+1，列不变）</span></span><br><span class="line">x = (x + <span class="number">1</span>) % k;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x = nextX;</span><br><span class="line">y = nextY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; k; n++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">System.out.print(sq[n][m] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h1><p>将n个皇后放置在n*n的国际象棋棋盘上，其中没有任何两个皇后处于同一行、同一列、同一对角线上。</p><h2 id="穷举法-1"><a href="#穷举法-1" class="headerlink" title="穷举法"></a>穷举法</h2><p>组合公式，从n个对象中选k个对象，不考虑k个对象的排列顺序：C(n,k)<br>穷举法要考虑的所有可能解的个数，即从n*n个格子中选出n个格子的组合个数C(n^2,n)。当n=4时，C(16,4)=1820，因此用穷举法解4皇后问题需要遍历1820个组合。</p><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>回溯法是对穷举法的一种改进，它采用走一步添加一个组件的方式，同时评估这一步中添加的组件是否符合题目要求，若不符合就返回上一步（回溯），从上一步重新开始考虑其他走法，若上一步往下的所有路都走不通，则再往上回溯；若符合就从这一步继续往下走，直到得出答案。<br>因此，回溯法需要遍历的可能解的数量会比穷举法少，当n=4时，考虑皇后必须放置在不同行和不同列，即第1个皇后有4种放法，第2个有3种，以此类推，可能解的数量为4!=24。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">// 存储每行放置的列的位置，如 result[0]=1 表示放在第一行第二列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">findColumn(r); <span class="comment">// 递归方法，因为要回溯，所以想到用递归实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 因为是按照每行来填，所以检查时只考虑前几行的放置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line"><span class="comment">// 和当前位置同列 || 和当前位置同一对角线</span></span><br><span class="line"><span class="keyword">if</span> ((result[i] == c) || (Math.abs(r - i) == Math.abs(c - result[i]))) &#123;</span><br><span class="line">System.out.println(<span class="string">"当前坐标：("</span> + r + <span class="string">","</span> + c + <span class="string">")和已有位置("</span> + i + <span class="string">","</span> + result[i] + <span class="string">")冲突"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findColumn</span><span class="params">(<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r == n) &#123; <span class="comment">// 每行都放完了，打印这条路的解,这条路结束</span></span><br><span class="line"><span class="comment">// print</span></span><br><span class="line">System.out.println(<span class="string">"result: "</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">System.out.println(result[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"----------------------"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++) &#123; <span class="comment">// 列</span></span><br><span class="line">System.out.println(<span class="string">"当前坐标：("</span> + r + <span class="string">","</span> + c + <span class="string">")"</span>);</span><br><span class="line"><span class="keyword">if</span> (isValid(r, c)) &#123;</span><br><span class="line">System.out.println(<span class="string">"当前坐标：("</span> + r + <span class="string">","</span> + c + <span class="string">")填1"</span>);</span><br><span class="line">result[r] = c;</span><br><span class="line">findColumn(r + <span class="number">1</span>);<span class="comment">// 寻找下一行的列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码时间复杂度为O(n^n)，即n的n次方，因为有n次递归，每次递归中遍历n列。空间复杂度为O(n)，因为用到了result[n]数组。</p><h3 id="位运算改进版实现"><a href="#位运算改进版实现" class="headerlink" title="位运算改进版实现"></a>位运算改进版实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">4</span>; <span class="comment">// n皇后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 解的总数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">find(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> row</span></span><br><span class="line"><span class="comment"> *            标记每列已占用的位置，已占用为1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ld</span></span><br><span class="line"><span class="comment"> *            标记左对角线上不能放的位置，不能放为1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rd</span></span><br><span class="line"><span class="comment"> *            标记右对角线上不能放的位置，不能放为1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> ld, <span class="keyword">int</span> rd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos, p;</span><br><span class="line"><span class="keyword">int</span> all1 = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; <span class="comment">// 1左移n位再减0001，得到n个1组成的二进制数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (row != all1) &#123;</span><br><span class="line"><span class="comment">// row，ld，rd进行“或”运算，求得所有可以放置皇后的列,对应位为0</span></span><br><span class="line"><span class="comment">// 然后取反后“与”上全1的数，来求得当前所有可以放置皇后的位置，对应列改为1</span></span><br><span class="line">pos = all1 &amp; (~(row | ld | rd));</span><br><span class="line">System.out.println(<span class="string">"可放的位置："</span> + Integer.toBinaryString(pos));</span><br><span class="line"><span class="keyword">while</span> (pos != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// pos取反+1 &amp; pos 得到pos中最右边的1</span></span><br><span class="line">p = pos &amp; (~pos + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// pos去掉最右列（最右列已占用）</span></span><br><span class="line">pos = pos - p;</span><br><span class="line"><span class="comment">// rowp 下一行已占用的列</span></span><br><span class="line"><span class="comment">// (ld|p)&lt;&lt;1 下一行不能放的列（因为左对角线被占用）</span></span><br><span class="line"><span class="comment">// (rd|p)&gt;&gt;1 下一行不能放的列（因为右对角线被占用）</span></span><br><span class="line">find(row | p, (ld | p) &lt;&lt; <span class="number">1</span>, (rd | p) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 每列都放了</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="n-gt-3时的通用解法"><a href="#n-gt-3时的通用解法" class="headerlink" title="n&gt;3时的通用解法"></a>n&gt;3时的通用解法</h2><p>因为n=1有一个解，n=2和n=3无解，所以只研究n&gt;3的通用解法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot AOP 实践与原理</title>
      <link href="/2020/03/02/springboot-aop/"/>
      <url>/2020/03/02/springboot-aop/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客先从AOP的代码编写讲起，接着介绍AOP的实现原理，其中包括动态代理的概念，最后介绍Spring中可以直接用的AOP注解。</p><h1 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h1><h2 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建切面类"><a href="#创建切面类" class="headerlink" title="创建切面类"></a>创建切面类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//声明这是一个组件</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//声明这是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义切入点"><a href="#定义切入点" class="headerlink" title="定义切入点"></a>定义切入点</h2><p>切入点就是你要在哪个包下的哪个类的哪个方法执行切面逻辑，或者说指定切入哪里。<strong>Spring AOP的切入点只能是方法。</strong><br>可以在一个切面类中定义多个切入点，再给每个切入点指定不同的Advice方法（Advice方法介绍见下一节）。<br>定义切入点有两种方式：</p><ol><li>用execution表达式定义切入点</li><li>用自定义注解定义切入点</li></ol><h3 id="用execution表达式定义切入点"><a href="#用execution表达式定义切入点" class="headerlink" title="用execution表达式定义切入点"></a>用execution表达式定义切入点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.sample.service.impl..*.*(..)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例表示在com.sample.service.impl包（含子包）下的所有类的所有方法切入。下面把这个示例拆解看看execution表达式的格式。</p><table><thead><tr><th align="left">符号</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">第一个”*”符号</td><td align="left">表示返回值的类型任意</td></tr><tr><td align="left">com.sample.service.impl</td><td align="left">要切入的类所在包名</td></tr><tr><td align="left">包名后面的”..”</td><td align="left">表示当前包及子包</td></tr><tr><td align="left">第二个”*“符号</td><td align="left">表示类名，*即任意类，也可指定具体的类，或带前后缀的类，如 *Service</td></tr><tr><td align="left">.*(..)</td><td align="left">表示任何方法名，括号表示参数，两个点表示任何参数类型</td></tr></tbody></table><p>如何使用这个切入点？示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)<span class="comment">// 这个注解以及它所修饰的方法的介绍见下一节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要同时指定<strong>多个切入点</strong>，用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut1() || pointcut2()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用自定义注解定义切入点"><a href="#用自定义注解定义切入点" class="headerlink" title="用自定义注解定义切入点"></a>用自定义注解定义切入点</h3><p>假设已有自定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME )</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义切入点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.example.demo.aop.Log)"</span>) <span class="comment">// 自定义注解的限定类名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例表示切入所有加了<code>@Log</code>属性的方法，比如下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"><span class="meta">@Log</span>(<span class="string">"添加用户操作"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user/add"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"add"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个切入点的方法和用“execution表达式”定义的切入点没有区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)<span class="comment">// 这个注解以及它所修饰的方法的介绍见下一节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这只是“自定义注解”定义的切入点的其中一种使用方式，这种使用方式的一个缺点是不能访问自定义注解<code>@Log</code>的value属性。<br>另一种使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(log)"</span>) <span class="comment">// 括号里的名字和注解参数名必须相同</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint, Log log)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 方法逻辑...</span></span><br><span class="line">     System.out.println(log.value()); <span class="comment">// 可以访问注解属性值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种使用方式的区别就是，切入点直接写在<code>@Before</code>注解中，不需要再用pointcut()方法定义切入点</p><p>和execution表达式相比，用自定义注解定义切入点，可以灵活安排切入的方法（想切哪里注解就加在哪里），且通过自定义注解的属性，在切面类中也能了解到被切方法的业务逻辑，若要在切面类中统一打印被切方法的日志，这点很好用。</p><h2 id="根据业务逻辑编写Advice方法"><a href="#根据业务逻辑编写Advice方法" class="headerlink" title="根据业务逻辑编写Advice方法"></a>根据业务逻辑编写Advice方法</h2><p>Advice，有翻译为“增强处理”，也有翻译为“通知”，本质含义就是要执行的切面逻辑，如要在每个方法开始前打印入参日志，就可以编写Before类型的Advice方法，如要在每个方法抛出异常后统一处理，就可以编写AfterThrowing类型的Advice方法。Advice一共有五种类型：</p><ul><li>Before</li><li>After</li><li>AfterReturning</li><li>AfterThrowing</li><li>Around</li></ul><p>这些类型的共同特点：</p><ul><li>所有类型的注解都有两个属性：value、argNames。value属性用于指定切入点，argNames属性可以用来访问目标方法的入参</li><li>除<code>Around</code>之外，其他四种类型的方法的连接点参数都只能是JoinPoint，不能是ProceedingJoinPoint（ProceedingJoinPoint是JoinPoint的子类）</li><li>只有<code>Around</code>方法能改变目标方法的入参和返回值</li></ul><p>下面分别介绍这五种类型的特点和使用方法。</p><h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><p>在目标方法执行前织入，不能访问目标方法的返回值，可选参数有JoinPoint。<br><code>@Before</code>注解属性：value、argNames</p><blockquote><p>JoinPoint简单介绍：<br>JoinPoint参数不必须，但需要时必须作为第一个参数！<br>常用方法有：<br>Object[] getArgs：返回目标方法的参数<br>Signature getSignature：返回目标方法的签名(含方法名和参数表)</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"============before============"</span>);</span><br><span class="line">    System.out.println(<span class="string">"目标方法名为:"</span> + joinPoint.getSignature().getName()); <span class="comment">// 打印方法名add</span></span><br><span class="line">    System.out.println(<span class="string">"目标方法所属类的类名:"</span> + joinPoint.getSignature().getDeclaringTypeName());<span class="comment">// 打印全限定类名com.example.demo.controller.UserController</span></span><br><span class="line">    <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"第"</span> + (i+<span class="number">1</span>) + <span class="string">"个参数为:"</span> + args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><p>在目标方法结束后织入，不管目标方法如何结束（正常还是异常），它都会被织入，可选参数有JoinPoint。<br><code>@After</code>注解和<code>@Before</code>注解属性相同：value、argNames<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"============after============"</span>);</span><br><span class="line">    <span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AfterReturning"><a href="#AfterReturning" class="headerlink" title="AfterReturning"></a>AfterReturning</h3><p>在目标方法正常完成后被织入，抛出异常了不织入，可选参数有JoinPoint和Object（目标方法的返回值）。<br><code>@AfterReturning</code>注解除了value、argNames这两个属性外，还有一个属性：</p><ul><li>returning：指定一个返回值形参名，可以通过该形参名来访问目标方法的返回值，但不可修改目标方法的返回值</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(pointcut = <span class="string">"pointcut()"</span>, returning = <span class="string">"returnObject"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(JoinPoint joinPoint, Object returnObject)</span> </span>&#123; <span class="comment">// 返回值的形参名与注解中的保持一致</span></span><br><span class="line">    System.out.println(<span class="string">"============afterReturning============"</span>);</span><br><span class="line">    <span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line">    <span class="comment">// 访问目标方法的返回值</span></span><br><span class="line">    System.out.println(<span class="string">"返回值："</span> + returnObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AfterThrowing"><a href="#AfterThrowing" class="headerlink" title="AfterThrowing"></a>AfterThrowing</h3><p>在目标方法抛出异常时织入，正常完成不织入，可选参数有JoinPoint和Throwable（目标方法抛出的异常）。<br><code>@AfterThrowing</code>注解除了value、argNames这两个属性外，还有一个属性：</p><ul><li>throwing：指定一个异常形参名，形参可用于访问目标方法抛出的异常</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(throwing = <span class="string">"e"</span>, pointcut = <span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable e)</span> </span>&#123; <span class="comment">// 异常的形参名与注解中的保持一致</span></span><br><span class="line">System.out.println(<span class="string">"============afterThrowing============"</span>);</span><br><span class="line"><span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line"><span class="comment">// 打印异常</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这个AfterThrowing只能用在打印异常信息，不能对抛出的异常做更多处理，也不能针对异常来改变目标方法的返回值。<br>想要根据异常信息修改目标方法返回值，只能用下面讲的Around。</p><h3 id="Around"><a href="#Around" class="headerlink" title="Around"></a>Around</h3><ul><li>可以在执行目标方法前织入，也可以在执行后织入</li><li>可以决定目标方法在什么时候执行，如何执行，可以完全阻止目标方法的执行</li><li>可以修改目标方法的参数值，也可以修改目标方法的返回值</li><li>至少包含一个参数，且第一个参数必须是ProceedingJoinPoint</li><li>在方法体内，调用ProceedingJoinPoint的proceed()方法才会执行目标方法。如果方法体内没有调用这个proceed()方法，则目标方法不会执行</li><li>最后必须把获得的目标方法的返回值，作为@Around方法的返回值return回去(因为如果无返回值的话，将不会继续执行目标方法)</li></ul><p><code>@Around</code>注解属性：value、argNames</p><p>第一个示例，没修改目标方法入参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">          <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">          Object[] args = joinPoint.getArgs();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">              System.out.println(<span class="string">"第"</span> + (i+<span class="number">1</span>) + <span class="string">"个参数为:"</span> + args[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 返回值</span></span><br><span class="line">          Object re = joinPoint.proceed();</span><br><span class="line">          <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第二个示例，修改了目标方法入参（入参为基本类型和String）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">        <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 修改参数值</span></span><br><span class="line">            args[i] += <span class="string">"updated"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        Object re = joinPoint.proceed(args); <span class="comment">// 这里要把修改后的args作为proceed方法的参数</span></span><br><span class="line">        <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个示例，修改了目标方法入参（入参为对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">        <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        Object param = args[<span class="number">0</span>];</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">if</span>(param <span class="keyword">instanceof</span> Person)</span><br><span class="line">        person = (Person) param;</span><br><span class="line">        person.setAddress(<span class="string">"address"</span>); <span class="comment">// 修改参数对象属性</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        Object re = joinPoint.proceed(); <span class="comment">// 这里不用再把修改后的args作为proceed方法的参数</span></span><br><span class="line">        <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，关于Around中的异常捕获：</p><ol><li>只有从目标方法中抛出的异常才会被捕获，若目标方法内自己try-catch异常了没有抛出，就不会触发Around的异常捕获</li><li>Around中处理异常，返回的响应类型必须和目标方法声明的一致，即必须是目标方法的返回类及其子类，否则会出现强制转换报错</li></ol><h1 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h1><p>AOP的全称是Aspect Oriented Programming，面向切面编程，它是通过动态代理技术，将Aspect方法中的逻辑完整织入到切入点中。下面开始先介绍静态代理（即设计模式中的代理模式），再介绍动态代理，最后再说说Spring是怎么用动态代理实现AOP的。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在设计模式中，常用到代理模式，它一般由一个接口和这个接口的两个实现类组成。<br>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"message: "</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProxy</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Service service; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceProxy</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">doBefore();</span><br><span class="line"><span class="keyword">this</span>.service.printMessage(msg);</span><br><span class="line">doAfter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行代理方法前的处理（前置处理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========proxy start========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行完代理方法后的处理（后置处理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========proxy end========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代理类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">ServiceProxy proxy = <span class="keyword">new</span> ServiceProxy(service);</span><br><span class="line">proxy.printMessage(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，静态代理需要我们自己编写代理类ServiceProxy，在它的printMessage方法中加上前置处理和后置处理。而动态代理，就不用我们自己写代理类，就能把我们指定的前置后置处理方法加到被代理方法的前后流程中。下面介绍动态代理的实现。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理，简单地说，就是不用自己写代理类，而是在运行时自动生成代理类和代理类对象。<br>接口Service和实现类ServiceImpl代码同上，不再赘述。</p><p>动态代理类：<br>作用：在运行时生成被代理类对象，规定执行被代理对象的目标方法的流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object _obj = <span class="keyword">null</span>; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object _obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>._obj = _obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   proxy 代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   method 被代理对象的目标方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   args 被代理对象的目标方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  被代理对象的目标方法的执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// 此处可以编写前置处理...</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(_obj, args); <span class="comment">// 反射执行被代理对象的目标方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用动态代理类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(service); <span class="comment">// 放入被代理对象</span></span><br><span class="line"><span class="comment">// 使用JDK中的Proxy类生成Service类的代理对象</span></span><br><span class="line">Service proxy = (Service) Proxy.newProxyInstance(service.getClass().getClassLoader(),</span><br><span class="line">service.getClass().getInterfaces(), dynamicProxy); </span><br><span class="line">proxy.printMessage(<span class="string">"hello"</span>); <span class="comment">// 这一步其实就是执行dynamicProxy.invoke方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码很简单地实现了动态代理：自己不用写Service类的代理类，运行时才生成Service类的代理类和代理对象。</p><p>当然AOP的实现没有这么简单，它还需要把切面类织入到切入点中。</p><h2 id="AOP的动态代理"><a href="#AOP的动态代理" class="headerlink" title="AOP的动态代理"></a>AOP的动态代理</h2><p>以下代码可以简单实现AOP逻辑。<br>接口Service和实现类ServiceImpl代码同上，不再赘述。</p><p>切面接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aspect</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">useAround</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectImpl</span> <span class="keyword">implements</span> <span class="title">Aspect</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doBefore========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAfter========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAfterReturning========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAfterThrowing========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAround Start========"</span>);</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">System.out.println(<span class="string">"========doAround End========"</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">useAround</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object _obj = <span class="keyword">null</span>; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Aspect _aspect; <span class="comment">// 切面类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object _obj, Aspect _aspect)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>._obj = _obj;</span><br><span class="line"><span class="keyword">this</span>._aspect = _aspect;</span><br><span class="line">Object proxy = Proxy.newProxyInstance(_obj.getClass().getClassLoader(), _obj.getClass().getInterfaces(), <span class="keyword">this</span>); <span class="comment">// 代理对象</span></span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment"> *            代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> *            被代理对象的目标方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> *            被代理对象的目标方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被代理对象的目标方法的执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">Object result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">_aspect.doBefore();</span><br><span class="line"><span class="keyword">if</span> (_aspect.useAround()) &#123;</span><br><span class="line">result = _aspect.doAround(_obj, method, args);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = method.invoke(_obj, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">hasException = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_aspect.doAfter();</span><br><span class="line"><span class="keyword">if</span> (hasException) &#123;</span><br><span class="line">_aspect.doAfterThrowing();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">_aspect.doAfterReturning();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用动态代理类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy();</span><br><span class="line">Service proxy = (Service) dynamicProxy.getProxy(service, <span class="keyword">new</span> AspectImpl());</span><br><span class="line">proxy.printMessage(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doBefore&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAround Start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">message: hello</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAround End&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAfter&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAfterReturning&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>可以看出，以上代码成功把切面类AspectImpl的逻辑织入到了被代理对象的目标方法中。因此，Spring AOP的原理就是，Spring中有一个类似于动态代理类DynamicProxy的类，帮我们把切面类织入到切入点了。<br>Spring的动态代理机制：</p><ol><li>JDK动态代理。只能代理实现了接口的类，是Spring的首选机制。上面代码所展现的就是这个机制。</li><li>CGLIB动态代理。不要求被代理类必须实现接口，但不能代理final类。当被代理类没有实现接口时，Spring就用这个机制。</li></ol><h1 id="Spring中已实现的AOP"><a href="#Spring中已实现的AOP" class="headerlink" title="Spring中已实现的AOP"></a>Spring中已实现的AOP</h1><p>Spring中有一些已经写好的切面逻辑，可以直接拿来用。</p><h2 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h2><p>用<code>@ControllerAdvice</code>注解修饰的类，可以对Controller中用<code>@RequestMapping</code>修饰的方法做切面处理，最常用的是统一处理Controller方法抛出的异常。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span> <span class="comment">// 响应体是json格式就必须加这个注解</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>) // 指定抛出的异常类型</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">JSONObject</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123; <span class="comment">// 在这个方法中写抛出异常后的处理</span></span><br><span class="line">System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">json.put(<span class="string">"code"</span>, <span class="string">"9999"</span>);</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"System Error"</span>);</span><br><span class="line"><span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例是指，当Conrtroller方法中抛出异常时，统一返回<strong>{“msg”:”System Error”,”code”:”9999”}</strong>响应体。<br>若需要统一跳到某个页面，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>) // 指定抛出的异常类型</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ModelAndView</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123; <span class="comment">// 在这个方法中写抛出异常后的处理</span></span><br><span class="line">    System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">//指定错误页面的模板页</span></span><br><span class="line">        mav.setViewName(<span class="string">"error"</span>);</span><br><span class="line">        mav.addObject(<span class="string">"code"</span>, ex.getCode());</span><br><span class="line">        mav.addObject(<span class="string">"msg"</span>, ex.getMsg());</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：当AOP切面和@ControllerAdvice同时存在，且AOP切面里也会统一处理Controller抛出的异常，@ControllerAdvice就不一定会执行。请看下面的例子。<br>AOP切面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(log)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint, Log log)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">            <span class="comment">// 返回值</span></span><br><span class="line">            Object re = joinPoint.proceed();</span><br><span class="line">            <span class="keyword">if</span>(re <span class="keyword">instanceof</span> JSONObject)</span><br><span class="line">            result = (JSONObject) re;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            result.put(<span class="string">"code"</span>, <span class="string">"9998"</span>);</span><br><span class="line">            result.put(<span class="string">"msg"</span>, <span class="string">"error"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ControllerAdvice的修饰类同上，不再赘述。<br>运行时发现，目标方法抛出异常时，会统一返回<strong>{“msg”:”error”,”code”:”9998”}</strong>，而不会返回@ControllerAdvice中的<strong>{“msg”:”System Error”,”code”:”9999”}</strong>。原因就是AOP中已经处理好异常了。<br>若仍然想把异常交给@ControllerAdvice处理，AOP切面可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(log)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint, Log log)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">            <span class="comment">// 返回值</span></span><br><span class="line">            Object re = joinPoint.proceed();</span><br><span class="line">            <span class="keyword">if</span>(re <span class="keyword">instanceof</span> JSONObject)</span><br><span class="line">            result = (JSONObject) re;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e; <span class="comment">// 把异常抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，目标方法抛出异常时，会统一返回@ControllerAdvice中的<strong>{“msg”:”System Error”,”code”:”9999”}</strong>。原因就是AOP中把异常抛出了。</p><h3 id="404异常处理"><a href="#404异常处理" class="headerlink" title="404异常处理"></a>404异常处理</h3><p>没有什么特殊配置的情况下，Spring Boot遇到404就会自动跳到Spring Boot的error页面。若想要自己处理404异常，可以使用@ControllerAdvice。顺便一提，由于接口不存在，所以404异常肯定不会被AOP切面处理。<br>要处理404异常，必须在配置文件中加上：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出现错误时, 直接抛出异常</span></span><br><span class="line"><span class="attr">spring.mvc.throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 不要为我们工程中的资源文件建立映射</span></span><br><span class="line"><span class="attr">spring.resources.add-mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这个配置一定要加，否则Spring Boot总是会帮我们处理404异常，而不会进入我们定义的方法中。<br>然后就是在@ControllerAdvice中处理404，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">JSONObject</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line"><span class="keyword">if</span>(ex <span class="keyword">instanceof</span> NoHandlerFoundException) &#123; <span class="comment">// 404异常</span></span><br><span class="line">json.put(<span class="string">"code"</span>, <span class="string">"9997"</span>);</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"No Found"</span>);</span><br><span class="line"><span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line">json.put(<span class="string">"code"</span>, <span class="string">"9999"</span>);</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"System Error"</span>);</span><br><span class="line"><span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以发现，访问不存在的URI时，会统一返回<strong>{“msg”:”No Found”,”code”:”9997”}</strong>。</p><h2 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h2><p>这个注解帮你实现了数据库事务逻辑，尤其是事务回滚。<br>举个例子，删除用户时，要把用户关联的权限一起删除，当删除用户成功但删除权限不成功时，应该把删除用户的操作回滚，使得数据一致。<br>服务层示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaintainService</span> <span class="keyword">implements</span> <span class="title">IMaintainService</span></span>&#123;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">// 事务回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，当deletePersonPrivilege方法抛出异常时，deleteById方法会被回滚，即数据库中用户和用户权限依然存在，说明回滚成功。另外，回滚成功后，依然会进入AOP切面中的异常捕获。<br>下面介绍<code>@Transactional</code>注解使用的注意点。</p><h3 id="Transactional只能用在public方法上"><a href="#Transactional只能用在public方法上" class="headerlink" title="@Transactional只能用在public方法上"></a>@Transactional只能用在public方法上</h3><p>Spring在回滚前会检查方法修饰符是不是public，是才回滚。</p><h3 id="Transactional的rollbackFor属性"><a href="#Transactional的rollbackFor属性" class="headerlink" title="@Transactional的rollbackFor属性"></a>@Transactional的<strong>rollbackFor</strong>属性</h3><p>默认情况下，只有抛出Error类，或RuntimeException类及其子类的异常，Spring才会回滚。其他类型的异常不会回滚。<br>若需要在抛出其他异常时回滚，可以指定<strong>rollbackFor</strong>属性，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor=Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">deletePerson</span>(<span class="title">int</span> <span class="title">personId</span>) </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，只有抛出Exception类及其子类的异常，Spring才会回滚。</p><h3 id="自调用问题"><a href="#自调用问题" class="headerlink" title="自调用问题"></a>自调用问题</h3><p>上面的示例，<code>@Transactional</code>注解修饰的方法会直接被Controller层接口调用，这种情况下都能回滚成功。但也有一些特殊情况。<br>情况1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，<code>@Transactional</code>不会生效。应改为下面这样才能生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 异步调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 异步调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种有异步线程存在的情况下，<code>@Transactional</code>无论加在哪个方法都不会生效。<br>因此，只有把<code>@Transactional</code>注解加在直接被外部调用的方法才能生效。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理描述 </tag>
            
            <tag> 实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的时间类型转换</title>
      <link href="/2020/02/25/java-date-trans/"/>
      <url>/2020/02/25/java-date-trans/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java中表示时间有三种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String dateStr = <span class="string">"2020-01-01 15:00:11"</span>; <span class="comment">// String类型</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(); <span class="comment">// Date类型</span></span><br><span class="line"><span class="keyword">long</span> time = date.getTime(); <span class="comment">// long类型</span></span><br></pre></td></tr></table></figure><p>　　这三种类型的不同在于，String类型不带时区信息，Date和long类型会带时区信息。开发项目时，接口参数的时间字段最好用long类型表示，这样发送方和接收方收到的时间会一致。用String类型也能一致，但双方可能都要做格式转换。用Date类型做接口参数时，接收方和收到的值可能与发送方的不一致，不适合验签。</p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><h3 id="Date转String"><a href="#Date转String" class="headerlink" title="Date转String"></a>Date转String</h3><p>看一下电脑上的时间，得知当前时间是8时区的2020-02-25 15:41:21（系统时区是8时区）。<br>按照<code>yyyy-MM-dd HH:mm:ss</code>的格式打印当前时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date(); <span class="comment">// 当前时间</span></span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>; <span class="comment">// 注意，月份M大写，分钟m小写</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">System.out.println(sdf.format(d)); <span class="comment">// 2020-02-25 15:41:21</span></span><br></pre></td></tr></table></figure><p>打印结果和电脑上显示的一致。</p><h4 id="转换时考虑时区"><a href="#转换时考虑时区" class="headerlink" title="转换时考虑时区"></a>转换时考虑时区</h4><p>若想知道当前时间对应的GMT0时间是多少，就要在转换时加上时区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date(); <span class="comment">// 当前时间</span></span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">String timezone = <span class="string">"GMT+0"</span>; <span class="comment">// 时区</span></span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">System.out.println(sdf.format(d)); <span class="comment">// 2020-02-25 07:41:21</span></span><br></pre></td></tr></table></figure><p>打印结果<strong>2020-02-25 07:41:21(GMT0)</strong>和当前时间<strong>2020-02-25 15:41:21(GMT8)</strong>可以对应。</p><h3 id="Date转long"><a href="#Date转long" class="headerlink" title="Date转long"></a>Date转long</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="keyword">long</span> time = date.getTime();</span><br></pre></td></tr></table></figure><h2 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h2><h3 id="long转Date"><a href="#long转Date" class="headerlink" title="long转Date"></a>long转Date</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">Date d = <span class="keyword">new</span> Date(currentTimeMillis);</span><br></pre></td></tr></table></figure><h3 id="long转String"><a href="#long转String" class="headerlink" title="long转String"></a>long转String</h3><p>先long转Date，再Date转String。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String转Date"><a href="#String转Date" class="headerlink" title="String转Date"></a>String转Date</h3><p>若已知时间字符串”2020-02-25 10:44:05”是8时区，系统也是8时区，那么转换时可以简单的写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"2020-02-25 10:44:05"</span>;</span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>; <span class="comment">// 时间字符串的格式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Tue Feb 25 10:44:05 CST 2020</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>10:44:05</strong>和时间字符串<strong>2020-02-25 10:44:05(GMT8)</strong>一致。</p><blockquote><p>CST时间：China Standard Time，中国标准时间，等于GMT8</p></blockquote><h4 id="转换时考虑时区-1"><a href="#转换时考虑时区-1" class="headerlink" title="转换时考虑时区"></a>转换时考虑时区</h4><p>但如果已知”2020-02-25 10:44:05”这个字符串是0时区，那么就要指定时区转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"2020-02-25 10:44:05"</span>;</span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>; <span class="comment">// 时间字符串的格式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">String timezone = <span class="string">"GMT+0"</span>; <span class="comment">// 时间字符串的时区</span></span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Tue Feb 25 18:44:05 CST 2020</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>18:44:05</strong>和时间字符串<strong>2020-02-25 10:44:05(GMT0)</strong>一致。</p><h4 id="复杂格式的时间字符串转换"><a href="#复杂格式的时间字符串转换" class="headerlink" title="复杂格式的时间字符串转换"></a>复杂格式的时间字符串转换</h4><p>处理复杂的时间字符串，如<strong>PDT时间</strong>：</p><blockquote><p>PDT时间：Pacific Daylight Time，太平洋夏季时间，等于UTC-7，UTC=GMT0，因此PDT=GMT8-15<br>PST时间：Pacific Standard Timee，太平洋标准时间，等于PDT-1，因此PST=GMT8-16</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"03:00:14 Jun 13, 2019 PDT"</span>; <span class="comment">// pdt时间2019-06-13 03:00:14</span></span><br><span class="line">String format = <span class="string">"HH:mm:ss MMM dd, yyyy z"</span>; <span class="comment">// z表示时区</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format, Locale.ENGLISH); <span class="comment">// 当字符串中有英文单词时要加上Locale参数</span></span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Thu Jun 13 18:00:14 CST 2019</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>18:00:14</strong>和时间字符串<strong>2019-06-13 03:00:14(PDT)</strong>一致。</p><p>处理<strong>UTC时间</strong>（UTC=GMT0）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"2019-04-24T02:30:00"</span>;</span><br><span class="line">String format = <span class="string">"yyyy-MM-dd'T'HH:mm:ss"</span>; <span class="comment">// 时间格式，注意T带引号</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">String timezone = <span class="string">"GMT+0"</span>; <span class="comment">// 时间字符串的时区</span></span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Wed Apr 24 10:30:00 CST 2019</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>10:30:00</strong>和时间字符串<strong>2019-04-24 02:30:00(UTC)</strong>一致。</p><h3 id="String转long"><a href="#String转long" class="headerlink" title="String转long"></a>String转long</h3><p>先String转Date，再Date转long。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《算法图解》笔记</title>
      <link href="/2020/02/23/grokking-algorithms-note/"/>
      <url>/2020/02/23/grokking-algorithms-note/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　《算法图解》这本书真的非常好懂，它结合图画，对算法基础知识讲得很透，把“每一步要怎么做”和“为什么这样做”都交代了。这些知识以前在学校也学习过，但那时候只记住算法每一步怎么做，时间复杂度也是硬背的，根本没去理解背后的原因。这样的后果就是学完就忘。这本书就很适合我这种对算法稍微懂点但又不是很懂的人，它帮我把以前的疑惑都解开了。但它有个局限性就是，只讲基础，对稍微难点的内容都是一笔带过，只能靠个人去学，真正的入门书。<br>　　因为作者就像聊天似的教算法，图画也多，所以这本书的知识点比较散，这篇博客就是将我从这本书学到的知识点记录下来。</p><h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2><ul><li>大O表示法体现的是随着元素数量n的增多，操作次数的增长趋势。如O(logn)（二分查找）的增长趋势明显比0(n)（简单查找）要慢得多，因此可以说二分查找比简单查找更好</li><li>大O表示法一般是该算法在最糟情况下的速度，但算法也有平均情况（也是最优情况）下的速度。如快速排序最糟O(n^2)，平均O(nlogn)</li><li>大O表示法不含常量的原因：当元素数量很多时，常量对速度的影响可忽略不计</li><li>O(1)表示常量时间，含义是无论元素数量多少，所需时间都一样</li></ul><p><strong>注：</strong></p><ol><li>这本书里只讨论时间复杂度，没讲空间复杂度</li><li>logn就是log2n，即2的幂</li></ol><h2 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h2><ul><li>在内存方面：数组元素的内存地址是相邻的，链表元素的内存地址不用相邻，链表的每个元素中都会存放下一个元素的内存地址</li><li>在查找方面：链表只能顺序查找，而数组可以随机访问到任一元素，因此说数组的查找效率更好</li><li>在插入和删除方面：链表的插入和删除只是改变某个元素存储的下一个元素的地址，数组的插入要重新分配内存，删除时要把后面的元素往前移</li><li>链表的插入和删除都是O(1)，这不包括“查找插入/删除位置”的时间</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li>递归没有什么性能优势，只是让代码更清晰。可以用递归实现的也能用循环实现</li><li>每个递归都包含两个条件：递归条件–让函数调用自己的条件，基线条件–函数return的条件（即不再递归的条件）</li><li>每次递归调用都会加入到调用栈，占用内存，执行完就会从调用栈弹出</li></ul><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>　　在调用栈过高的情况下，可以写成尾递归的形式。尾递归就是手动把本次调用的计算结果作为递归函数的参数，这样在return时就直接return递归，而不是还要先处理递归结果再return。<br>　　下面以阶乘函数为例，展示递归和尾递归的不同写法：</p><p><strong>普通递归：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> n * fac(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尾递归：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fac2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">//第一次调用时t=1</span></span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> fac2(n - <span class="number">1</span>, n * t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　写成尾递归后，若编译器会自动帮你把尾递归代码优化就会很好用（jvm不会），否则需要你手动把尾递归代码优化了才会有节省栈内存的效果。尾递归可以优化的原因：每次递归都计算出了一个结果，上一次递归的结果就没必要保留，可以释放内存。</p><h2 id="分而治之（D-amp-C）"><a href="#分而治之（D-amp-C）" class="headerlink" title="分而治之（D&amp;C）"></a>分而治之（D&amp;C）</h2><ul><li><p>分而治之是一种递归式的问题解决方法。思路是缩小问题范围，思考解决小问题的方法，能解决小问题的方法也适用于大问题。欧几里得算法就是这个思路</p><blockquote><p>两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数</p></blockquote></li><li><p>工作过程：a.找出基线条件，这个条件必须尽可能简单；b.缩小问题的规模，使其符合基线条件</p></li><li><p>要处理的对象是数组时，基线条件一般是数组为空或只含一个元素</p></li></ul><p><strong>举例：</strong>求数组[1,2,3,4,5]的总和，基线条件为：当数组只有一个元素时数组总和就等于这个元素。做法就是：不断挑出一个元素，使数组规模变小，求(挑出的元素+数组剩余元素总和)的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span>[] aArr = <span class="keyword">new</span> <span class="keyword">int</span>[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">aArr[i - <span class="number">1</span>] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">0</span>] + sum(aArr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码只是为了说明“分而治之”的思想，一般情况下求数组总和还用不到递归。</p><p><strong>注：</strong>这本书说的“分而治之”的概念是其他一些教材说的“减而治之”。一些人把“减而治之”看作是“分而治之”的一种特殊情况，作者这样写也没错。</p><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><ul><li>由数组和散列函数组成，通过散列函数将要存储的值计算成数组索引，值就放在索引处</li><li>良好的散列函数会尽量覆盖数组的每个位置，即每个值都放在不同位置</li></ul><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul><li>只适用于有序数列</li><li>运行时间为O(logn)，就是把一串数字对半分，直到只剩一个数字的次数</li><li>操作过程也运用了递归思想。基线条件：数组中间元素与目标相同；递归条件：当中间的元素不对，对一半数组继续二分查找</li></ul><p><strong>循环式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> high = n.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> i = n[mid];</span><br><span class="line"><span class="keyword">if</span> (i == target)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &lt; target) &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[] n, <span class="keyword">int</span> target, <span class="keyword">int</span> high, <span class="keyword">int</span> low)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> num = n[mid];</span><br><span class="line"><span class="keyword">if</span> (num == target)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num &lt; target) &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> binarySearch2(n, target, high, low);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li>重复从数组中挑出最大或最小的元素放入新数组，直到原数组没有元素了</li><li>运行时间为0(n^2)，从n个元素中挑最大或最小（相当于把每个元素检查一遍），要挑n次，所以是n*n</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li>过程：选出一个基准值pivot，比基准值小的数作为一个子数组a1，比基准值大的数作为子数组a2，qsort(a1) + pivot + qsort(a2)就是结果</li><li>平均情况下运行时间是O(nlogn)，即<strong>随机选取基准值</strong>，子数组a1和a2的元素个数基本是原数组的一半，调用栈高为logn，每一层栈要处理的元素数是n，所以是n*logn</li><li>最糟情况下运行时间是O(n^2)，即<strong>选取的基准值是最大或最小数</strong>，子数组a1和a2中总有一个为空，此时调用栈高为n，每一层栈要处理的元素数是n，所以是n*n</li></ul><p><strong>附：</strong>合并排序（Merge Sort）<br>　　合并排序就是把数组对半分，再递归把子数组对半分直到只有一个元素（栈高度logn），每一次对半分好后通过比较两个子数组的元素合并为一个有序数组（操作元素数n），合并排序的平均和最糟情况都是0(nlogn)</p><h2 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h2><ul><li><p>图的结构包含：节点(V)和边(E)</p></li><li><p>树是一种特殊的图：不存在子节点往父节点指的边</p></li><li><p>节点之间有严格的先后顺序的图，叫拓扑排序</p></li><li><p>非加权图找最短路径：广度优先搜索<br>广度优先搜索就是，从起点开始，判断走一步能到达的顶点中有没有终点，若没有，就判断走两步能到达的顶点中有没有终点。。。找到终点后，走的步数就是最短路径。广度优先搜索首先能判断是否能到达终点，其次求出到达终点的最短路径。运行时间O(V+E)。</p></li><li><p>加权图（不含负权边）找最短路径（即权重之和最小）：狄克斯特拉算法<br>狄克斯特拉算法的思路：</p><ol><li>从所在节点的相邻节点中，找出“最便宜”的节点，即到达此相邻节点的权重最小</li><li>到达上一步所述的“最便宜”的节点后，更新从起点到达该“最便宜”节点的相邻节点的权重和</li><li>重复这个过程，直到对图中的每个节点都这样做了</li><li>计算最终路径的权重之和</li></ol></li><li><p>加权图（含负权边）找最短路径（即权重之和最小）：贝尔曼-福德算法</p></li><li><p>狄克斯特拉算法不适合用在带环的图</p></li></ul><h2 id="NP完全问题（NPC）"><a href="#NP完全问题（NPC）" class="headerlink" title="NP完全问题（NPC）"></a>NP完全问题（NPC）</h2><ul><li><p>无法快速找到最优解的就是NP完全问题</p></li><li><p><em>集合覆盖问题</em> 和 <em>旅行商问题</em> 就是典型的NP完全问题。背包问题属于集合覆盖问题。</p></li><li><p>解决NP完全问题，最好使用近似算法。贪婪算法就是近似算法的一种，无法得到最优解，但也接近最优解<br>贪婪算法，就是在限制的条件内，每一步都采取最优的做法。如背包问题中，每次都放入价值最高的物品，直到放不下为止</p></li><li><p>动态规划可以帮助找到NP完全问题的最优解</p><ul><li><p>可以使用动态规划的条件有：</p><ul><li>问题可以分解为互相独立的子问题。如背包问题中，放手机和放电脑彼此是独立的，谁先放都不会影响到另一个的价值</li><li>使用动态规划，问题的对象只有两种状态，有和没有，不能考虑“有一部分”这样的情况。如背包问题中，放一袋大米，只能考虑放整袋，不能考虑把米袋拆了只拿一部分</li></ul></li><li><p>动态规划的步骤</p><ol><li>绘制网格</li><li>决定网格的坐标轴代表什么。因为每个网格都代表一个子问题，所以要考虑怎么划分子问题。如对比两个字符串中相同字母的个数（求最长公共子序列问题），子问题就是一个字母一个字母的比较，所以坐标轴就是两个字符串</li><li>决定网格内的值代表什么。一般就是要优化的值。如求最长公共子序列问题，网格内的值就是相同字母的个数</li><li>决定网格内的值的计算公式。这个要通过经验和尝试来决定</li></ol></li></ul></li></ul><ul><li>NP完全问题的特征：<ol><li>元素数越多，算出最优解的时间越长</li><li>不能使用“分而治之”，必须考虑所有情况的问题</li><li>可以转化为集合覆盖问题或旅行商问题</li></ol></li></ul><p><strong>附：</strong>数学建模中其实有四类问题：P问题、NP问题、NP完全问题（NPC）、NP难问题（NPH），概念涉及到多项式，很复杂，这里不讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建vue开发环境</title>
      <link href="/2020/02/19/vue-env-build/"/>
      <url>/2020/02/19/vue-env-build/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为自己工作是搞后台的，偶尔要写下前端的时候，发现连前端项目怎么启动都忘记了= =||甚至不知道开发环境是怎么稀里糊涂地就搭好了。这种“学过的东西又还给网上教程”的感觉十分不愉快，但如果是还给自己写的教程，那…应该会庆幸还好写下来了吧╭(′▽`)╯。<br>这篇博客先简单地介绍“搭建vue开发环境”的4个步骤：</p><ol><li>安装Node.js</li><li>配置npm命令</li><li>初始化一个vue项目看看效果</li><li>编辑器VSCode的安装和配置</li></ol><p>说完“搭建环境”后，再顺便说说vue项目是怎么添加依赖模块和怎么打包部署的。</p><ul><li>给vue项目安装模块</li><li>打包vue项目</li></ul><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>进入官网下载：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 。安装好之后，在任一目录打开cmd输入命令测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>有打印版本号，类似于v13.5.0，就算安装成功。</p><h2 id="配置npm命令"><a href="#配置npm命令" class="headerlink" title="配置npm命令"></a>配置npm命令</h2><h3 id="设置依赖模块下载地址"><a href="#设置依赖模块下载地址" class="headerlink" title="设置依赖模块下载地址"></a>设置依赖模块下载地址</h3><p>开发vue项目时经常要安装项目所需模块（和后台项目下载jar包差不多），默认的下载地址 <a href="https://registry.npmjs.org/" target="_blank" rel="noopener">https://registry.npmjs.org/</a> 很慢，一般使用国内镜像地址 <a href="https://registry.npm.taobao.org/" target="_blank" rel="noopener">https://registry.npm.taobao.org/</a> 。<br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>执行成功后没有任何打印。</p><h3 id="设置全局模块和缓存目录"><a href="#设置全局模块和缓存目录" class="headerlink" title="设置全局模块和缓存目录"></a>设置全局模块和缓存目录</h3><p>在node.js的安装目录下，如<code>D:\Program Files\nodejs</code>，新建文件夹<code>node_cache</code>（名字可以任意起），这个文件夹是缓存目录。<br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> cache <span class="string">"D:\Program Files\nodejs\node_cache"</span></span><br></pre></td></tr></table></figure><p>全局模块目录就和本地maven仓库差不多。在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">"D:\Program Files\nodejs"</span></span><br></pre></td></tr></table></figure><p>这两个命令执行成功后没有任何打印。</p><h3 id="检查已设置内容"><a href="#检查已设置内容" class="headerlink" title="检查已设置内容"></a>检查已设置内容</h3><p>目前要自定义设置的就是这三个配置。要查看是否设置成功有两种方法：<br><strong>第一种：</strong><br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config ls</span><br></pre></td></tr></table></figure><p>结果会展示已自定义设置的内容：</p><img src="/2020/02/19/vue-env-build/npm_config_ls_result.png" class="" title="已设置内容"><p><strong>第二种：</strong><br>进入<code>C:\Users\个人目录</code>下，查看<code>.npmrc</code>文件，内容就是自定义配置项。</p><h3 id="其他有用的npm-config命令"><a href="#其他有用的npm-config命令" class="headerlink" title="其他有用的npm config命令"></a>其他有用的npm config命令</h3><ul><li><p>查看npm所有配置项（包括默认配置项）： npm config ls -l</p></li><li><p>修改某一个配置项： npm config set &lt;配置项名&gt; &lt;配置项值&gt;</p></li><li><p>查看某一个配置项值：npm config get &lt;配置项名&gt;</p></li><li><p>查看npm config命令的使用帮助： npm config -h</p></li></ul><h2 id="初始化一个vue项目"><a href="#初始化一个vue项目" class="headerlink" title="初始化一个vue项目"></a>初始化一个vue项目</h2><blockquote><p><strong>如果不打算自己创建项目，而是直接用已有的项目框架来开发，这一步可以跳过</strong></p></blockquote><h3 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h3><p>vue-cli叫做vue脚手架，它可以自动生成vue+webpack的项目模板。<br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure><p>这个命令还可以简写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g vue-cli</span><br></pre></td></tr></table></figure><p>这个命令表示<strong>全局</strong>安装vue-cli。执行过程中会打印一堆模块的名字，没看到<strong>ERROR</strong>之类的字眼就安装成功了。<br>若想验证是否安装成功，可以在cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue</span><br></pre></td></tr></table></figure><p>看到有vue命令的使用帮助就代表安装成功了。<br>另外，这个vue-cli模块安装到了刚刚执行这个命令<code>npm config set prefix &quot;...&quot;</code>时设置的目录下的<code>node_modules</code>文件夹中。<br>npm install命令的更多介绍可以看“扩展内容”-“给vue项目安装模块”部分。</p><h3 id="创建vue项目"><a href="#创建vue项目" class="headerlink" title="创建vue项目"></a>创建vue项目</h3><p>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack hello-demo</span><br></pre></td></tr></table></figure><p>这个命令表示在当前目录下创建hello-demo项目。</p><p>创建过程中，会问你一些问题，在看到<code>Install vue-router?</code>问题前都按<code>回车</code>，<code>Install vue-router?</code>这个问题输入<code>Y</code>，剩下的目前用不到就输入<code>N</code>。示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">? Project name hello-demo</span><br><span class="line">? Project description A Vue.js project</span><br><span class="line">? Author abc &lt;123456@qq.com&gt;</span><br><span class="line">? Vue build standalone</span><br><span class="line">? Install vue-router? Yes</span><br><span class="line">? Use ESLint to lint your code? No</span><br><span class="line">? Set up unit tests No</span><br><span class="line">? Setup e2e tests with Nightwatch? No</span><br><span class="line">? Should we run `npm install` <span class="keyword">for</span> you after the project has been created? (recommended) npm</span><br></pre></td></tr></table></figure><p>创建完成后有如下提示，说明创建成功。</p><img src="/2020/02/19/vue-env-build/vue_init_result.png" class="" title="创建成功"><h3 id="运行vue项目"><a href="#运行vue项目" class="headerlink" title="运行vue项目"></a>运行vue项目</h3><p>按照创建完成后给出的提示命令，在cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hello-demo</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><code>npm run dev</code>命令简单地说就是用hello-demo项目中的<code>node_modules\webpack-dev-server</code>模块启动项目，用的是开发环境的配置<code>build\webpack.dev.conf.js</code>，详细一点的解释可以在网上找得到，这里就不展开了。<br>启动成功后，访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 可以看到如下页面：</p><img src="/2020/02/19/vue-env-build/run_result.png" class="" title="项目主页"><h2 id="编辑器VSCode的安装和配置"><a href="#编辑器VSCode的安装和配置" class="headerlink" title="编辑器VSCode的安装和配置"></a>编辑器VSCode的安装和配置</h2><p>可以用来做vue开发的编辑器有vscode、webstorm等等，这里介绍的vscode，优点是免费而且轻量，缺点是使用一些必要的功能还要额外装插件。<br>在官网下载：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a> ，安装过程很普通所以不讲了。</p><h3 id="下载vetur插件实现vue代码高亮"><a href="#下载vetur插件实现vue代码高亮" class="headerlink" title="下载vetur插件实现vue代码高亮"></a>下载vetur插件实现vue代码高亮</h3><p>vscode打开vue项目时没有任何语法高亮。要下载vetur插件来实现。</p><ul><li><p>常规安装<br>在vscode界面最左侧的工具栏，如下图点击图标出现<code>Extensions</code>页面。</p><img src="/2020/02/19/vue-env-build/vscode_extensions.png" class="" title="Extensions"><p>在输入框输入vetur，点击安装，安装好后重新打开vscode即可看到vue代码已高亮。</p></li><li><p>离线安装<br>因为开发环境很有可能是不联网的，所以有时候要采取特殊手段来安装插件。<br>先在有网的环境，进入官网下载插件包：<a href="https://marketplace.visualstudio.com/vscode" target="_blank" rel="noopener">https://marketplace.visualstudio.com/vscode</a> ，搜索vetur，点击图中的下载按钮下载。</p><img src="/2020/02/19/vue-env-build/vetur_download.png" class="" title="vetur"><p>下载后的插件包是<code>.vsix</code>后缀的。<br>然后把这个<code>.vsix</code>文件放到vscode的安装目录的bin目录下。<br>接着在bin目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code --install-extension octref.vetur-0.23.0.vsix</span><br></pre></td></tr></table></figure><p>离线安装其他插件也是用这样的方法。</p></li></ul><h3 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h3><p>点击File -&gt; Preference -&gt; Keyboard Shortcuts，可以查看和修改快捷键。</p><h2 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h2><p>以上步骤已经把vue开发环境搭建好了。下面扩展地讲一下vue项目依赖模块的安装和打包。</p><h3 id="给vue项目安装模块"><a href="#给vue项目安装模块" class="headerlink" title="给vue项目安装模块"></a>给vue项目安装模块</h3><h4 id="安装axios模块"><a href="#安装axios模块" class="headerlink" title="安装axios模块"></a>安装axios模块</h4><p>假设现在在开发hello-demo项目，发现需要一个axios插件，用来实现HTTP请求。<br>在项目根目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save axios</span><br></pre></td></tr></table></figure><p>这个命令执行完，你会发现，此项目的<code>node_modules</code>文件夹中多了一个<code>axios</code>模块，且在项目的<code>package.json</code>文件中的<code>dependencies</code>括号内，多了<code>&quot;axios&quot;: &quot;^0.19.2&quot;</code>这一行。现在就可以在项目中使用axios了。</p><p><code>package.json</code>文件中的<code>dependencies</code>和<code>devDependencies</code>这两部分都表示项目依赖的模块，不同的是，<code>dependencies</code>代表<strong>生产环境</strong>需要依赖的模块，<code>devDependencies</code>代表<strong>开发</strong>时需要依赖的模块。</p><p>把模块添加到<code>devDependencies</code>下的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev &lt;模块名&gt;</span><br></pre></td></tr></table></figure><h4 id="常用的npm-install命令"><a href="#常用的npm-install命令" class="headerlink" title="常用的npm install命令"></a>常用的npm install命令</h4><ul><li><p>查看npm install命令的使用帮助：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -h</span><br></pre></td></tr></table></figure></li><li><p>全局安装模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g &lt;模块名&gt;</span><br></pre></td></tr></table></figure><p>安装到这个命令<code>npm config set prefix &quot;...&quot;</code>设置的目录下的<code>node_modules</code>文件夹中。</p></li><li><p>局部安装模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;模块名&gt;</span><br><span class="line">npm install --save &lt;模块名&gt;</span><br></pre></td></tr></table></figure><p>这两个命令效果一样，都是安装到当前项目下的<code>node_modules</code>文件夹中，同时添加到<code>package.json</code>文件中的<code>dependencies</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev &lt;模块名&gt;</span><br></pre></td></tr></table></figure><p>这个命令是安装到当前项目下的<code>node_modules</code>文件夹中，同时添加到<code>package.json</code>文件中的<code>devDependencies</code>。</p></li><li><p>下载项目依赖模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>这个命令会下载<code>package.json</code>文件中的<code>dependencies</code>和<code>devDependencies</code>中的所有依赖模块。<br>这个使用场景一般是git clone了项目，项目文件中通常不会包含依赖模块，依赖模块都写在<code>package.json</code>文件里，需要自己手动npm install下载一下。【和后台项目初次启动前先maven update一样</p></li><li><p>指定版本号下载模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install [-g|--save|--save-dev] &lt;模块名&gt;@&lt;版本号&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="打包vue项目"><a href="#打包vue项目" class="headerlink" title="打包vue项目"></a>打包vue项目</h3><p>进入要打包的项目目录，cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>打包完成后会打印<code>Build complete</code>。可以发现，项目目录下多出一个dist文件夹。</p><img src="/2020/02/19/vue-env-build/dist.png" class="" title="dist"><p>这个dist文件夹中就是项目的所有静态文件（做过混淆的），可以用nginx部署，nginx的配置文件基本是这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8080;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    root &#x2F;hellodemo&#x2F;dist; # dist文件所在目录</span><br><span class="line">    index index.html;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">      # 此处的 @router 实际上是引用下面的转发，否则在 Vue 路由刷新时可能会抛出 404</span><br><span class="line">      try_files $uri $uri&#x2F; @router;</span><br><span class="line">      # 请求指向的首页</span><br><span class="line">      index index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 由于路由的资源不一定是真实的路径，无法找到具体文件</span><br><span class="line">    # 所以需要将请求重写到 index.html 中，然后交给真正的 Vue 路由处理请求资源</span><br><span class="line">    location @router &#123;</span><br><span class="line">      rewrite ^.*$ &#x2F;index.html last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 这里配置后台接口地址转发，假设后台服务的IP端口是10.1.75.23:18081</span><br><span class="line">    # 比方说，前端“添加用户”的请求地址是http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;user&#x2F;add，就会被转发到 http:&#x2F;&#x2F;10.1.75.23:18081&#x2F;user&#x2F;add</span><br><span class="line">    location &#x2F;api&#x2F; &#123;</span><br><span class="line">          # 后端的真实接口</span><br><span class="line">          proxy_pass http:&#x2F;&#x2F;10.1.75.23:18081&#x2F;;</span><br><span class="line">          proxy_redirect off;</span><br><span class="line">          proxy_set_header Host $host;</span><br><span class="line">          proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">          proxy_set_header   Cookie $http_cookie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署完后浏览器输入localhost:8080就能跳到项目主页了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天依激励法</title>
      <link href="/2020/02/18/tianyi-fight/"/>
      <url>/2020/02/18/tianyi-fight/</url>
      
        <content type="html"><![CDATA[<p>爱天依就更要好好学习！<br>【顺便用以前做的表情包来测试一下图片效果和置顶~</p><img src="/2020/02/18/tianyi-fight/tianyi_fight.jpg" class="" title="天依激励法">]]></content>
      
      
      
        <tags>
            
            <tag> 洛天依 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/12/hello-world/"/>
      <url>/2020/02/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
