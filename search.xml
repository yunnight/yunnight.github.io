<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RestTemplate负载均衡原理</title>
      <link href="/2021/02/05/resttemplate-loadbalance/"/>
      <url>/2021/02/05/resttemplate-loadbalance/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当我们使用 RestTemplate 调用服务时，会经过以下几个过程：</p><ol><li>RestTemplate 发送的请求被 LoadBalancerInterceptor 拦截，LoadBalancerInterceptor 调用 LoadBalancerClient.execute() 方法处理请求。LoadBalancerClient 默认使用的实现类是 RibbonLoadBalancerClient</li><li>在 RibbonLoadBalancerClient.execute() 方法中，用 serviceId（被调方的服务名）获取一个 ILoadBalancer 对象，再调用 ILoadBalancer.chooseServer() 方法</li><li>在 ILoadBalancer.chooseServer() 方法中，调用 IRule.choose() 方法，从被调服务的多个节点中选出一个节点</li><li>选出服务节点后，把原本是服务名的请求 URI 换成这个节点的IP+端口，发送请求，得到响应</li></ol><p>下面先讲第一个重点： ILoadBalancer 和 IRule 是怎么挑选被调服务的某个节点的？</p><p>PS：文中的源码版本是 SpringCloud Finchley.RELEASE, SpringBoot 2.0.9.RELEASE</p><h1 id="挑选服务节点"><a href="#挑选服务节点" class="headerlink" title="挑选服务节点"></a>挑选服务节点</h1><p>这部分的逻辑有一丢丢复杂，我只选有关联的讲，能省则省，注意跟紧不要掉队咯~</p><h2 id="ILoadBalancer"><a href="#ILoadBalancer" class="headerlink" title="ILoadBalancer"></a>ILoadBalancer</h2><p>ILoadBalancer 的实现类的继承关系（从父类到子类）：ILoadBalancer -&gt; AbstractLoadBalancer -&gt; BaseLoadBalancer -&gt; DynamicServerListLoadBalancer -&gt; ZoneAwareLoadBalancer</p><p><code>ILoadBalancer</code>定义了挑选服务节点的基本方法：<code>chooseServer</code>。<code>AbstractLoadBalancer</code>只是给 ILoadBalancer 接口扩展了几个方法。</p><p><code>BaseLoadBalancer</code>定义了成员变量<code>IRule</code>，IRule 的默认值为<code>RoundRobinRule</code>，就是轮询算法。在 BaseLoadBalancer.chooseServer() 方法中，直接调用 IRule.choose() 方法挑选服务节点。</p><p><code>DynamicServerListLoadBalancer</code>未重写父类的 chooseServer 方法，但它实现了服务实例清单在运行期的动态更新能力（这个后面讲）。</p><p><code>ZoneAwareLoadBalancer</code>重写了 chooseServer 方法，它比父类方法多了一个判断：被调服务的节点存在于一个 Zone 内还是分布在多个 Zone？</p><p>如果是分布在多个 Zone，ZoneAwareLoadBalancer 首先使用<code>ZoneAvoidanceRule</code>计算每个 Zone 的可用性，再从可用的 Zone 中<strong>随机选一个</strong>。选出一个 Zone 后，再用 IRule 从这个 Zone 内的节点列表内挑选一个节点。</p><p>如果就只存在于一个 Zone 内，那就不需要选择 Zone 了，直接用 IRule 从这个 Zone 内的节点列表内挑选一个节点。</p><p><strong>因此，无论是哪种情况，最后都是调用成员 IRule 的 choose 方法挑选服务节点</strong>。</p><p>在配置类<code>RibbonClientConfiguration</code>中，配置了 ILoadBalancer 实现类是<code>ZoneAwareLoadBalancer</code>，IRule 实现类是<code>ZoneAvoidanceRule</code>。所以在默认配置下，最后负责挑选服务节点的方法是<code>ZoneAvoidanceRule.choose()</code>。</p><hr><p>不了解什么是 Zone？这里简单介绍下：</p><p>Zone 和 Region 是两个区域的概念。一个 Region 下可以包含多个 Zone，一个 Zone 只对应一个 Region。这两个属性的意义在于可以指定客户端的某个节点位于某个 Zone 内，这个客户端调用其他服务时，优先在自己的 Zone 内选被调服务的节点，如果没有再去别的 Zone 选服务节点，减少了远程调用的次数。</p><p>对于这两个属性的概念，我也参照其他博客的理解：Region 代表地区，如北京、新加坡，Zone 代表机房，如北京下有两个机房：bj-zone1 和 bj-zone2。</p><p>我们没有使用到这两个属性时，每个节点的注册中心地址配置都是<code>eureka.client.serviceUrl.defalutZone = xxx</code>。在这个配置下，所有节点所在的 Region =”us-east-1”，Zone = “defalutZone”，这两个默认值在<code>EurekaClientConfigBean</code>中指定。</p><h2 id="IRule"><a href="#IRule" class="headerlink" title="IRule"></a>IRule</h2><p>因为默认使用的是 ZoneAvoidanceRule，所以这里只介绍它和它的父类们 O(∩_∩)O</p><p>继承关系（从父类到子类）：IRule -&gt; AbstractLoadBalancerRule -&gt; ClientConfigEnabledRoundRobinRule -&gt; PredicateBasedRule -&gt; ZoneAvoidanceRule</p><p><code>IRule</code>接口和<code>AbstractLoadBalancerRule</code>抽象类定义了挑选服务节点的基本方法：choose，以及成员<code>ILoadBalancer lb</code>，ILoadBalancer 在 IRule 中的作用就是“获取服务节点列表”。【结合上面介绍的 BaseLoadBalancer，可以看出 ILoadBalancer 和 IRule 互相依赖</p><p><code>ClientConfigEnabledRoundRobinRule</code>实现了 choose 方法：调用 RoundRobinRule.choose() 挑选服务节点。这个类的作用是为其子类的 choose 方法提供一个备选方案。</p><p><code>PredicateBasedRule</code>是个抽象类，定义了获取<code>AbstractServerPredicate</code>对象的方法，交由子类实现。它的 choose 方法就是调用 AbstractServerPredicate 对象的 chooseRoundRobinAfterFiltering 方法挑选服务节点并返回。</p><hr><p>下面先介绍一下 AbstractServerPredicate.chooseRoundRobinAfterFiltering() 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title">chooseRoundRobinAfterFiltering</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">    List&lt;Server&gt; eligible = getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">    <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.absent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(eligible.get(incrementAndGetModulo(eligible.size())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，chooseRoundRobinAfterFiltering 方法把形参 List<Server> servers（被调服务的节点列表）交给<code>getEligibleServers</code>方法进行过滤，得到过滤后的节点列表。如果返回的列表为空，则用 Optional.absent() 表示服务不存在，反之则以<strong>线性轮询</strong> 的方式从过滤后的节点列表中获取一个实例并返回。</p><p>getEligibleServers 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getEligibleServers</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loadBalancerKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ImmutableList.copyOf(Iterables.filter(servers, <span class="keyword">this</span>.getServerOnlyPredicate()));            </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        List&lt;Server&gt; results = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">for</span> (Server server: servers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.apply(<span class="keyword">new</span> PredicateKey(loadBalancerKey, server))) &#123;</span><br><span class="line">                results.add(server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，进入 else 分支，遍历 servers，对每个 server 执行 apply 方法，<strong>apply 方法就是服务过滤的逻辑</strong>，apply 方法返回true，就将此 server 加入要返回的列表，false就不加入。</p><blockquote><p>什么情况下不进入 else 分支？<br>很少。因为从RibbonLoadBalancerClient.execute() 方法开始一直传进来的 loadBalancerKey=”default”，所以都会进入 else 分支。</p></blockquote><p>综上，AbstractServerPredicate.chooseRoundRobinAfterFiltering() 是一个模板方法，<strong>定义了处理被调服务节点列表的模板：先过滤列表，再轮询选择。</strong>其中用于过滤服务节点列表的 apply 方法由 AbstractServerPredicate 的子类实现。</p><p>AbstractServerPredicate 有一个重要的子类：<code>CompositePredicate</code>。</p><p>CompositePredicate 成员变量包括一个主过滤条件<code>AbstractServerPredicate delegate</code>和一组次过滤条件<code>List&lt;AbstractServerPredicate&gt; fallbacks</code>。它重写了 getEligibleServers 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getEligibleServers</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">    List&lt;Server&gt; result = <span class="keyword">super</span>.getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">    Iterator&lt;AbstractServerPredicate&gt; i = fallbacks.iterator();</span><br><span class="line">    <span class="keyword">while</span> (!(result.size() &gt;= minimalFilteredServers &amp;&amp; result.size() &gt; (<span class="keyword">int</span>) (servers.size() * minimalFilteredPercentage))</span><br><span class="line">            &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">        AbstractServerPredicate predicate = i.next();</span><br><span class="line">        result = predicate.getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，它的 getEligibleServers 方法先调用了父类 AbstractServerPredicate 的同名方法，父类的这个方法又会调用子类（此处是 CompositePredicate）的 apply 方法。CompositePredicate 的 apply 方法就是使用主过滤条件 ———— delegate.apply()。</p><p>从父类方法返回 List<Server> result 后，对 result 列表长度进行判断，判断条件简单地写就是：”!(result.size() &gt;= 1 &amp;&amp; result.size() &gt; 0)”，即如果 result 列表长度大于1，该条件就不成立，不会进入 while 循环，直接将 result 列表返回。如果这个条件成立，就依次使用次过滤条件 fallbacks 对 servers 进行过滤，直到该条件不成立，或 fallbacks 全部使用过了，就返回最后的过滤结果。</p><hr><p>说回到 PredicateBasedRule，它的子类<code>ZoneAvoidanceRule</code>使用的 AbstractServerPredicate 对象就是 CompositePredicate 类，其中主过滤条件是<code>ZoneAvoidancePredicate</code>，次过滤条件只有<code>AvailabilityPredicate</code>。</p><p><code>ZoneAvoidanceRule</code>未重写父类的 choose 方法，所以它的 choose 方法的调用链为：</p><p>ZoneAvoidanceRule.choose() -&gt; AbstractServerPredicate.chooseRoundRobinAfterFiltering() -&gt; CompositePredicate.getEligibleServers()</p><p>因此，ZoneAvoidanceRule.choose() 逻辑为“先过滤列表，再轮询选择”。过滤节点列表时，先用 ZoneAvoidancePredicate 过滤一遍，如果过滤后的列表个数小于1，才会使用到次过滤条件 AvailabilityPredicate。</p><p>ZoneAvoidancePredicate 和 AvailabilityPredicate 的过滤逻辑，简单地说就是：<br>ZoneAvoidancePredicate 计算了列表内所有节点所在的 Zone 的可用性，只留下了在可用 Zone 内的节点；<br>AvailabilityPredicate 排除了断路器打开（说明服务可能故障）或并发请求数过多的节点。</p><p>因为很少使用次过滤条件，我们可以简单地说：<strong>ZoneAvoidanceRule 先筛选出在可用 Zone 内的被调服务节点列表，再用“线性轮询”的方法从中选出一个。</strong></p><p>至此，默认配置下的挑选服务的逻辑讲完啦~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在默认配置下，负责挑选服务节点的是 ZoneAwareLoadBalancer.chooseServer() 方法。</p><p>ZoneAwareLoadBalancer.chooseServer() 方法先判断：被调服务的节点存在于一个 Zone 内还是分布在多个 Zone？有多个 Zone 就先计算每个 Zone 的可用性，从可用的 Zone 中随机选一个 Zone。如果只有一个 Zone 就不需要选择了。</p><p>确定好 Zone 后，再调用 ZoneAvoidanceRule.choose() 挑选服务节点，此时待挑选的服务列表内的节点都是存在于这个确定好的 Zone 内。</p><p>ZoneAvoidanceRule 的 choose 方法就是调用其成员 CompositePredicate 的 chooseRoundRobinAfterFiltering 方法。在这个方法中，先过滤被调服务的节点列表，再用“线性轮询”的方法从过滤后的列表选出一个节点。</p><p>过滤列表时，先使用的是 ZoneAvoidancePredicate.apply() 方法，它计算了列表内所有节点所在的 Zone 的可用性，只留下了在可用 Zone 内的节点。</p><p>如果 ZoneAvoidancePredicate 过滤后的列表不为空，就用“线性轮询”的方法从这个列表里选出一个节点，结束。【考虑到此时待挑选的列表内的节点都是存在于一个 Zone 内，除非这个 Zone 变得不可用了，不然经过 ZoneAvoidancePredicate 过滤后的列表都是不为空的</p><p>如果 ZoneAvoidancePredicate 过滤后的列表为空，再使用 AvailabilityPredicate.apply()  方法过滤，它排除了断路器打开（说明服务可能故障）或并发请求数过多的节点。最后也是用“线性轮询”的方法从过滤后的列表里选出一个节点，结束。</p><blockquote><p>扩展内容：如果现在需要你自己实现“灰度部署”或“蓝绿部署”，是不是就有思路了？</p></blockquote><p>哎，就是先自定义一个 AbstractServerPredicate 的子类，在这个子类的 apply 方法里编写过滤服务的代码，比如在“灰度发布”阶段，灰度请求只能进入灰度节点，那么在 apply 方法里就要排除掉正常节点，只留下灰度节点。【至于如何识别正常服务还是灰度服务，可以借助<code>eureka.instance.metadata-map</code>属性，在服务的元数据里体现</p><p>然后还需要自定义一个 PredicateBasedRule 的子类，它使用的 AbstractServerPredicate 对象就是刚刚自定义的 AbstractServerPredicate 子类。最后要记得配置 IRule Bean 是自己创建的那个 PredicateBasedRule 子类哦~</p><p>Github上有一个实现蓝绿发布的工程：<a href="https://github.com/jmnarloch/ribbon-discovery-filter-spring-cloud-starter" target="_blank" rel="noopener">https://github.com/jmnarloch/ribbon-discovery-filter-spring-cloud-starter</a> 。作者就是在自定义的 AbstractServerPredicate 子类中，过滤出和调用方 flag 一样的节点，比如调用方是蓝节点，就只过滤出被调方的蓝节点。</p><h1 id="获取服务列表"><a href="#获取服务列表" class="headerlink" title="获取服务列表"></a>获取服务列表</h1><p>上面我们提到，ILoadBalancer 也是 IRule 的成员，它在 IRule 中的作用就是“获取服务节点列表”。那么问题来了，ILoadBalancer 是怎么获取服务节点列表的？</p><p>ILoadBalancer 接口定义了两个方法：<br>(1) <code>List&lt;Server&gt; getReachableServers()</code>————获取正常服务节点<br>(2) <code>List&lt;Server&gt; getAllServers()</code>————获取所有服务节点，包括正常的和停止的节点</p><p>IRule.choose() 方法就是先调用 ILoadBalancer 的这两个方法的其中一个，如 PredicateBasedRule 是调用 ILoadBalancer.getAllServers()，获取被调服务的节点列表，再用特定算法选出一个节点。</p><p>BaseLoadBalancer 实现了这两个方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有服务，包括正常和停止</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; allServerList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Server&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常服务</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; upServerList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Server&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getReachableServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Collections.unmodifiableList(upServerList);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getAllServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Collections.unmodifiableList(allServerList);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>DynamicServerListLoadBalancer 未重写这两个方法，它实现的是对这两个服务列表，allServerList 和 upServerList 的动态更新。</p><p>为了实现服务列表的动态更新，DynamicServerListLoadBalancer 定义了一个成员：<code>ServerList&lt;T&gt; serverListImpl</code>，默认初始化 serverListImpl = <code>DomainExtractingServerList</code>。DomainExtractingServerList 对象里又包含一个成员：<code>ServerList&lt;DiscoveryEnabledServer&gt; list</code>，默认初始化 list = <code>DiscoveryEnabledNIWSServerList</code>。</p><p>这就是个套娃。</p><p><code>ServerList</code>接口有两个方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServerList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Server</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getInitialListOfServers</span><span class="params">()</span></span>; <span class="comment">// 获取初始的服务列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getUpdatedListOfServers</span><span class="params">()</span></span>; <span class="comment">// 获取更新后的服务列表</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DynamicServerListLoadBalancer 就是依赖 ServerList 的 getUpdatedListOfServers 方法获取最新的服务列表，调用链为：</p><p>DynamicServerListLoadBalancer.updateListOfServers() -&gt; DomainExtractingServerList.getUpdatedListOfServers() -&gt; DiscoveryEnabledNIWSServerList.getUpdatedListOfServers() -&gt; DiscoveryEnabledNIWSServerList.obtainServersViaDiscovery()</p><p>这个调用链最后一环<code>DiscoveryEnabledNIWSServerList.obtainServersViaDiscovery()</code>调用了<code>DiscoveryClient.getInstancesByVipAddress()</code>方法，这个方法根据 serviceId（被调服务的名字），优先从同个 Region 中找服务节点，找到了就返回服务节点列表，同个 Region 下没有再去别的 Region 中找【<strong>DiscoveryClient 的服务列表的来源就是注册中心</strong></p><p>DiscoveryEnabledNIWSServerList 得到 DiscoveryClient 返回的节点列表后，从该列表选出状态为 UP 的节点，把每个服务节点包装成<code>DiscoveryEnabledServer</code>对象。</p><p>DomainExtractingServerList 得到 DiscoveryEnabledNIWSServerList 返回的节点列表后，再把每个节点包装成<code>DomainExtractingServer</code>对象返回给 DynamicServerListLoadBalancer，其中每个节点的 Zone 属性来源于节点的元数据配置，配置项为<code>eureka.instance.metadata-map.zone</code>。</p><p>上面的调用链中第一个方法<code>DynamicServerListLoadBalancer.updateListOfServers()</code>，就是负责更新 allServerList 和 upServerList 的方法。这个方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateListOfServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       List&lt;T&gt; servers = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">       <span class="keyword">if</span> (serverListImpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">           servers = serverListImpl.getUpdatedListOfServers();<span class="comment">// 调用成员serverListImpl</span></span><br><span class="line">           LOGGER.debug(<span class="string">"List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,</span><br><span class="line">                   getIdentifier(), servers);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (filter != <span class="keyword">null</span>) &#123;</span><br><span class="line">               servers = filter.getFilteredListOfServers(servers);<span class="comment">// 调用成员filter</span></span><br><span class="line">               LOGGER.debug(<span class="string">"Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,</span><br><span class="line">                       getIdentifier(), servers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       updateAllServerList(servers);<span class="comment">// 最终把列表传给另一个方法，由这个方法更新服务列表</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如上，从 serverListImpl.getUpdatedListOfServers() 得到节点列表后，接着使用成员<code>filter</code>对这个列表进行过滤， filter 默认初始化为<code>ZonePreferenceServerListFilter</code>。</p><p>ZonePreferenceServerListFilter 过滤列表时，先调用父类方法。在父类方法中，判断是否启用“区域感知”功能（shouldEnableZoneAffinity），判断的依据是当前区域（Zone）是否健康（有几个指标来评估），如果当前 Zone 健康，就启用“区域感知”功能，过滤出和调用方 Zone 一致的节点并返回。如果当前 Zone 不健康，就不启用“区域感知”，返回的列表是没过滤的、分布在多个 Zone 的被调方节点列表。</p><p>从父类方法返回后，ZonePreferenceServerListFilter 接着判断父类是不是已经做过过滤了（过滤后的列表和过滤前是否一样）。如果已经被过滤了，就直接返回父类的结果。如果没有被过滤，则子类再从列表中过滤出和调用方 Zone 一致的节点，返回。</p><p>总之，经过 ZonePreferenceServerListFilter 的过滤，被调方节点列表中只留下了和调用方在同一个 Zone 内的节点。这就实现了“优先调用同个 Zone 内的节点”。但，前提是被调方在这个 Zone 内有节点，否则结果依然是没过滤的、分布在其他多个 Zone 的被调方节点列表。</p><p>filter 过滤完后，把过滤后的、最新的节点列表传入<code>updateAllServerList</code>方法，这个方法内接着调用<code>DynamicServerListLoadBalancer.setServersList()</code>方法。</p><p>DynamicServerListLoadBalancer.setServersList() 方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServersList</span><span class="params">(List lsrv)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.setServersList(lsrv); <span class="comment">// 调用父类方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据节点所在的 Zone 进行分类</span></span><br><span class="line">       List&lt;T&gt; serverList = (List&lt;T&gt;) lsrv;</span><br><span class="line">       Map&lt;String, List&lt;Server&gt;&gt; serversInZones = <span class="keyword">new</span> HashMap&lt;String, List&lt;Server&gt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (Server server : serverList) &#123;</span><br><span class="line">           <span class="comment">// make sure ServerStats is created to avoid creating them on hot</span></span><br><span class="line">           <span class="comment">// path</span></span><br><span class="line">           getLoadBalancerStats().getSingleServerStat(server);</span><br><span class="line">           String zone = server.getZone();</span><br><span class="line">           <span class="keyword">if</span> (zone != <span class="keyword">null</span>) &#123;</span><br><span class="line">               zone = zone.toLowerCase();</span><br><span class="line">               List&lt;Server&gt; servers = serversInZones.get(zone);</span><br><span class="line">               <span class="keyword">if</span> (servers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   servers = <span class="keyword">new</span> ArrayList&lt;Server&gt;();</span><br><span class="line">                   serversInZones.put(zone, servers);</span><br><span class="line">               &#125;</span><br><span class="line">               servers.add(server);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       setServerListForZones(serversInZones); <span class="comment">// 调用子类方法</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法形参<code>List lsrv</code>就是过滤后的、最新的节点列表，这个方法做了3件事：</p><ol><li>调用父类 BaseLoadBalancer 的 setServersList 方法，这个方法将 allServerList 和 upServerList 都更新为 lsrv</li><li>整理过滤后的节点列表，根据节点所在的 Zone 进行分类，分类完后是一个 Map，key 为 Zone 的名字，value 为这个 Zone 下的节点列表</li><li>把分类后的 Map 传给子类方法 ZoneAwareLoadBalancer.setServerListForZones()</li></ol><p><code>ZoneAwareLoadBalancer.setServerListForZones()</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setServerListForZones</span><span class="params">(Map&lt;String, List&lt;Server&gt;&gt; zoneServersMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setServerListForZones(zoneServersMap);</span><br><span class="line">    <span class="keyword">if</span> (balancers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        balancers = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BaseLoadBalancer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Server&gt;&gt; entry: zoneServersMap.entrySet()) &#123;</span><br><span class="line">    String zone = entry.getKey().toLowerCase();</span><br><span class="line">        getLoadBalancer(zone).setServersList(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, BaseLoadBalancer&gt; existingLBEntry: balancers.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!zoneServersMap.keySet().contains(existingLBEntry.getKey())) &#123;</span><br><span class="line">            existingLBEntry.getValue().setServersList(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BaseLoadBalancer <span class="title">getLoadBalancer</span><span class="params">(String zone)</span> </span>&#123;</span><br><span class="line">    zone = zone.toLowerCase();</span><br><span class="line">    BaseLoadBalancer loadBalancer = balancers.get(zone);</span><br><span class="line">    <span class="keyword">if</span> (loadBalancer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// We need to create rule object for load balancer for each zone</span></span><br><span class="line">    IRule rule = cloneRule(<span class="keyword">this</span>.getRule());</span><br><span class="line">        loadBalancer = <span class="keyword">new</span> BaseLoadBalancer(<span class="keyword">this</span>.getName() + <span class="string">"_"</span> + zone, rule, <span class="keyword">this</span>.getLoadBalancerStats());</span><br><span class="line">        BaseLoadBalancer prev = balancers.putIfAbsent(zone, loadBalancer);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loadBalancer = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> loadBalancer;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也做了3件事：</p><ol><li>调用父类 DynamicServerListLoadBalancer 的 setServerListForZones 方法，记录一下参数 Map 里拥有的 Zone</li><li>对每个 Zone 都初始化一个<code>BaseLoadBalancer</code>对象，然后把这个 Zone 内的节点列表赋值给这个 BaseLoadBalancer 的 allServerList 和 upServerList</li><li>检查成员 balancers 内是不是有过期的 Zone 信息，即参数 Map 里已经没有这个 Zone 了但 balancers 里还有，把过期的 Zone 对应的 BaseLoadBalancer 的服务列表置为空</li></ol><p>对每个 Zone 初始化 BaseLoadBalancer 对象时，初始化的这个 BaseLoadBalancer 对象的成员 IRule = ZoneAvoidanceRule（因为是从 ZoneAwareLoadBalancer 的 IRule 克隆过来的），属性 name = 服务名 + “_” + zone名。Zone 和 BaseLoadBalancer 的对应关系保存在成员<code>ConcurrentHashMap&lt;String, BaseLoadBalancer&gt; balancers</code>内。</p><hr><p>服务列表的更新过程说完了，现在我们简单提一下何时更新服务列表？</p><p>DynamicServerListLoadBalancer 还有这样两个成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ServerListUpdater.UpdateAction updateAction = <span class="keyword">new</span> ServerListUpdater.UpdateAction() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        updateListOfServers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> ServerListUpdater serverListUpdater;</span><br></pre></td></tr></table></figure><p>成员<code>serverListUpdater</code>是 PollingServerListUpdater 类，在 RibbonClientConfiguration 中配置的。这是个定时任务，它<strong>周期性（默认30秒）执行</strong><code>ServerListUpdater.UpdateAction.doUpdate()</code>方法。如上，这个 doUpdate 方法就是执行 DynamicServerListLoadBalancer.updateListOfServers() 方法。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>BaseLoadBalancer 定义了保存服务节点列表的成员：allServerList 和 upServerList。</p><p>DynamicServerListLoadBalancer 借助成员 ServerListUpdater，周期性（默认30秒）调用 updateListOfServers 方法更新服务节点列表。</p><p>在 updateListOfServers 方法中，DynamicServerListLoadBalancer 再借助成员 serverListImpl = DomainExtractingServerList 从注册中心获取被调方节点列表，优先获取同个 Region 内的节点列表，每个节点都是 UP 状态，且带有 Zone 信息。</p><p>接着，DynamicServerListLoadBalancer 再调用成员 filter = ZonePreferenceServerListFilter 过滤出和调用方 Zone 一致的被调方节点。若被调方在这个 Zone 内没有节点，则 filter 返回的还是没过滤的、分布在其他多个 Zone 的节点列表。</p><p>最后，过滤完的节点列表更新到 allServerList 和 upServerList。ZoneAwareLoadBalancer 还会根据节点所在的 Zone 对节点进行分类。每个 Zone 对应一个 BaseLoadBalancer 对象（若没有会自动初始化），这个 BaseLoadBalancer 对象保存的节点列表就是仅限于这个 Zone 内的节点，成员 IRule 也是 ZoneAvoidanceRule。</p><hr><p><strong>关于“优先调用同一个 Zone 内的节点”：</strong></p><p>前面说到，调用方会优先调用在同一个 Zone 内的被调方节点，原因就是待挑选的服务节点列表经过 ZonePreferenceServerListFilter 过滤后只剩下了在同一个 Zone 内的节点。调用 ZoneAwareLoadBalancer.chooseServer() 时，因为列表中的节点只存在于一个 Zone，所以使用的 IRule 就是 ZoneAwareLoadBalancer 的成员，待选的服务列表也是 ZoneAwareLoadBalancer 维护的 allServerList，内容是这同一个 Zone 内的被调方节点。</p><p>如果被调方在这个 Zone 内没有节点，只在另一个 Zone 内有节点，则 ZonePreferenceServerListFilter 不会做任何过滤，ZoneAwareLoadBalancer 得到的还是在另一个 Zone 内的节点列表。调用 ZoneAwareLoadBalancer.chooseServer() 时，因为列表中的节点只存在于一个 Zone，所以挑选的逻辑还是和上面一样。</p><p>如果被调方在这个 Zone 内没有节点，在其他多个 Zone 内有节点，则 ZonePreferenceServerListFilter 不会做任何过滤，ZoneAwareLoadBalancer 把每个 Zone 下的节点列表整理出来，保存在每个 Zone 对应的 BaseLoadBalancer 对象中。调用 ZoneAwareLoadBalancer.chooseServer() 时，因为列表中的节点分布在多个 Zone，就先选出一个 Zone，取这个 Zone 对应的 BaseLoadBalancer 对象，再调用这个 BaseLoadBalancer 的 chooseServer 方法选出服务节点。自然而然，方法内使用的 IRule 就是 BaseLoadBalancer 的成员，待选的服务列表也是这个 BaseLoadBalancer 的 allServerList，内容是仅限于这个 Zone 内的节点。</p><p>不管是用谁的 IRule，这个 IRule 都是 ZoneAvoidanceRule，待选的服务列表都是在一个 Zone 内的节点。只要这个 Zone 在这调用过程中保持正常不故障，ZoneAvoidanceRule 就是用“线性轮询”的方式，从这个 Zone 的节点列表内选一个节点，结束。 </p><h1 id="组件的自动配置"><a href="#组件的自动配置" class="headerlink" title="组件的自动配置"></a>组件的自动配置</h1><p>负载均衡中的重点已经说完了，这里是一些旁支末节，可以不用理会~我写下来是因为这部分源码中有一些实现方式蛮新鲜的，所以特地记录一下。</p><p>在“前言”部分已经列出了负载均衡的过程，其中前两点是：</p><ol><li>RestTemplate 发送的请求被 LoadBalancerInterceptor 拦截，LoadBalancerInterceptor 调用 LoadBalancerClient.execute() 方法处理请求。LoadBalancerClient 默认使用的实现类是 RibbonLoadBalancerClient</li><li>在 RibbonLoadBalancerClient.execute() 方法中，用 serviceId（被调方的服务名）获取一个 ILoadBalancer 对象，再调用 ILoadBalancer.chooseServer() 方法</li></ol><p>除了 ILoadBalancer 和 IRule，整个过程用到的组件还有拦截请求的 LoadBalancerInterceptor，具体处理请求的 RibbonLoadBalancerClient，这部分内容就介绍下这几个组件是怎么配置的。</p><h2 id="LoadBalancerInterceptor的配置"><a href="#LoadBalancerInterceptor的配置" class="headerlink" title="LoadBalancerInterceptor的配置"></a>LoadBalancerInterceptor的配置</h2><p>在配置类<code>LoadBalancerAutoConfiguration</code>中，首先扫描被<code>@LoadBalanced</code>修饰的 RestTemplate Bean，然后为每个 RestTemplate Bean 添加拦截器<code>LoadBalancerInterceptor</code>。添加了拦截器后，RestTemplate 发出的每个请求都会被拦截。</p><p>在这个配置类之前还会加载另一个配置类<code>RibbonAutoConfiguration</code>，注入<code>LoadBalancerClient</code>Bean（实现类是<code>RibbonLoadBalancerClient</code>），这个 Bean 成为了 LoadBalancerInterceptor 的成员，最终处理请求的方法就是<code>LoadBalancerClient.execute()</code>方法。</p><p>LoadBalancerInterceptor 配置源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RestTemplate<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnBean</span>(<span class="title">LoadBalancerClient</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">LoadBalancerRetryProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LoadBalancerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SmartInitializingSingleton <span class="title">loadBalancedRestTemplateInitializerDeprecated</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> () -&gt; restTemplateCustomizers.ifAvailable(customizers -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (RestTemplate restTemplate : LoadBalancerAutoConfiguration.<span class="keyword">this</span>.restTemplates) &#123;</span><br><span class="line">                <span class="keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">                    customizer.customize(restTemplate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.springframework.retry.support.RetryTemplate"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> restTemplate -&gt; &#123;</span><br><span class="line">                List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">                        restTemplate.getInterceptors());</span><br><span class="line">                list.add(loadBalancerInterceptor);</span><br><span class="line">                restTemplate.setInterceptors(list); <span class="comment">// restTemplate添加拦截器</span></span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分是我第一次看到<code>@Autowired</code>的这个用法：在 @Autowired 注解上加另一个注解，就会扫描出所有加了这个注解的同类的 Bean 放到 List 内。</p><h2 id="ILoadBalancer的配置"><a href="#ILoadBalancer的配置" class="headerlink" title="ILoadBalancer的配置"></a>ILoadBalancer的配置</h2><p>请求被拦截后，由 RibbonLoadBalancerClient.execute() 方法处理请求，首先根据 serviceId（服务名）取 ILoadBalancer 对象，负责这件事的是 RibbonLoadBalancerClient 的成员<code>SpringClientFactory</code>。</p><p>SpringClientFactory 根据 serviceId 取 IloadBalancer，实际上是根据 serviceId 取 IoC 容器，再从 IoC 容器中取 IloadBalancer Bean。serviceId 和 IoC 容器的关系保存在成员<code>Map&lt;String, AnnotationConfigApplicationContext&gt; contexts</code>中。如果 serviceId 还没有对应的 IoC 容器，就先创建一个以便下次取用。因此，<strong>ILoadBalancer 和 IRule 的初始化不是在系统启动时，而是在第一次调用某个服务的时候</strong>。</p><p>一个分布式应用一般要调用多个服务，按照这个设计，调用方要为每个被调服务创建一个 IoC 容器，这个容器中的 ILoadBalancer、IRule 等都是调用这个服务专用的。这种做法比起用同一个 ILoadBalancer Bean 调所有服务，可以更好的维护每个服务的节点列表，使它们之间互不干扰。</p><p>SpringClientFactory 中创建容器的方法源码（方法参数 name 就是 serviceId）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">.getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">"default."</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">context.register(configuration); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">context.register(PropertyPlaceholderAutoConfiguration<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class"><span class="title">this</span>.<span class="title">defaultConfigType</span>)</span>; <span class="comment">// 3</span></span><br><span class="line">context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line"><span class="keyword">this</span>.propertySourceName,</span><br><span class="line">Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">&#125;</span><br><span class="line">context.setDisplayName(generateDisplayName(name));</span><br><span class="line">context.refresh();</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，创建的容器注册了4个东西：</p><ol><li>Map&lt;String, C&gt; configurations 中 key=serviceId 的 value 的 getConfiguration() 返回值</li><li>Map&lt;String, C&gt; configurations 中 以”default.”开头的 key 对应的 value 的 getConfiguration() 返回值</li><li>PropertyPlaceholderAutoConfiguration.class</li><li>defaultConfigType</li></ol><p>其中，第三个不用关注，第四个 defaultConfigType =<code>RibbonClientConfiguration.class</code>，这个属性是在构造方法<code>SpringClientFactory()</code>中设置。</p><p>接下来研究下 SpringClientFactory 的成员<code>Map&lt;String, C&gt; configurations</code>的内容是什么。</p><p>它的来源在<code>RibbonAutoConfiguration</code>配置类，对，就是注入了 RibbonLoadBalancerClient 的那个类。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringClientFactory <span class="title">springClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，Map&lt;String, C&gt; configurations 的来源是所有<code>RibbonClientSpecification</code>Bean。那么，RibbonClientSpecification Bean 又在哪注册呢？它又包含了什么内容？</p><p>在配置类<code>RibbonEurekaAutoConfiguration</code>中，通过<code>@RibbonClients</code>注解，import 另一个类<code>RibbonClientConfigurationRegistrar</code>。</p><p>RibbonEurekaAutoConfiguration 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="meta">@RibbonClients</span>(defaultConfiguration = EurekaRibbonClientConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RibbonEurekaAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RibbonClients 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="meta">@Import</span>(RibbonClientConfigurationRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">RibbonClients</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">RibbonClient[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] defaultConfiguration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RibbonClientConfigurationRegistrar 继承自<code>ImportBeanDefinitionRegistrar</code>，它是和<code>@Import</code>注解配合的一个类：使用<code>@Import</code>，如果括号中的类是<code>ImportBeanDefinitionRegistrar</code>接口的实现类，则会调用接口方法<code>registerBeanDefinitions</code>，在这个方法里可以注入 Bean。</p><p>在 RibbonClientConfigurationRegistrar 类中，调用了 registerBeanDefinitions 方法后，如果 RibbonClients 的 defaultConfiguration 属性有值，就会进入<code>registerClientConfiguration</code>方法（方法源码如下），在这个方法内创建了 RibbonClientSpecification Bean并注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">Object name, Object configuration)</span> </span>&#123;</span><br><span class="line">BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(RibbonClientSpecification<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">builder.addConstructorArgValue(name); <span class="comment">// "default." + @RibbonClients注解所在类的全限定名</span></span><br><span class="line"></span><br><span class="line">builder.addConstructorArgValue(configuration); <span class="comment">// @RibbonClients的defaultConfiguration属性</span></span><br><span class="line"></span><br><span class="line">registry.registerBeanDefinition(name + <span class="string">".RibbonClientSpecification"</span>,</span><br><span class="line">builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，因为这个 @RibbonClients 注解是标在<code>RibbonEurekaAutoConfiguration</code>类上，结合 RibbonEurekaAutoConfiguration 类的源码，这个 RibbonClientSpecification 对象的 name = “default.org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration”，configuration = EurekaRibbonClientConfiguration.class。</p><p>然后，这个 RibbonClientSpecification 对象被扫描到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>再然后，SpringClientFactory 把这个 List<RibbonClientSpecification> configurations 转为自己的成员<code>Map&lt;String, C&gt; configurations</code>，key = RibbonClientSpecification 对象的 name 属性，value = RibbonClientSpecification 对象，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurations</span><span class="params">(List&lt;C&gt; configurations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (C client : configurations) &#123;</span><br><span class="line"><span class="keyword">this</span>.configurations.put(client.getName(), client);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，SpringClientFactory 创建容器时注册的4个东西分别是：</p><ol><li>Map&lt;String, C&gt; configurations 中 key=serviceId 的 value 的 getConfiguration() 返回值 – 没有这个 key </li><li>Map&lt;String, C&gt; configurations 中 以”default.”开头的 key 对应的 value 的 getConfiguration() 返回值 – RibbonClientSpecification.getConfiguration() 返回值 = EurekaRibbonClientConfiguration.class</li><li>PropertyPlaceholderAutoConfiguration.class</li><li>defaultConfigType – RibbonClientConfiguration.class</li></ol><p>综上，serviceId 对应的 IoC 容器中加载了配置类<code>EurekaRibbonClientConfiguration</code>和<code>RibbonClientConfiguration</code>。其中，RibbonClientConfiguration 注入了 ILoadBalancer = ZoneAwareLoadBalancer、IRule = ZoneAvoidanceRule。</p><hr><p>补充介绍一下 ZoneAwareLoadBalancer 的初始化过程。</p><p>配置 ZoneAwareLoadBalancer 的源码（在 RibbonClientConfiguration 类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer<span class="class">.<span class="keyword">class</span>, <span class="title">name</span>)) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer<span class="class">.<span class="keyword">class</span>, <span class="title">config</span>, <span class="title">name</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">serverListFilter, serverListUpdater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZoneAwareLoadBalancer 初始化时，先调用父类 DynamicServerListLoadBalancer 初始化， DynamicServerListLoadBalancer 再调用父类 BaseLoadBalancer 初始化。当前 BaseLoadBalancer 的 name = serviceId。</p><p>DynamicServerListLoadBalancer 从父类 BaseLoadBalancer 初始化返回后，再调用 restOfInit 方法，这个方法又会调用到 updateListOfServers 方法。对，这个就是 DynamicServerListLoadBalancer 更新服务列表的方法。所以，ZoneAwareLoadBalancer 初始化时，也把它的服务列表初始化好了，它的成员<code>ConcurrentHashMap&lt;String, BaseLoadBalancer&gt; balancers</code>———— Zone 和 BaseLoadBalancer 的对应关系也初始化好了。</p><p>在没有配置多个 Zone 的一般项目中，如果你在这个初始化过程里调试 BaseLoadBalancer 的构造方法，你就会发现 BaseLoadBalancer 的构造方法被调用了两次，第一次调用是因为 ZoneAwareLoadBalancer 初始化要调用父类构造方法，name 属性为 serviceId；第二次调用是因为 ZoneAwareLoadBalancer 要创建 defaultZone 对应的 BaseLoadBalancer 对象，name 属性为 serviceId + “_defaultzone”。</p><h2 id="配置类的加载顺序"><a href="#配置类的加载顺序" class="headerlink" title="配置类的加载顺序"></a>配置类的加载顺序</h2><p>系统启动时，根据<code>spring.factories</code>文件加载了配置类<code>RibbonAutoConfiguration</code>，其中注入了 RibbonLoadBalancerClient 。</p><p>RibbonAutoConfiguration 注入了 RibbonLoadBalancerClient Bean 后，加载<code>LoadBalancerAutoConfiguration</code>，这个类为 RestTemplate 设置了 LoadBalancerInterceptor。</p><p>RibbonAutoConfiguration 加载完后，加载<code>RibbonEurekaAutoConfiguration</code>，通过<code>@RibbonClients</code>注解，import RibbonClientConfigurationRegistrar 类，这个类注入了 RibbonClientSpecification ，这个对象中包含配置类<code>EurekaRibbonClientConfiguration</code>的 class 信息。</p><p>系统中第一次使用 RestTemplate 调用服务时，为这个服务初始化一个 IoC 容器，IoC 容器加载的配置类包括<code>EurekaRibbonClientConfiguration</code>和<code>RibbonClientConfiguration</code>。其中，RibbonClientConfiguration 注入了 ILoadBalancer = ZoneAwareLoadBalancer、IRule = ZoneAvoidanceRule。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用SSH方式</title>
      <link href="/2020/12/05/git-ssh/"/>
      <url>/2020/12/05/git-ssh/</url>
      
        <content type="html"><![CDATA[<p>我平时git clone时用的都是HTTPS协议，也设置了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>这行代码的作用是在 .gitconfig 文件中加这些内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[credential]</span><br><span class="line">helper &#x3D; store</span><br></pre></td></tr></table></figure><p>以及生成一个 .git-credentials 文件，里面内容是明文的用户名密码：https://&lt;用户名&gt;:&lt;密码&gt;@github.com</p><p>这个方法在一段时间内有用，设置完后输入一次用户名密码，之后就不用再输了，但最近不行了。</p><p>顺便一提，当我设置完后输入一次用户名密码后，电脑的 凭据管理器 -&gt; Windows凭据 里也保存了一个凭据。</p><p>但现在这些即使重新设置一遍都没有用！！</p><p>无奈，我选择改用<strong>SSH协议</strong>。</p><hr><p>使用SSH协议，首先要生成SSH公私钥并把公钥配置到 GitHub 上。”SSH keys”只有在使用 SSH 协议时才会使用。</p><p>在 GitHub 上添加好公钥后，需要用以下命令测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果提示：”Hi &lt;你的用户名&gt;! You’ve successfully authenticated, but GitHub does not provide shell access.” 说明配置成功。<br>如果提示：”ssh: connect to host github.com port 22: Connection timed out” 说明配置不成功，需要修改端口。</p><p>在 .ssh 目录下新建一个 config 文件，不带后缀。【这个文件的作用待研究…<br>文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User &lt;id_rsa.pub 文件中的邮箱&gt;</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><p>文件保存好后，重新执行 ssh -T <a href="mailto:git@github.com">git@github.com</a> 就OK了。</p><hr><p>接着，要把原本用HTTPS的仓库改为SSH。一般的仓库可以先删除再重新 git clone，记得用SSH方式clone。</p><p>hexo博客改为SSH的步骤：</p><p>1) _config.yml 文件中，git地址改为SSH地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:&lt;用户名&gt;&#x2F;&lt;用户名&gt;.github.io.git</span><br></pre></td></tr></table></figure><p>2) 执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url origin &lt;git SSH地址&gt;</span><br></pre></td></tr></table></figure><p>执行完后检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; git remote -v </span><br><span class="line">origin  git@github.com:&lt;用户名&gt;/&lt;用户名&gt;.github.io.git (fetch)</span><br><span class="line">origin  git@github.com:&lt;用户名&gt;/&lt;用户名&gt;.github.io.git (push)</span><br></pre></td></tr></table></figure><p>修改成功！以后 hexo -d 时用的就是SSH协议了！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud健康检查</title>
      <link href="/2020/11/22/springcloud-health-check/"/>
      <url>/2020/11/22/springcloud-health-check/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍 SpringCloud 服务引入<code>spring-boot-starter-actuator</code>依赖后，进行健康检查的原理，以及何时进行健康检查。目前看有两种情况，第一是客户端自己触发健康检查并将检查结果告诉 Server，第二是 SpringBoot Admin Server 主动调用客户端的 health 端点再更新客户端状态。</p><p>文中源码版本：SpringBoot 2.0.9.RELEASE ; SpringCloud Finchley.RELEASE</p><h1 id="健康检查原理"><a href="#健康检查原理" class="headerlink" title="健康检查原理"></a>健康检查原理</h1><p>得到服务的健康状态的接口是<code>HealthCheckHandler</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HealthCheckHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    InstanceInfo.<span class="function">InstanceStatus <span class="title">getStatus</span><span class="params">(InstanceInfo.InstanceStatus currentStatus)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InstanceStatus</code>是服务健康状态的枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> InstanceStatus &#123;</span><br><span class="line">    UP, <span class="comment">// Ready to receive traffic</span></span><br><span class="line">    DOWN, <span class="comment">// Do not send traffic- healthcheck callback failed</span></span><br><span class="line">    STARTING, <span class="comment">// Just about starting- initializations to be done - do not</span></span><br><span class="line">    <span class="comment">// send traffic</span></span><br><span class="line">    OUT_OF_SERVICE, <span class="comment">// Intentionally shutdown for traffic</span></span><br><span class="line">    UNKNOWN;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HealthCheckHandler 接口有两个实现类，<code>HealthCheckCallbackToHandlerBridge</code>和<code>EurekaHealthCheckHandler</code>。前者是默认配置，它的 getStatus() 只会返回 UP 状态。<code>EurekaHealthCheckHandler</code>是在配置项<code>eureka.client.healthcheck.enabled = true</code>时自动装配的（装配类 EurekaDiscoveryClientConfiguration），如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"eureka.client.healthcheck.enabled"</span>, matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaHealthCheckHandlerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> HealthAggregator healthAggregator = <span class="keyword">new</span> OrderedHealthAggregator();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(HealthCheckHandler<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">EurekaHealthCheckHandler</span> <span class="title">eurekaHealthCheckHandler</span>() </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> EurekaHealthCheckHandler(<span class="keyword">this</span>.healthAggregator);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EurekaHealthCheckHandler 的 getStatus() 是调用其成员<code>CompositeHealthIndicator</code>的<code>getHealth()</code>方法来得到状态的。CompositeHealthIndicator 是<code>HealthIndicator</code>接口的实现类。</p><p><code>HealthIndicator</code>接口只有一个方法<code>health()</code>，这个方法负责健康检查，检查完毕返回<code>Health</code>对象。Health 对象只有两个属性：<code>status</code>代表服务状态，<code>details</code>是更细致的说明。</p><p>不同的 HealthIndicator 实现类检查内容不同，如<code>DataSourceHealthIndicator</code>是检查数据库连接的，<code>DiskSpaceHealthIndicator</code>是检查内存大小的。<code>CompositeHealthIndicator</code>比较特别，它不是专门检查某个模块的，它的作用是收纳了系统中所有实现了<code>HealthIndicator</code>的Bean，它的<code>health()</code>方法就是遍历调用这些<code>HealthIndicator.health()</code>方法，将每个方法返回的 Health 对象的 status 属性，用<code>HealthAggregator</code>类聚合为一个 status 返回。聚合方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Status <span class="title">aggregateStatus</span><span class="params">(List&lt;Status&gt; candidates)</span> </span>&#123; <span class="comment">// 参数就是所有status</span></span><br><span class="line"><span class="comment">// 过滤未定义的状态</span></span><br><span class="line">List&lt;Status&gt; filteredCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Status candidate : candidates) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.statusOrder.contains(candidate.getCode())) &#123;</span><br><span class="line">filteredCandidates.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If no status is given return UNKNOWN</span></span><br><span class="line"><span class="keyword">if</span> (filteredCandidates.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> Status.UNKNOWN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把所有Status 按照以下顺序排序，取第一个</span></span><br><span class="line"><span class="comment">// Status.DOWN, Status.OUT_OF_SERVICE, Status.UP, Status.UNKNOWN</span></span><br><span class="line">filteredCandidates.sort(<span class="keyword">new</span> StatusComparator(<span class="keyword">this</span>.statusOrder));</span><br><span class="line"><span class="keyword">return</span> filteredCandidates.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聚合后的Health对象示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"status"</span>:<span class="string">"UP"</span>,</span><br><span class="line">    <span class="attr">"details"</span>:&#123;</span><br><span class="line">        <span class="attr">"diskSpace"</span>:&#123;</span><br><span class="line">            <span class="attr">"status"</span>:<span class="string">"UP"</span>,</span><br><span class="line">            <span class="attr">"details"</span>:&#123;</span><br><span class="line">                <span class="attr">"total"</span>:<span class="number">297428578304</span>,</span><br><span class="line">                <span class="attr">"free"</span>:<span class="number">243281637376</span>,</span><br><span class="line">                <span class="attr">"threshold"</span>:<span class="number">10485760</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"refreshScope"</span>:&#123;</span><br><span class="line">            <span class="attr">"status"</span>:<span class="string">"UP"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"discoveryComposite"</span>:&#123;</span><br><span class="line">            <span class="attr">"status"</span>:<span class="string">"UP"</span>,</span><br><span class="line">            <span class="attr">"details"</span>:&#123;</span><br><span class="line">                <span class="attr">"discoveryClient"</span>:&#123;</span><br><span class="line">                    <span class="attr">"status"</span>:<span class="string">"UP"</span>,</span><br><span class="line">                    <span class="attr">"details"</span>:&#123;</span><br><span class="line">                        <span class="attr">"services"</span>:[</span><br><span class="line">                            <span class="string">"spring-cloud-register2"</span></span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"eureka"</span>:&#123;</span><br><span class="line">                    <span class="attr">"description"</span>:<span class="string">"Remote status from Eureka server"</span>,</span><br><span class="line">                    <span class="attr">"status"</span>:<span class="string">"UP"</span>,</span><br><span class="line">                    <span class="attr">"details"</span>:&#123;</span><br><span class="line">                        <span class="attr">"applications"</span>:&#123;</span><br><span class="line">                            <span class="attr">"SPRING-CLOUD-REGISTER2"</span>:<span class="number">1</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"hystrix"</span>:&#123;</span><br><span class="line">            <span class="attr">"status"</span>:<span class="string">"UP"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义HealthIndicator"><a href="#自定义HealthIndicator" class="headerlink" title="自定义HealthIndicator"></a>自定义HealthIndicator</h2><p>自定义的 HealthIndicator 可以实现自己的健康检查机制。实现类只需要用<code>@Component</code>注解注入就行。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Health.up().build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="客户端自我检查后上报"><a href="#客户端自我检查后上报" class="headerlink" title="客户端自我检查后上报"></a>客户端自我检查后上报</h1><p>SpringCloud Client 依赖了<code>spring-boot-starter-actuator</code>，并配置<code>eureka.client.healthcheck.enabled = true</code>之后，会自己<strong>周期性（默认30秒）</strong>地执行健康检查，若健康状态与上一次检查的不一致，会调用 Server 的<strong>注册</strong>接口，将自己的状态告诉 Server，这样注册中心的页面上可以看到此客户端的健康状态变了。</p><blockquote><p>注册中心的注册接口：POST /eureka/apps/{appId}。appId就是配置文件中的<code>spring.application.name</code>，请求体是<code>InstanceInfo</code>类，其中属性<code>status</code>就是服务的健康状态。</p></blockquote><p><code>DiscoveryClient</code>初始化方法<code>initScheduledTasks()</code>中，判断配置项<code>eureka.client.registerWithEureka = true</code>时，初始化<code>InstanceInfoReplicator</code>，并调用其 start() 方法。</p><p>InstanceInfoReplicator 继承自 Runnable 接口，它有个成员<code>ScheduledExecutorService scheduler</code>，这是可以设置执行周期性任务或延时任务的线程池类，执行的任务内容基本就是 InstanceInfoReplicator 定义的 run 方法。</p><p>InstanceInfoReplicator.run() 方法中调用 DiscoveryClient.refreshInstanceInfo() 方法，DiscoveryClient.refreshInstanceInfo() 方法中调用 EurekaHealthCheckHandler.getStatus() 方法执行健康检查，再调用 ApplicationInfoManager.setInstanceStatus(status) 将检查结果 InstanceStatus 传给<code>ApplicationInfoManager</code>类。</p><p>ApplicationInfoManager.setInstanceStatus() 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setInstanceStatus</span><span class="params">(InstanceStatus status)</span> </span>&#123;</span><br><span class="line">      InstanceStatus next = instanceStatusMapper.map(status);</span><br><span class="line">      <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 设置新状态，返回旧状态</span></span><br><span class="line">      InstanceStatus prev = instanceInfo.setStatus(next);</span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (StatusChangeListener listener : listeners.values()) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  listener.notify(<span class="keyword">new</span> StatusChangeEvent(prev, next));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  logger.warn(<span class="string">"failed to notify listener: &#123;&#125;"</span>, listener.getId(), e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，若 InstanceInfo 的前一个状态 prev 不为 null，会将两个状态作为一个<code>StatusChangeEvent</code>事件通知到<code>StatusChangeListener</code>类。而我们从<code>InstanceInfo.setStatus()</code>方法中得知，当前后状态一致，即健康状态不变，返回的 prev 就是 null，ApplicationInfoManager 就不会通知 StatusChangeListener。</p><p>StatusChangeListener 的实现类也是在 DiscoveryClient.initScheduledTasks() 中定义好的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">statusChangeListener = <span class="keyword">new</span> ApplicationInfoManager.StatusChangeListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"statusChangeListener"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(StatusChangeEvent statusChangeEvent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||</span><br><span class="line">InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123;</span><br><span class="line"><span class="comment">// log at warn level if DOWN was involved</span></span><br><span class="line">logger.warn(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logger.info(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</span><br><span class="line">&#125;</span><br><span class="line">instanceInfoReplicator.onDemandUpdate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它监听到 StatusChangeEvent 事件后，调用了<code>InstanceInfoReplicator.onDemandUpdate()</code>方法，而这个方法中其实就是调用了 InstanceInfoReplicator.run() 方法。</p><p>InstanceInfoReplicator.run() 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceInfoReplicator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            discoveryClient.refreshInstanceInfo();</span><br><span class="line"></span><br><span class="line">            Long dirtyTimestamp = instanceInfo.isDirtyWithTime();</span><br><span class="line">            <span class="keyword">if</span> (dirtyTimestamp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                discoveryClient.register();</span><br><span class="line">                instanceInfo.unsetIsDirty(dirtyTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"There was a problem with the instance info replicator"</span>, t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Future next = scheduler.schedule(<span class="keyword">this</span>, replicationIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">            scheduledPeriodicRef.set(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中除了调用 DiscoveryClient.refreshInstanceInfo() 方法触发健康检查以外，还会调用 DiscoveryClient.register() 进行注册，在这之前有个判断，判断当前 InstanceInfo 是否已经“Dirty”了，若是就要重新注册。“Dirty”的设置在上面提到的 InstanceInfo.setStatus() 方法中，简单地说，当新旧健康状态不一致时，当前 InstanceInfo 会被设置为 Dirty，于是会重新注册。 </p><p>从上面源码中还可以看出，每次执行 run() 方法，都会在 finally 块中设置下一次执行时间是当前时间延迟<code>replicationIntervalSeconds</code>秒，因此等同于每 replicationIntervalSeconds 秒执行一次 run() 方法，这个时间可配置，默认值30秒。</p><p>总结：InstanceInfoReplicator.run() 周期性执行，默认周期30秒，每次执行都会触发 EurekaHealthCheckHandler 进行健康检查（调用链：InstanceInfoReplicator.run() -&gt; DiscoveryClient.refreshInstanceInfo() -&gt; EurekaHealthCheckHandler.getStatus()）。若本次检查结果和上次不一样，就会再次发送注册请求，上报自己的状态信息，注册中心页面上的服务状态就会更新（调用链：ApplicationInfoManager.setInstanceStatus() -&gt; StatusChangeListener.notify() -&gt; InstanceInfoReplicator.onDemandUpdate() -&gt; InstanceInfoReplicator.run() -&gt; DiscoveryClient.register()）。</p><h1 id="SpringBoot-Admin-Server-主动调用"><a href="#SpringBoot-Admin-Server-主动调用" class="headerlink" title="SpringBoot Admin Server 主动调用"></a>SpringBoot Admin Server 主动调用</h1><blockquote><p>spring-boot-admin-starter-server 源码中大量使用<code>Flux</code>、<code>Mono</code>类，它们是 Spring Reactor，即响应式编程中的基本概念。简单地说，Flux 表示可以发射1到N个元素的异步发射器，Mono 表示可以发射0或1个元素的异步发射器。这里不多介绍了。</p></blockquote><p>Admin Server 在装配类<code>AdminServerAutoConfiguration</code>中注入了一个<code>StatusUpdateTrigger</code> Bean，它用来<strong>周期性（默认10秒）</strong>请求客户端的 health 端点，更新客户端状态。从下面源码可以看到，StatusUpdateTrigger 的 Bean 初始化方法是 start 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(initMethod = <span class="string">"start"</span>, destroyMethod = <span class="string">"stop"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatusUpdateTrigger <span class="title">statusUpdateTrigger</span><span class="params">(StatusUpdater statusUpdater, Publisher&lt;InstanceEvent&gt; events)</span> </span>&#123;</span><br><span class="line">    StatusUpdateTrigger trigger = <span class="keyword">new</span> StatusUpdateTrigger(statusUpdater, events);</span><br><span class="line">    trigger.setUpdateInterval(adminServerProperties.getMonitor().getPeriod());</span><br><span class="line">    trigger.setStatusLifetime(adminServerProperties.getMonitor().getStatusLifetime());</span><br><span class="line">    <span class="keyword">return</span> trigger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 StatusUpdateTrigger.start() 方法中，用 Flux 类设置了执行周期（10秒）和执行方法，在执行方法内，对每个服务实例<code>Instance</code>遍历调用了<code>StatusUpdater.updateStatus()</code>方法。<br>updateStatus() 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">updateStatus</span><span class="params">(InstanceId id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> repository.computeIfPresent(id, (key, instance) -&gt; <span class="keyword">this</span>.doUpdateStatus(instance)).then();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 StatusUpdater.updateStatus() 方法中，根据 doUpdateStatus() 方法的返回值更新了 repository 中某个客户端的状态。 repository 是<code>InstanceRepository</code>接口的实现类<code>SnapshottingInstanceRepository</code>对象，作用是保存所有客户端 Instance。</p><p>StatusUpdater.doUpdateStatus() 方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Mono&lt;Instance&gt; <span class="title">doUpdateStatus</span><span class="params">(Instance instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance.isRegistered()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">"Update status for &#123;&#125;"</span>, instance);</span><br><span class="line">    <span class="keyword">return</span> instanceWebClient.instance(instance)</span><br><span class="line">                            .get()</span><br><span class="line">                            .uri(Endpoint.HEALTH)</span><br><span class="line">                            .exchange()</span><br><span class="line">                            .log(log.getName(), Level.FINEST)</span><br><span class="line">                            .flatMap(<span class="keyword">this</span>::convertStatusInfo)</span><br><span class="line">                            .doOnError(ex -&gt; logError(instance, ex))</span><br><span class="line">                            .onErrorResume(<span class="keyword">this</span>::handleError)</span><br><span class="line">                            .map(instance::withStatusInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，发送HTTP请求到客户端 health 端点，根据响应的 HTTP 状态码确定被调客户端的健康状态（用<code>StatusInfo</code>类表示，这个类是 admin-server 依赖定义的）。响应码200时，StatusInfo=(status=UP, details={})；响应码503时，StatusInfo=(status=DOWN, details={error=Service Unavailable, status=503})。如果出现 HTTP 调用失败导致无响应，会打印日志”Couldn’t retrieve status for Instance…”，并把该服务的状态定为 OFFLINE。</p><p>这个HTTP状态码和 StatusInfo 的对应关系是在客户端 health 端点响应中定义的。只有当状态为 Status.DOWN 和 Status.OUT_OF_SERVICE 时，响应码503，其余的响应码都是200。</p><p>顺便一提，Admin Server 调用 Client 的 health 端点是调用到 Client 的这个方法：（delegate 就是上面提到过的 CompositeHealthIndicator）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EndpointWebExtension</span>(endpoint = HealthEndpoint<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HealthEndpointWebExtension</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ReadOperation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebEndpointResponse&lt;Health&gt; <span class="title">getHealth</span><span class="params">(SecurityContext securityContext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.responseMapper.map(<span class="keyword">this</span>.delegate.health(), securityContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，Admin Server 监控服务状态的方法就是用 StatusUpdateTrigger 每隔10秒遍历客户端的 health 端点，把最新状态更新到 SnapshottingInstanceRepository 中，Admin Server 页面上的服务状态也随之变化。</p><p>再说说 SnapshottingInstanceRepository 中所有的客户端服务信息是怎么来的。它的来源是，在 Eureka Server 的 DiscoveryClient 中，因为配置了<code>eureka.client.fetchRegistry = true</code>，所以初始化一个定时任务（定时周期默认30秒），这个任务就是定时向 Eureka Server （也就是它自己）拉取服务列表，这个服务列表就会更新到 SnapshottingInstanceRepository 中。</p><p>实现方式是，DiscoveryClient 拉取服务列表成功后会发布<code>HeartbeatEvent</code>事件。这个事件被<code>InstanceDiscoveryListener</code>监听到了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceDiscoveryListener</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(HeartbeatEvent event)</span> </span>&#123;</span><br><span class="line">        discoverIfNeeded(event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法调用到<code>InstanceRegistry.register()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;InstanceId&gt; <span class="title">register</span><span class="params">(Registration registration)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(registration, <span class="string">"'registration' must not be null"</span>);</span><br><span class="line">    InstanceId id = generator.generateId(registration);</span><br><span class="line">    Assert.notNull(id, <span class="string">"'id' must not be null"</span>);</span><br><span class="line">    <span class="keyword">return</span> repository.compute(id, (key, instance) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = Instance.create(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(instance.register(registration));</span><br><span class="line">    &#125;).map(Instance::getId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，会为每个服务生成一个ID，这个ID是唯一且固定的（即使服务重新注册也不会改变）。当我们在 Admin Server 页面上访问某个服务的某个端点时，这个ID会拼接在前端请求的URL中，如：<a href="http://localhost:18001/admin/instances/eb4fa470685c/actuator/metrics。" target="_blank" rel="noopener">http://localhost:18001/admin/instances/eb4fa470685c/actuator/metrics。</a></p><blockquote><p>Admin 心跳检查的周期是20秒？</p></blockquote><p>在实践中发现， Admin Server 调用客户端 health 端点似乎并不是严格的以10秒为周期，原因在于，虽然 StatusUpdateTrigger 是每隔10秒调用 updateStatusForAllInstances 方法，但在 updateStatusForAllInstances 中有一个判断，当上一次查询的时间是在当前时间的前10秒内，则不执行更新方法 updateStatus 。只有当上一次查询的时间是在当前时间的前10秒之前，才会执行 updateStatus 方法去调这个服务节点的 health 端点。<br>由于时间计算的误差，有时候两次调 health 的间隔是10秒，有时候是20秒。</p><p><code>updateStatusForAllInstances</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Mono&lt;Void&gt; <span class="title">updateStatusForAllInstances</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.debug(<span class="string">"Updating status for all instances"</span>);</span><br><span class="line">    Instant expiryInstant = Instant.now().minus(statusLifetime);</span><br><span class="line">    <span class="keyword">return</span> Flux.fromIterable(lastQueried.entrySet())</span><br><span class="line">               .filter(e -&gt; e.getValue().isBefore(expiryInstant)) <span class="comment">// 判断时间</span></span><br><span class="line">               .map(Map.Entry::getKey)</span><br><span class="line">               .flatMap(<span class="keyword">this</span>::updateStatus) <span class="comment">// 更新方法</span></span><br><span class="line">               .then();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java BIO NIO</title>
      <link href="/2020/10/25/java-io/"/>
      <url>/2020/10/25/java-io/</url>
      
        <content type="html"><![CDATA[<h1 id="BIO基础"><a href="#BIO基础" class="headerlink" title="BIO基础"></a>BIO基础</h1><p>BIO全称是Blocking I/O，意为非阻塞IO。我们平时使用的IO API就是BIO。</p><p>BIO是面向流的。<strong>输入流读取数据，输出流写入数据</strong>。流基类是<code>InputStream</code>和<code>OutputStream</code>。但我们不能直接使用基类，只能使用其子类。基类声明了子类最基本也是最常用的 read/write 方法。</p><p><code>InputStream</code>和<code>OutputStream</code>是直接操作<strong>字节数组</strong>的。使用它们需要手动把字符转为字节输入，字节转为字符读出。它们有“一次读/写一个字节”和“一次读/写多个字节”的方法，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure><p>“一次读/写一个字节”的方法因为效率低下所以很少用。“一次读/写多个字节”的方法很常用。read 方法数据流向：<code>input -&gt; byte[]</code>。write 方法数据流向：<code>byte[] -&gt; output</code>。read 方法返回值int代表实际读取的字节数。</p><p>常用子类：</p><ol><li>FileInputStream、FileOutputStream</li><li>BufferedInputStream、BufferedOutputStream</li><li>ByteArrayInputStream、ByteArrayOutputStream</li></ol><h2 id="BufferedInputStream和BufferedOutputStream"><a href="#BufferedInputStream和BufferedOutputStream" class="headerlink" title="BufferedInputStream和BufferedOutputStream"></a>BufferedInputStream和BufferedOutputStream</h2><p><code>BufferedOutputStream</code>将写入的数据存储在缓冲区中，缓冲区是一个名为buf的字节数组。等到缓冲区满或刷新输出流时，它将数据一次性全部写入底层输出流。因此，调用 BufferedOutputStream 的 write 方法之后，需要手动调用<code>flush()</code>方法把缓冲区数据写入底层输出流。</p><p><code>BufferedInputStream</code>也有一个名为buf的字节数组作缓冲区。调用 read 方法时，它首先从缓冲区读取数据，只有当缓冲区没有数据时，它才会从底层输入流读取数据。和其他输入流子类不同的是，当<code>BufferedInputStream</code>的 read 方法需要从底层读取数据时，它会一直读到“输入流阻塞”或“没有数据可读”时，这些数据会放到缓冲区，然后把缓冲区数据的全部或部分填充到 byte[] 数组。其他输入流在返回前，只从底层读取一次，不会尝试多次读取直到无可读。</p><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream(InputStream in)</span><br><span class="line">BufferedInputStream(InputStream in, <span class="keyword">int</span> bufferSize)</span><br><span class="line"></span><br><span class="line">BufferedOutputStream(OutputStream out)</span><br><span class="line">BufferedOutputStream(OutputStream out, <span class="keyword">int</span> bufferSize)</span><br></pre></td></tr></table></figure><p>第一个参数就是底层输入/输出流，第二个参数是指定缓冲区大小（单位为字节）。默认情况下，输入/输出流的 bufferSize 为8192字节。</p><p>BufferedInputStream和BufferedOutputStream的 read/write 方法同基类，无新增方法。</p><h2 id="ByteArrayInputStream和ByteArrayOutputStream"><a href="#ByteArrayInputStream和ByteArrayOutputStream" class="headerlink" title="ByteArrayInputStream和ByteArrayOutputStream"></a>ByteArrayInputStream和ByteArrayOutputStream</h2><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayInputStream(<span class="keyword">byte</span> buf[])</span><br><span class="line">ByteArrayInputStream(<span class="keyword">byte</span> buf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream()</span><br><span class="line">ByteArrayOutputStream(<span class="keyword">int</span> size)</span><br></pre></td></tr></table></figure><p><code>ByteArrayInputStream</code>的参数 byte buf[] 是这个输入流数据的来源。当调用 ByteArrayInputStream 的 read(byte[] data) 方法时，就是把这个 byte buf[] 的数据复制到 byte[] data 中。offset 和 length 参数和上面所说的 read/write 方法的含义一致。</p><p><code>ByteArrayOutputStream</code>内部也有一个字节数组buf，参数size就是指定这个字节数组的大小（默认值32）。当调用 ByteArrayOutputStream 的 write(byte[] data) 方法时，就是把这个 byte[] data 的数据复制到 byte buf[] 中。</p><p>ByteArrayXXX 和 BufferedXXX 的<strong>区别</strong>在于，ByteArrayXXX 没有用底层输入/输出流，它只把数据存在字节数组 buf 中。而 BufferedXXX 和底层流有交互，字节数组 buf 只是它和底层流之间的缓冲。在使用场景上，BufferedXXX 常用在网络IO，因为读/写缓冲区的速度比直接读/写网络流要快。ByteArrayXXX 常用于复制输入流的内容，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InputStream input =  httpconn.getInputStream();</span><br><span class="line">  </span><br><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();  </span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line"><span class="keyword">int</span> len;  </span><br><span class="line"><span class="keyword">while</span> ((len = input.read(buffer)) &gt; -<span class="number">1</span> ) &#123;  </span><br><span class="line">baos.write(buffer, <span class="number">0</span>, len);  </span><br><span class="line">&#125;</span><br><span class="line">baos.flush();</span><br><span class="line"><span class="comment">// 复制</span></span><br><span class="line">InputStream stream1 = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">InputStream stream2 = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br></pre></td></tr></table></figure><h2 id="处理字符的Reader和Writer"><a href="#处理字符的Reader和Writer" class="headerlink" title="处理字符的Reader和Writer"></a>处理字符的Reader和Writer</h2><p><code>Reader</code>和<code>Writer</code>直接操作的是<strong>字符</strong>而不是字节。字节和字符互相转换需要指定编码方式<code>charset</code>。Reader 和 Writer 默认使用的编码方式来自于<code>Charset.defaultCharset()</code>方法返回值。</p><p>Charset.defaultCharset() 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title">defaultCharset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (defaultCharset == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Charset<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">String csn = AccessController.doPrivileged(</span><br><span class="line"><span class="keyword">new</span> GetPropertyAction(<span class="string">"file.encoding"</span>));</span><br><span class="line">Charset cs = lookup(csn);</span><br><span class="line"><span class="keyword">if</span> (cs != <span class="keyword">null</span>)</span><br><span class="line">defaultCharset = cs;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">defaultCharset = forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> defaultCharset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面方法中，首先取<code>file.encoding</code>属性值，找不到该属性值则返回”UTF-8”。<code>file.encoding</code>属性值在 Eclipse 中设置在 Project -&gt; Properties -&gt; Resource -&gt; Text file encoding。项目不是在 Eclipse 中运行时，file.encoding 就是系统编码。</p><p>Reader 和 Writer 是基类，和 XXXStream 类一样，规定了子类的基本方法，包括“一次读/写一个字符”和“一次读/写多个字符”，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] text)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] text)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String s, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure><p>和 XXXStream 类方法很相似，不同的是字节数组变成了字符数组（字符串），且 read 方法返回值 int 表示实际读取的<strong>字符数</strong>。</p><p>重要子类：</p><ol><li>InputStreamReader、OutputStreamWriter</li><li>BufferedReader、BufferedWriter</li><li>StringReader、StringWriter</li></ol><h2 id="InputStreamReader和OutputStreamWriter"><a href="#InputStreamReader和OutputStreamWriter" class="headerlink" title="InputStreamReader和OutputStreamWriter"></a>InputStreamReader和OutputStreamWriter</h2><p>这两个类是 Reader 和 Writer 最基本的子类，也是 XXXStream 的包装类。<code>InputStreamReader</code>从其底层输入流中读取字节，再根据 charset 把字节转为字符返回。<code>OutputStreamWriter</code>接收字符数组，根据 charset 将字符转为字节，写入底层输出流。</p><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader(InputStream in)</span><br><span class="line">InputStreamReader(InputStream in, String charsetName)</span><br><span class="line"></span><br><span class="line">OutputStreamWriter(OutputStream out)</span><br><span class="line">OutputStreamWriter(OutputStream out, String charsetName)</span><br></pre></td></tr></table></figure><h2 id="BufferedReader和BufferedWriter"><a href="#BufferedReader和BufferedWriter" class="headerlink" title="BufferedReader和BufferedWriter"></a>BufferedReader和BufferedWriter</h2><p>与 BufferedInputStream 和 BufferedOutputStream 相似，<code>BufferedReader</code>和<code>BufferedWriter</code>使用内部的<strong>字符数组</strong>作为缓冲区，读取时先从缓冲区读取，写入时先写入缓冲区，只有当缓冲区满或 flush 时，缓冲区内容才写入底层输出流。</p><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader(Reader in)</span><br><span class="line">BufferedReader(Reader in, <span class="keyword">int</span> bufferSize)</span><br><span class="line"></span><br><span class="line">BufferedWriter(Writer out)</span><br><span class="line">BufferedWriter(Writer out, <span class="keyword">int</span> bufferSize)</span><br></pre></td></tr></table></figure><p>bufferSize为缓冲区字符数组大小，默认为8192字符。</p><h2 id="StringReader和StringWriter"><a href="#StringReader和StringWriter" class="headerlink" title="StringReader和StringWriter"></a>StringReader和StringWriter</h2><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringReader(String s)</span><br><span class="line"></span><br><span class="line">StringWriter()</span><br><span class="line">StringWriter(<span class="keyword">int</span> initialSize)</span><br></pre></td></tr></table></figure><p><code>StringReader</code>和<code>StringWriter</code>都没有与底层输入/输出流交互。StringReader 的成员变量就是一个字符串<code>String s</code>，StringWriter 的成员变量是<code>StringBuffer buf</code>，这也是它们存放数据的地方。读取的数据来源是 String s，写入数据的目的地是 StringBuffer buf。StringWriter 构造函数中 initialSize 是设置 StringBuffer buf 的大小。</p><p>这两个类提供了字符串与 Reader、Writer 之间互相转换的便利。StringWriter 的<code>toString()</code>方法就可以直接输出 StringBuffer buf 的内容，非常方便。</p><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS常用方法</title>
      <link href="/2020/10/25/js-note/"/>
      <url>/2020/10/25/js-note/</url>
      
        <content type="html"><![CDATA[<p>JS（JavaScript）是一种脚本语言，是许多浏览器的默认脚本语言，因此不需要在<code>&lt;script&gt;</code>标签中使用 type=”text/javascript”。</p><p>下面所有JS代码都是写在下面这个模板的<code>&lt;script&gt;</code>标签中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"test()"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// JS代码....</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="获取HTML元素"><a href="#获取HTML元素" class="headerlink" title="获取HTML元素"></a>获取HTML元素</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(id)</span><br></pre></td></tr></table></figure><h1 id="判断对象为空"><a href="#判断对象为空" class="headerlink" title="判断对象为空"></a>判断对象为空</h1><p>js的对象有3种状态：undefined、null、空对象（无属性的对象）、有属性的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1</span><br><span class="line">getType(obj1) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="literal">null</span></span><br><span class="line">getType(obj2) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;&#125;</span><br><span class="line">getType(obj3) <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj4 = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">getType(obj4) <span class="comment">// 有属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj === <span class="literal">undefined</span>) <span class="built_in">console</span>.log(<span class="string">'undefined'</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(obj === <span class="literal">null</span>) <span class="built_in">console</span>.log(<span class="string">'null'</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span>) <span class="built_in">console</span>.log(<span class="string">'&#123;&#125;'</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">'有属性'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，很多时候判断变量直接写<code>if(obj)</code>，这个详细展开说下。</p><h1 id="IF-变量"><a href="#IF-变量" class="headerlink" title="IF+变量"></a>IF+变量</h1><p>很多时候，我们直接使用变量作为判断条件，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj) &#123;&#125;</span><br><span class="line">obj ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>对于不同的变量类型，判断为true/false的结果各有差异，具体为：</p><ol><li>undefined、null =&gt; false</li><li>空字符串 =&gt; false （只有空格的字符串就不是空字符串）</li><li>整数0 =&gt; false</li></ol><p>为true的情况就与以上情况相反。</p><h1 id="是否相等"><a href="#是否相等" class="headerlink" title="是否相等"></a>是否相等</h1><p>两个等号<code>==</code>与三个等号<code>===</code>都是用来比较变量是否相等，区别在于，两个等号是不严格相等，类型不同的变量只要值相等也属于相等。<strong>一般使用三个等号</strong>，类型不同即不相等。<br>不等号 <code>!=</code>与<code>!==</code>的区别也是如此，一般使用后者。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num == str) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(num === str) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h1><p>遍历数组元素都是通过下标来遍历，无论数组元素是普通类型还是对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123; <span class="comment">// 第一种</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123; <span class="comment">// 第二种</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span>,</span><br><span class="line">c: <span class="number">3</span>,</span><br><span class="line">d: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">e: <span class="number">99</span>,</span><br><span class="line">f: <span class="number">88</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [obj1, obj2] <span class="comment">// 对象数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h1><p>遍历对象属性也可以用<code>for in</code>语法，此外还可以用<code>Object.keys()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span>,</span><br><span class="line">c: <span class="number">3</span>,</span><br><span class="line">d: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(key + <span class="string">":"</span> + obj[key])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj); <span class="comment">// 只包含key的数组 于是遍历对象改为遍历数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> keys) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(keys[i] + <span class="string">":"</span> + obj[keys[i]])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象合并与复制"><a href="#对象合并与复制" class="headerlink" title="对象合并与复制"></a>对象合并与复制</h1><p>使用三点运算符<code>...</code> 或 <code>Object.assign()</code></p><p>三点运算符例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span>,</span><br><span class="line">c: <span class="number">3</span>,</span><br><span class="line">d: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">e: <span class="number">99</span>,</span><br><span class="line">f: <span class="number">88</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;...obj1&#125; <span class="comment">// 复制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj4 = &#123;...obj1, ...obj2&#125; <span class="comment">// 合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj5 = &#123;</span><br><span class="line">e: <span class="number">100</span>,</span><br><span class="line">f: <span class="number">88</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj6 = &#123;...obj4, ...obj5&#125; <span class="comment">// 有相同属性时，后者覆盖前者</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj3)) <span class="comment">// &#123;"a":1,"b":2,"c":3,"d":4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj4)) <span class="comment">// &#123;"a":1,"b":2,"c":3,"d":4,"e":99,"f":88&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj6)) <span class="comment">// &#123;"a":1,"b":2,"c":3,"d":4,"e":100,"f":88&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Object.assign()例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span>,</span><br><span class="line">c: <span class="number">3</span>,</span><br><span class="line">d: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">e: <span class="number">99</span>,</span><br><span class="line">f: <span class="number">88</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj5 = &#123;</span><br><span class="line">e: <span class="number">100</span>,</span><br><span class="line">f: <span class="number">88</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj6 = <span class="built_in">Object</span>.assign(obj1, obj2, obj5) <span class="comment">// 把obj2、obj5都合并到obj1并返回</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1)) <span class="comment">// &#123;"a":1,"b":2,"c":3,"d":4,"e":100,"f":88&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj6)) <span class="comment">// &#123;"a":1,"b":2,"c":3,"d":4,"e":100,"f":88&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：合并后的对象属性顺序与合并顺序一致。当参与合并的两个对象有相同属性 key 时，后一个对象的属性 value 会覆盖前一个对象的value。</p><h1 id="对象属性的增删"><a href="#对象属性的增删" class="headerlink" title="对象属性的增删"></a>对象属性的增删</h1><p>JS对象可以随意新增、删除属性字段。前提是这个对象不为 null 或 undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> user = &#123;&#125;</span><br><span class="line"></span><br><span class="line">user.name = <span class="string">"abc"</span> <span class="comment">// 添加属性</span></span><br><span class="line">user.age = <span class="number">24</span></span><br><span class="line">user.sex = <span class="string">"male"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(user)) <span class="comment">// &#123;"name":"abc","age":24,"sex":"male"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> user.age <span class="comment">// 删除属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(user)) <span class="comment">// &#123;"name":"abc","sex":"male"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user2 = <span class="literal">null</span></span><br><span class="line">user2.name = <span class="string">"efg"</span> <span class="comment">// Cannot set property 'name' of null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user3</span><br><span class="line">user3.name = <span class="string">"efg"</span> <span class="comment">// Cannot set property 'name' of undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找数组元素并返回"><a href="#查找数组元素并返回" class="headerlink" title="查找数组元素并返回"></a>查找数组元素并返回</h1><p>JS Array.find 方法用于查找出满足指定条件的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = arr.find(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">e = e + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> e === <span class="number">6</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// 不改变原数组元素</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = []</span><br><span class="line"><span class="keyword">var</span> result2 = arr2.find(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e + <span class="number">1</span> === <span class="number">6</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在回调函数中，“return + 条件”，条件符合则返回true，查找到元素。回调函数中即使对每个元素有修改，也<strong>不会改变原数组和原数组中的元素</strong>。若符合条件的元素有多个，<strong>只返回第一个</strong>。</p><p>若数组为空，则返回 undefined 。</p><p>此外，还有<strong>返回符合条件的元素的下标</strong>的方法：Array.findIndex。除了返回的是下标值外，其他和 find 方法无异。空数组返回 -1 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = arr.findIndex(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">e = e + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> e === <span class="number">6</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// 不改变原数组元素</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = []</span><br><span class="line"><span class="keyword">var</span> result2 = arr2.findIndex(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e + <span class="number">1</span> === <span class="number">6</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找元素下标还有更简单的方法： <code>indexOf</code>和<code>lastIndexOf</code>，用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = arr.indexOf(<span class="number">4</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> result2 = arr.lastIndexOf(<span class="number">4</span>) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="built_in">console</span>.log(result2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要<strong>返回所有符合条件的元素</strong>，用 filter 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = arr.filter(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e === <span class="number">4</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="遍历数组元素并执行函数"><a href="#遍历数组元素并执行函数" class="headerlink" title="遍历数组元素并执行函数"></a>遍历数组元素并执行函数</h1><p>这个功能用上面小节“遍历数组”中的方法也可实现。这里介绍更高级的方法。</p><p><strong>map:</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = arr.map(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map 方法对原数组每个元素执行一遍回调函数，返回新数组。如果没有return，则新数组元素为 undefined。若原数组为空，则新数组也为空：[]</p><p>map 方法也可以这么用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">a: <span class="number">3</span>,</span><br><span class="line">b: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">a: <span class="number">5</span>,</span><br><span class="line">b: <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [obj1, obj2, obj3]</span><br><span class="line"><span class="keyword">var</span> arrA = []</span><br><span class="line"><span class="keyword">var</span> arrB = []</span><br><span class="line"></span><br><span class="line">arr.map(<span class="function">(<span class="params">e, index</span>) =&gt;</span> &#123;</span><br><span class="line">arrA[index] = e.a</span><br><span class="line">arrB[index] = e.b</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="built_in">console</span>.log(arrA) <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrB) <span class="comment">// [2, 4, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>forEach:</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">e, index</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 map 不同，forEach 没有返回值，但也是每个元素都执行一遍回调函数。</p><blockquote><p>map 和 forEach 会不会改变原数组？这个要看具体情况。</p></blockquote><p>如果是对象数组，则会改变原数组：<br>【因为对象数组遍历时的 e 是引用类型，改变引用即改变原对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">a: <span class="number">3</span>,</span><br><span class="line">b: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">a: <span class="number">5</span>,</span><br><span class="line">b: <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [obj1,obj2,obj3]</span><br><span class="line"></span><br><span class="line">arr.map(<span class="function">(<span class="params">e, index</span>) =&gt;</span> &#123;</span><br><span class="line">e.b = e.a</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [&#123;a: 1, b: 1&#125;,&#123;a: 3, b: 3&#125;,&#123;a: 5, b: 5&#125;]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是基本类型数组，则不改变原数组：<br>【基本类型包括number,string,Boolean,null,undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">arr.map(<span class="function">(<span class="params">e, index</span>) =&gt;</span> &#123;</span><br><span class="line">e = e*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是下面这样用，不管是什么类型的数组都会改变原数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">arr.map(<span class="function">(<span class="params">e, index</span>) =&gt;</span> &#123;</span><br><span class="line">arr[index] = <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 1, 1, 1, 1]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子都是用 map，改成 forEach 现象相同。</p><h1 id="增删数组元素"><a href="#增删数组元素" class="headerlink" title="增删数组元素"></a>增删数组元素</h1><p>pop：删除数组的最后一个元素，返回删除的元素。</p><p>push：向数组的末尾添加一个或更多元素，返回新的长度。</p><p>shift：删除数组的第一个元素，返回删除的元素。</p><p>unshift：向数组的开头添加一个或更多元素，返回新的长度。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = arr.pop() </span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(result1) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = arr.push(<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13]</span></span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result3 = arr.shift()</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13]</span></span><br><span class="line"><span class="built_in">console</span>.log(result3) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result4 = arr.unshift(<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [20, 21, 22, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13]</span></span><br><span class="line"><span class="built_in">console</span>.log(result4) <span class="comment">// 14</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指定下标增删元素：splice 方法</strong></p><p>array.splice(index, howmany, item1,…..,itemX)</p><p>index：要添加/删除元素的下标位置<br>howmany：在此下标位 删除 多少元素，为0表示不删除元素<br>item1,…..,itemX：要添加的元素，一个或多个</p><p>只返回被删除的元素组成的数组，若没有删除元素则返回空数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = arr.splice(<span class="number">2</span>,<span class="number">2</span>) <span class="comment">// 删除index=2,3 的元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"><span class="built_in">console</span>.log(result1) <span class="comment">// [3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = arr.splice(<span class="number">7</span>,<span class="number">0</span>,<span class="number">20</span>,<span class="number">21</span>) <span class="comment">// 在 index=7 插入两个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 5, 6, 7, 8, 9, 20, 21, 10]</span></span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result3 = arr.splice(<span class="number">1</span>,<span class="number">3</span>,<span class="number">30</span>,<span class="number">31</span>)  <span class="comment">// 删除index=1,2,3 的元素，再在 index=1 插入两个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 30, 31, 7, 8, 9, 20, 21, 10]</span></span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h1><p>JS中的字符串变量有很多方法的使用方法和作用 与Java类似，其中包括：<br>substring(start, end)<br>split(regex, limit)<br>concat(str1, str2, …)<br>indexOf(searchString，position)<br>lastIndexOf(searchString, position)<br>replace(searchValue, replaceValue)</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件开发</title>
      <link href="/2020/08/30/vue-component-build/"/>
      <url>/2020/08/30/vue-component-build/</url>
      
        <content type="html"><![CDATA[<h1 id="父子组件之间的交互"><a href="#父子组件之间的交互" class="headerlink" title="父子组件之间的交互"></a>父子组件之间的交互</h1><ol><li>子组件要求父组件传递的变量写在<code>props</code>中</li><li>子组件自己维护的，不需要父组件传递的变量写在<code>data</code>中</li><li>在子组件内调用父组件方法：子组件用<code>$emit</code>发起一个事件（可以带事件参数），父组件用<code>v-on</code>或<code>@</code>监听这个事件并做处理（监听方法的形参就是子组件传的参数）</li><li>父组件调用子组件方法：父组件在子组件上定义<code>ref</code>属性,  父组件用<code>this.$refs.refName.method</code>去调用子组件方法。</li></ol><h1 id="示例：分页表格组件"><a href="#示例：分页表格组件" class="headerlink" title="示例：分页表格组件"></a>示例：分页表格组件</h1><p><code>TablePage</code>功能：</p><ol><li>翻页时、改变页大小时，自动调用后台查找</li><li>固定一列操作列，数据列和操作列分开从父组件传</li><li>当操作列中的按钮大于1时，这些按钮应折叠在“更多”下拉按钮中，如“编辑”、“删除”。如果不需要这些操作，操作列应该隐藏</li></ol><p>框架是iView。设置好跨域访问和axios全局后，使用<code>&lt;Table /&gt;</code>和<code>&lt;Page /&gt;</code>以及<code>slot-scope</code>实现以上功能。</p><p><code>TablePage</code>组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表格 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Table</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">:columns</span>=<span class="string">"insideColumns"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">:data</span>=<span class="string">"data"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">border</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"&#123; row, index &#125;"</span> <span class="attr">slot</span>=<span class="string">"action"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"actionNumber &lt; 2"</span>&gt;</span>     </span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"firstAction.onClick(row)"</span>&gt;</span>&#123;&#123;firstAction.name&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 按钮数超过一个时，显示更多操作的下拉菜单 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Dropdown</span> <span class="attr">transfer</span> <span class="attr">trigger</span>=<span class="string">"click"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0)"</span>&gt;</span>More<span class="tag">&lt;<span class="name">Icon</span> <span class="attr">type</span>=<span class="string">"ios-arrow-down"</span>&gt;</span><span class="tag">&lt;/<span class="name">Icon</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">DropdownMenu</span> <span class="attr">slot</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">DropdownItem</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in insideActions"</span> <span class="attr">:key</span>=<span class="string">"index"</span> &gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"item.onClick(row)"</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">DropdownItem</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">DropdownMenu</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">Dropdown</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Table</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 分页组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 10px"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Page</span> <span class="attr">transfer</span> <span class="attr">:current</span>=<span class="string">"currentPage"</span> <span class="attr">:total</span>=<span class="string">"count"</span> <span class="attr">:page-size</span>=<span class="string">"pageSize"</span> <span class="attr">show-elevator</span> <span class="attr">show-total</span> <span class="attr">show-sizer</span> @<span class="attr">on-change</span>=<span class="string">"changePage"</span> @<span class="attr">on-page-size-change</span>=<span class="string">"changePageSize"</span> /&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'TablePage'</span>,</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 子组件要求父组件传递的变量</span></span></span><br><span class="line">    props: &#123;</span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">default</span> () &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> [];</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, </span><br><span class="line"><span class="actionscript">        columns: &#123; <span class="comment">// 数据列</span></span></span><br><span class="line"><span class="javascript">            type: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">default</span> () &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> [];</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        actions: &#123; <span class="comment">// 操作列</span></span></span><br><span class="line"><span class="javascript">            type: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">default</span> () &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> [];</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,         </span><br><span class="line">        count: &#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">default</span>: <span class="number">0</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        currentPage: &#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">default</span>: <span class="number">1</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        pageSize: &#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">default</span>: <span class="number">10</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript"><span class="comment">// 子组件自己维护的变量</span></span></span><br><span class="line">    data () &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line">            insideColumns: [],</span><br><span class="line">            actionNumber: 0,</span><br><span class="line">            firstAction: &#123;&#125;,</span><br><span class="line">            insideActions: [],            </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changePage (newPage) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.currentPage = newPage;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.getData();</span></span><br><span class="line">        &#125;,</span><br><span class="line">        changePageSize (newPageSize) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.pageSize = newPageSize;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.getData();</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript"><span class="comment">// 在子组件内调用父组件方法：子组件用`$emit`发起一个事件</span></span></span><br><span class="line">        getData () &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.$emit(<span class="string">'get-data'</span>, <span class="keyword">this</span>.currentPage, <span class="keyword">this</span>.pageSize);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript"><span class="comment">// 当actions有元素时，新增一列操作列</span></span></span><br><span class="line">        handleColumns (columns) &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> actionColumn = &#123;</span></span><br><span class="line"><span class="actionscript">                title: <span class="string">'Action'</span>,</span></span><br><span class="line"><span class="actionscript">                slot: <span class="string">'action'</span>,</span></span><br><span class="line">                width: 130,</span><br><span class="line"><span class="actionscript">                fixed: <span class="string">'right'</span>,</span></span><br><span class="line"><span class="actionscript">                resizable: <span class="literal">true</span></span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">this</span>.actions &amp;&amp; <span class="keyword">this</span>.actions.length &gt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.insideColumns = columns.concat(actionColumn);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="comment">// 处理外部传入的 actions</span></span></span><br><span class="line">        handleActions (actions) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.actionNumber = actions.length; <span class="comment">// 按钮数</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">this</span>.actionNumber &gt; <span class="number">0</span>) &#123; </span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.firstAction = actions[<span class="number">0</span>]; <span class="comment">// 设置唯一的按钮</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span>(<span class="keyword">this</span>.actionNumber &gt; <span class="number">1</span>) &#123; <span class="comment">// 按钮多于1个，设置下拉按钮项</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> more = [...actions];</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.insideActions = more;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.handleColumns(<span class="keyword">this</span>.columns);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.handleActions(<span class="keyword">this</span>.actions);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中的<code>getData()</code>方法很关键，它是<code>TablePage</code>与父组件通信的桥梁，通过<code>this.$emit()</code>触发名为”get-data”的事件，并传递参数<code>currentPage</code>和<code>pageSize</code>。在父组件中，需要<code>v-on</code>这个事件，得到这两个参数。</p><p>父组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 点击按钮触发查询，加载表格数据 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-bottom: 10px"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> @<span class="attr">click</span>=<span class="string">"search()"</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--分页表格区域--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TablePage</span> <span class="attr">:columns</span>=<span class="string">"columns"</span> <span class="attr">:data</span>=<span class="string">"data"</span> <span class="attr">:count</span>=<span class="string">"count"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:currentPage</span>=<span class="string">"currentPage"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:pageSize</span>=<span class="string">"pageSize"</span></span></span><br><span class="line">            @get-data="loadData" &lt;!--子组件内$emit的事件--&gt;</span><br><span class="line">            :actions="actions"</span><br><span class="line">            &gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">TablePage</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> TablePage <span class="keyword">from</span> <span class="string">'./table-page'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'PersonManage'</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line"><span class="actionscript">    TablePage <span class="comment">// 引入组件</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">        currentPage: 1,</span><br><span class="line">        pageSize: 10,        </span><br><span class="line"><span class="actionscript">        <span class="comment">// 总条数</span></span></span><br><span class="line">        count: 0,</span><br><span class="line"><span class="actionscript">        <span class="comment">// 表格数据列</span></span></span><br><span class="line">        columns: [</span><br><span class="line">            &#123;</span><br><span class="line"><span class="actionscript">                title: <span class="string">'ID'</span>,</span></span><br><span class="line"><span class="actionscript">                key: <span class="string">'id'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line"><span class="actionscript">                title: <span class="string">'Lastname'</span>,</span></span><br><span class="line"><span class="actionscript">                key: <span class="string">'lastname'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line"><span class="actionscript">                title: <span class="string">'Firstname'</span>,</span></span><br><span class="line"><span class="actionscript">                key: <span class="string">'firstname'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line"><span class="actionscript">                title: <span class="string">'City'</span>,</span></span><br><span class="line"><span class="actionscript">                key: <span class="string">'city'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line"><span class="actionscript">                title: <span class="string">'Address'</span>,</span></span><br><span class="line"><span class="actionscript">                key: <span class="string">'address'</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"><span class="actionscript">        <span class="comment">// 表格源数据</span></span></span><br><span class="line">        data: [],</span><br><span class="line"><span class="actionscript">        <span class="comment">// 操作列</span></span></span><br><span class="line">        actions: [</span><br><span class="line"><span class="javascript">            &#123; <span class="attr">name</span>: <span class="string">'Edit'</span>, <span class="attr">onClick</span>: <span class="function">(<span class="params">row</span>) =&gt;</span> <span class="keyword">this</span>.handleEdit(row) &#125;,</span></span><br><span class="line"><span class="javascript">            &#123; <span class="attr">name</span>: <span class="string">'Delete'</span>, <span class="attr">onClick</span>: <span class="function">(<span class="params">row</span>) =&gt;</span> <span class="keyword">this</span>.handleDelete(row.id)&#125;</span></span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">      search()&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.currentPage = <span class="number">1</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.loadData(<span class="keyword">this</span>.currentPage, <span class="keyword">this</span>.pageSize)</span></span><br><span class="line">      &#125;,      </span><br><span class="line"><span class="actionscript">      <span class="comment">// 调用后台接口获取表格数据</span></span></span><br><span class="line">      loadData(currentPage, pageSize)&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.currentPage = currentPage</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.pageSize = pageSize</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$axios(&#123;</span></span><br><span class="line"><span class="actionscript">            url: <span class="string">'/man/person/getListByPage'</span>,</span></span><br><span class="line"><span class="actionscript">            method: <span class="string">'post'</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="actionscript">                currentPage: <span class="keyword">this</span>.currentPage,</span></span><br><span class="line"><span class="actionscript">                pageSize: <span class="keyword">this</span>.pageSize</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> resData = res.data</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> pageData = resData.data</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.data = pageData.dataList</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.count = pageData.count</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,  </span><br><span class="line"><span class="actionscript">  <span class="comment">// 按钮事件</span></span></span><br><span class="line">      handleEdit(row)&#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'edit=====&gt;'</span>+<span class="built_in">JSON</span>.stringify(row))</span></span><br><span class="line">      &#125;,</span><br><span class="line">      handleDelete(rowId)&#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'delete=====&gt;'</span>+<span class="built_in">JSON</span>.stringify(rowId))</span></span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>currentPage</code>和<code>pageSize</code>由父组件传入子组件，而不是由子组件维护，原因是：父组件在改变<code>currentPage</code>和<code>pageSize</code>的值后应该同步到子组件，这样子组件的<code>&lt;Page /&gt;</code>组件才能与实际页码和页大小匹配。</p><p>父组件改变<code>currentPage</code>和<code>pageSize</code>的场景：点击查询按钮时，需要把当前页码<code>currentPage</code>改为1。</p><p>因此，这两个参数也应该由父组件传入子组件，子组件改变它的值后通知到父组件。</p><h1 id="父组件调用子组件方法例子"><a href="#父组件调用子组件方法例子" class="headerlink" title="父组件调用子组件方法例子"></a>父组件调用子组件方法例子</h1><p>抄自：<a href="https://www.cnblogs.com/renzm0318/p/8762129.html" target="_blank" rel="noopener">https://www.cnblogs.com/renzm0318/p/8762129.html</a></p><p>子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">childComponent</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">name: <span class="string">"child"</span>,</span></span><br><span class="line">methods: &#123;</span><br><span class="line"><span class="actionscript">childClick(e) &#123; <span class="comment">// 子组件方法</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(e)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"parentClick"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">"mychild"</span> /&gt;</span><span class="comment">&lt;!--子组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./child'</span>;   <span class="comment">//引入子组件Child</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">name: <span class="string">"parent"</span>,</span></span><br><span class="line">components: &#123;</span><br><span class="line">Child</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">parentClick() &#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.$refs.mychild.childClick(<span class="string">"子组件方法"</span>);<span class="comment">// 调用子组件的方法childClick</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security 认证与授权流程</title>
      <link href="/2020/08/23/spring-security-auth/"/>
      <url>/2020/08/23/spring-security-auth/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>只要是权限校验框架，就离不开两个步骤：认证（Authentication）和授权（Authorization）。认证即“用户登录”，授权即“允许用户访问目标URI”。这篇博客介绍了Spring Security 5.0.6版本认证与授权这两个过程的执行链条，未涉及到更高级的功能（如单点登录、RememberMe）。</p><blockquote><p>官方文档（Security5.0.6）：<a href="https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/" target="_blank" rel="noopener">https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/</a></p></blockquote><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>Spring Security的认证工作主要由<code>UsernamePasswordAuthenticationFilter</code>完成。这个Filter是默认配置的，每个请求都会被它拦截。认证成功后，会生成经过认证的用户信息对象<code>Authentication</code>。<strong>无论认证成功或失败，都不会继续走后面的Filter。</strong></p><p>步骤简述：</p><ol><li>请求进入<code>UsernamePasswordAuthenticationFilter.doFilter()</code>方法</li><li>在doFilter()方法中，先判断请求URI是否为<code>POST loginProcessingUrl</code>，是则继续，<strong>否则跳过认证，直接进入Security过滤器链中下一个Filter</strong>。loginProcessingUrl表示登录提交的URI，可自定义，默认值为”/login”</li><li>判断为“是”，doFilter()调用<code>AuthenticationManager.authenticate()</code>。默认调用到AuthenticationManager的实现类<code>ProviderManager</code></li><li>在ProviderManager.authenticate()中，调用<code>AuthenticationProvider.authenticate()</code>方法执行真正的认证逻辑。默认调用到AuthenticationProvider的实现类<code>DaoAuthenticationProvider</code></li><li>在AuthenticationProvider.authenticate()中，根据请求中的用户名参数”username”，调用<code>UserDetailsService.loadUserByUsername()</code>，该方法返回<code>UserDetails</code>对象，表示数据源中存储的用户信息</li><li>AuthenticationProvider获得UserDetails对象后，校验此UserDetails对象，校验依据是UserDetails接口的几个boolean方法，如isEnabled()。说明一下，因为此UserDetails对象是用请求中的用户名查找出的，所以校验此对象状态也就是对请求中的用户名进行<strong>认证</strong></li><li>若在“第5步”中<code>UserDetailsService.loadUserByUsername()</code>没有找到UserDetails，或在“第6步”中校验UserDetails对象不通过，则说明请求中的用户名有误。这两个方法会抛出<code>AuthenticationException</code>子类，说明认证失败。这个异常向上传递最终由<code>UsernamePasswordAuthenticationFilter</code>捕获处理。UsernamePasswordAuthenticationFilter捕获异常后，调用<code>AuthenticationFailureHandler.onAuthenticationFailure()</code>进行后续处理，默认调用到实现类<code>SimpleUrlAuthenticationFailureHandler</code>，作用是返回403状态码，或者在设置了failureUrl时跳转到此URL。之后不会再经过其他Filter</li><li>若认证成功，则AuthenticationProvider生成通过认证的<code>Authentication</code>对象（含用户名、密码、权限等），并返回到<code>AuthenticationManager.authenticate()</code>，再向上传递到<code>UsernamePasswordAuthenticationFilter.doFilter()</code></li><li>doFilter()获得<code>Authentication</code>对象后，调用<code>SecurityContextHolder.getContext().setAuthentication()</code>将Authentication对象赋予给当前的<code>SecurityContext</code></li><li>doFilter()调用<code>AuthenticationSuccessHandler.onAuthenticationSuccess()</code>进行后续处理，默认调用到实现类<code>SavedRequestAwareAuthenticationSuccessHandler</code>，作用是从request header或配置中取targetUrl并跳转。之后不会再经过其他Filter</li></ol><p>认证成功流程：</p><img src="/2020/08/23/spring-security-auth/authentication_success.PNG" class="" title="认证成功"><p>认证失败流程：</p><img src="/2020/08/23/spring-security-auth/authentication_fail.PNG" class="" title="认证失败"><h2 id="UserDetailsService和UserDetails"><a href="#UserDetailsService和UserDetails" class="headerlink" title="UserDetailsService和UserDetails"></a>UserDetailsService和UserDetails</h2><p>在上述“第5步”中，提到了<code>UserDetailsService.loadUserByUsername()</code>方法。该方法源码；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException, DataAccessException</span>;</span><br></pre></td></tr></table></figure><p>该方法的作用就是查找数据源中的用户信息，<code>AuthenticationProvider.authenticate()</code>就是以此为依据对当前请求进行认证。根据UserDetailsService的已有实现类推测，数据源可以是JDBC数据库、内存。</p><p>该方法的返回对象<code>UserDetails</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的4个boolean方法，就是<code>DaoAuthenticationProvider</code>对请求进行认证的依据。Spring默认使用的实现类是<code>User</code>。</p><p><code>getAuthorities()</code>方法返回一个<code>Collection&lt;GrantedAuthority&gt;</code>对象，GrantedAuthority是个接口，一般使用它的实现类<code>SimpleGrantedAuthority</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GrantedAuthority</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回表示权限的String</span></span><br><span class="line"><span class="function">String <span class="title">getAuthority</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义实现思路"><a href="#自定义实现思路" class="headerlink" title="自定义实现思路"></a>自定义实现思路</h2><ol><li>自定义<code>AuthenticationProvider.authenticate()</code>，实现自己的认证逻辑，如校验密码是否正确</li><li>自定义<code>UserDetailsService.loadUserByUsername()</code>，实现自己的查找原用户信息的方式，如从数据库查找</li><li>自定义<code>UserDetails</code>，这是原用户信息对象，也是认证成功后被保存在<code>SecurityContext</code>的对象，可以自定义需要的属性，如用户所在组、岗位等</li><li>自定义会进入认证逻辑的<code>POST loginProcessingUrl</code>，如果你的登录表单action不是”/login”就需要设置</li><li>自定义登录页地址</li><li>自定义认证成功和失败后的处理，<code>AuthenticationSuccessHandler</code>和<code>AuthenticationFailureHandler</code></li></ol><p>以上自定义可以实现基本的认证需求，更高级的如RememberMe、单点登录等这里没有列出，需要查阅其他资料。</p><h2 id="自定义实现示例"><a href="#自定义实现示例" class="headerlink" title="自定义实现示例"></a>自定义实现示例</h2><p>配置示例（只写出与认证有关的部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">CustomAuthenticationProvider customAuthenticationProvider;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">http</span><br><span class="line">.formLogin() <span class="comment">// 这行下面的语句都是在设置UsernamePasswordAuthenticationFilter的属性</span></span><br><span class="line">.loginPage(<span class="string">"/login"</span>) <span class="comment">// 登录页</span></span><br><span class="line">.loginProcessingUrl(<span class="string">"/login/submit"</span>) <span class="comment">// 登录提交URI，访问此URI的请求会进入认证逻辑</span></span><br><span class="line">.successHandler(<span class="keyword">new</span> LoginSuccessHandler()) <span class="comment">// 自定义AuthenticationSuccessHandler</span></span><br><span class="line">.failureHandler(<span class="keyword">new</span> LoginFailureHandler()) <span class="comment">// 自定义AuthenticationFailureHandler</span></span><br><span class="line">.and()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 给AuthenticationManager设置自定义AuthenticationProvider</span></span><br><span class="line">auth.authenticationProvider(customAuthenticationProvider);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义AuthenticationProvider示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"securityUserService"</span>)</span><br><span class="line">UserDetailsService userDetailsService; <span class="comment">// 自定义UserDetailsService</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">String username = authentication.getName();</span><br><span class="line">Object password = (String) authentication.getCredentials();</span><br><span class="line"><span class="comment">// SecurityUser是自定义的UserDetails</span></span><br><span class="line">SecurityUser userDetails = (SecurityUser) userDetailsService.loadUserByUsername(username);</span><br><span class="line"><span class="keyword">if</span> (userDetails == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="string">"账号不存在"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!userDetails.getPassword().equals(password)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="string">"账号密码错误"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userDetails, password, userDetails.getAuthorities());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><p>在认证流程中，只有当请求URI是设置的登录提交URI loginProcessingUrl时，才会进入<code>UsernamePasswordAuthenticationFilter</code>的认证逻辑，且不论认证结果如何都会直接返回，不会进入授权流程。<strong>是其他URI时，就会跳过认证，直接进入授权流程</strong>。</p><p>Spring Security的授权工作主要由<code>FilterSecurityInterceptor</code>完成，它也是个Filter实现类。它是Security过滤器链中位置倒数第二的Filter，若进入了它的授权逻辑，授权成功则走出Security过滤器链，进入下一步；授权失败则请求结束，返回响应体或跳转页面。</p><ol><li>请求进入<code>FilterSecurityInterceptor</code>拦截器，调用其父类方法<code>super.beforeInvocation(fi)</code>，继续调用<code>FilterInvocationSecurityMetadataSource.getAttributes()</code>获取被拦截URI所需的权限字符串集合。Security内置了一些权限字符串，如“permitAll”</li><li>若<code>FilterInvocationSecurityMetadataSource.getAttributes()</code>方法返回NULL，则FilterSecurityInterceptor执行完毕，<strong>请求走出Security过滤器链</strong>。因此可以认为返回NULL的URI是无需权限访问的</li><li>被拦截URI的权限不为NULL，则FilterSecurityInterceptor通过<code>SecurityContext.getAuthentication()</code>取得当前用户的权限信息，再调用授权管理器<code>AccessDecisionManager.decide()</code>方法决定是否允许用户访问此URI。这个方法由AccessDecisionManager子类实现，Spring已实现的decide策略有<code>AffirmativeBased</code>一票肯定，<code>UnanimousBased</code>一票否定，<code>ConsensusBased</code>少数服从多数。默认使用AffirmativeBased</li><li>若用户无权访问，AccessDecisionManager.decide()抛出<code>AccessDeniedException</code>异常，这个异常会被<code>ExceptionTranslationFilter</code>处理，这个后面再讲</li><li>AccessDecisionManager.decide()顺利执行完毕，表示用户有权访问，即授权成功，<strong>请求走出Security过滤器链</strong></li></ol><blockquote><p>若未登录用户直接访问URI，AccessDecisionManager会怎么判断？<br>这个要看URI的权限，如果URI的权限是“permitAll”，则未登录用户也可以访问。具体看AffirmativeBased类的源码。</p></blockquote><p>另外，请求走出Security过滤器链后，不一定就直接进入Controller，因为走完Security过滤器链之后可能还有过滤器。这部分内容见“过滤器链”一节。</p><p>授权成功流程：</p><img src="/2020/08/23/spring-security-auth/authorization_success.png" class="" title="授权成功"><p>授权失败流程：</p><img src="/2020/08/23/spring-security-auth/authorization_fail.png" class="" title="授权失败"><h2 id="AccessDecisionManager和FilterInvocationSecurityMetadataSource"><a href="#AccessDecisionManager和FilterInvocationSecurityMetadataSource" class="headerlink" title="AccessDecisionManager和FilterInvocationSecurityMetadataSource"></a>AccessDecisionManager和FilterInvocationSecurityMetadataSource</h2><p>接口源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * authentication是当前用户信息，里面包含用户拥有的权限</span></span><br><span class="line"><span class="comment"> * object是被拦截URI</span></span><br><span class="line"><span class="comment"> * configAttributes是被拦截URI对应的权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException,</span></span><br><span class="line"><span class="function">InsufficientAuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回true表示此类失效</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decide()方法参数介绍：</p><ol><li><code>authentication</code>是从SecurityContext中拿到的当前用户信息，里面包含用户拥有的权限</li><li><code>object</code>代表被拦截URI</li><li><code>configAttributes</code>是<code>FilterInvocationSecurityMetadataSource.getAttributes()</code>返回的，代表被拦截URI所需权限</li></ol><p>FilterInvocationSecurityMetadataSource.getAttributes()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Collection&lt;ConfigAttribute&gt; <span class="title">getAttributes</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br></pre></td></tr></table></figure><p><code>getAttributes()</code>方法返回一个<code>Collection&lt;ConfigAttribute&gt;</code>对象，ConfigAttribute是个接口，一般使用它的实现类<code>SecurityConfig</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigAttribute</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回表示权限的String</span></span><br><span class="line"><span class="function">String <span class="title">getAttribute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>Collection&lt;ConfigAttribute&gt;</code>是不是和认证流程中提到的<code>Collection&lt;GrantedAuthority&gt;</code>很像？它们都是权限字符串的集合，区别在于前者是被拦截URI的权限集合，后者是用户拥有的权限集合。</p><h2 id="ExceptionTranslationFilter"><a href="#ExceptionTranslationFilter" class="headerlink" title="ExceptionTranslationFilter"></a>ExceptionTranslationFilter</h2><p>ExceptionTranslationFilter在Security过滤器链中放在FilterSecurityInterceptor前一位，但它可以捕获过滤器链中，甚至过滤器链之后的，任一个Filter抛出的异常，这其中就包括FilterSecurityInterceptor抛出的异常。这是因为，它在doFilter方法中，把<code>chain.doFilter(request, response);</code>整个try-catch了。</p><p>虽然它捕获了过滤器链中所有类型的异常，但它只处理两种异常：<code>AuthenticationException</code>和<code>AccessDeniedException</code>，其它的异常它会继续抛出。</p><p>若异常为<code>AuthenticationException</code>，它会调用<code>AuthenticationEntryPoint.commence()</code>处理。一般的做法是重定向到登录页。若异常为<code>AccessDeniedException</code>，它分两种情况，若用户未登录，它调用<code>AuthenticationEntryPoint.commence()</code>处理；若用户已登录但无权限，它调用<code>AccessDeniedHandler.handle()</code>处理。</p><p>值得一提的是，在认证过程中抛出的<code>AuthenticationException</code>由<code>UsernamePasswordAuthenticationFilter</code>自己处理后返回，不会进入ExceptionTranslationFilter。即<strong>只有授权时抛出的异常会由它处理</strong>。</p><h2 id="自定义实现思路-1"><a href="#自定义实现思路-1" class="headerlink" title="自定义实现思路"></a>自定义实现思路</h2><ol><li>自定义<code>AccessDecisionManager.decide()</code>，实现自己的授权逻辑，比如直接判断用户权限是否包含此URI，而不是用Security提供的投票方式</li><li>自定义<code>FilterInvocationSecurityMetadataSource.getAttributes()</code>，实现自己的查找URI所需权限的方式，如从数据库查找</li><li>自定义ExceptionTranslationFilter处理异常的方法，<code>AuthenticationEntryPoint.commence()</code>和<code>AccessDeniedHandler.handle()</code></li></ol><p>以上自定义可以实现基本的授权需求，更高级的需要查阅其他资料。</p><h2 id="自定义实现示例-1"><a href="#自定义实现示例-1" class="headerlink" title="自定义实现示例"></a>自定义实现示例</h2><p>配置示例（只写出与授权有关的部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">http</span><br><span class="line">.authorizeRequests()</span><br><span class="line">.anyRequest().authenticated() <span class="comment">// 所有请求都需要认证授权</span></span><br><span class="line">.withObjectPostProcessor(<span class="keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123; <span class="comment">// 设置FilterSecurityInterceptor属性</span></span><br><span class="line"><span class="keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="function">O <span class="title">postProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">O fsi)</span> </span>&#123;</span><br><span class="line">fsi.setAccessDecisionManager(<span class="keyword">new</span> CustomAccessDecisionManager()); <span class="comment">// 自定义AccessDecisionManager</span></span><br><span class="line">fsi.setSecurityMetadataSource(<span class="keyword">new</span> CustomFilterInvocationSecurityMetadataSource()); <span class="comment">// 自定义FilterInvocationSecurityMetadataSource</span></span><br><span class="line"><span class="keyword">return</span> fsi;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.and()</span><br><span class="line">.exceptionHandling() <span class="comment">// 以下两行设置ExceptionTranslationFilter属性</span></span><br><span class="line">.accessDeniedHandler(<span class="keyword">new</span> CustomAccessDeniedHandler()) <span class="comment">// 自定义AccessDeniedHandler</span></span><br><span class="line">.authenticationEntryPoint(<span class="keyword">new</span> CustomAuthenticationEntryPoint()) <span class="comment">// 自定义AuthenticationEntryPoint</span></span><br><span class="line">.and()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义AccessDecisionManager示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAccessDecisionManager</span> <span class="keyword">implements</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// authentication是从spring的全局缓存SecurityContextHolder中拿到的，里面是用户的权限信息(权限编码)</span></span><br><span class="line"><span class="comment">// object是被拦截URI</span></span><br><span class="line"><span class="comment">// configAttributes是被拦截URI对应的权限(权限编码)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"=========================AccessDecisionManager=============================="</span>);</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(configAttributes)) &#123; <span class="comment">// 被拦截URI所需权限为空，直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br><span class="line"><span class="comment">// 简单的判断用户权限中是否包含URI权限</span></span><br><span class="line"><span class="keyword">for</span> (ConfigAttribute attr : configAttributes) &#123;</span><br><span class="line">String attribute = attr.getAttribute();</span><br><span class="line"><span class="keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">String authority2 = authority.getAuthority();</span><br><span class="line"><span class="keyword">if</span> (authority2.equals(attribute)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(<span class="string">"无权访问"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h1><p>在Security配置类<code>WebSecurityConfigurerAdapter</code>的初始化方法中，会给<code>HttpSecurity</code>设置一些过滤器。这个动作在执行我们重写的<code>configure()</code>方法之前。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> HttpSecurity <span class="title">getHttp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!disableDefaults) &#123; <span class="comment">// 启用默认配置</span></span><br><span class="line">http</span><br><span class="line">.csrf().and() <span class="comment">// 4.CsrfFilter</span></span><br><span class="line">.addFilter(<span class="keyword">new</span> WebAsyncManagerIntegrationFilter()) <span class="comment">// 1.WebAsyncManagerIntegrationFilter</span></span><br><span class="line">.exceptionHandling().and() <span class="comment">//11.ExceptionTranslationFilter</span></span><br><span class="line">.headers().and() <span class="comment">// 3.HeaderWriterFilter</span></span><br><span class="line">.sessionManagement().and() <span class="comment">// 10.SessionManagementFilter</span></span><br><span class="line">.securityContext().and() <span class="comment">// 2.SecurityContextPersistenceFilter</span></span><br><span class="line">.requestCache().and() <span class="comment">//7.RequestCacheAwareFilter</span></span><br><span class="line">.anonymous().and() <span class="comment">// 9.AnonymousAuthenticationFilter</span></span><br><span class="line">.servletApi().and() <span class="comment">// 8.SecurityContextHolderAwareRequestFilter</span></span><br><span class="line">.apply(<span class="keyword">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and()</span><br><span class="line">.logout(); <span class="comment">// 5.LogoutFilter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面展示的部分源码，作用主要是注册了10个Filter，数字代表它们在过滤器链中的顺序。这些过滤器的顺序是在<code>FilterComparator</code>类中定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FilterComparator() &#123;</span><br><span class="line"><span class="keyword">int</span> order = <span class="number">100</span>;</span><br><span class="line">put(ChannelProcessingFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line">order += STEP;</span><br><span class="line">put(ConcurrentSessionFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line">order += STEP;</span><br><span class="line">put(WebAsyncManagerIntegrationFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line">order += STEP;</span><br><span class="line">put(SecurityContextPersistenceFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line">order += STEP;</span><br><span class="line">put(HeaderWriterFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line"><span class="comment">// 太多了，其余略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那在我们什么配置都没有的情况下，<code>UsernamePasswordAuthenticationFilter</code>是在哪里注册并起作用的？<br>在默认的<code>WebSecurityConfigurerAdapter.configure()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">http</span><br><span class="line">.authorizeRequests()</span><br><span class="line">.anyRequest().authenticated()</span><br><span class="line">.and()</span><br><span class="line">.formLogin().and() <span class="comment">// UsernamePasswordAuthenticationFilter</span></span><br><span class="line">.httpBasic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一行<code>formLogin()</code>，工作包括初始化UsernamePasswordAuthenticationFilter，并设置其成员变量<code>requiresAuthenticationRequestMatcher=POST /login</code>，这个成员变量就代表登录提交URI loginProcessingUrl，即要进入认证流程的URI。</p><p><strong>注意：</strong>Spring Security的这一整套过滤器，是以<strong>一个过滤器的身份</strong>被添加到<code>ApplicationFilterChain</code>中。ApplicationFilterChain就是Tomcat整理的过滤器链。这“一个过滤器”名叫“SpringSecurityFilterChain”。若我们自定义Filter没有添加到Security过滤器链中，这个Filter会排在Security过滤器链之后，即执行完Security所有过滤器后才会执行到这个Filter。</p><p>像下面这个自定义Filter就是没有加入到Security过滤器链中，只是加入了ApplicationFilterChain：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何把自定义Filter添加到Security过滤器链中？下面说明。</p><h2 id="添加自定义过滤器"><a href="#添加自定义过滤器" class="headerlink" title="添加自定义过滤器"></a>添加自定义过滤器</h2><p>想在Security的过滤器链中的某个位置加入自定义过滤器，可以使用HttpSecurity的3种方法：</p><ol><li>addFilterBefore(Filter filter, Class&lt;? extends Filter&gt; beforeFilter)</li><li>addFilterAfter(Filter filter, Class&lt;? extends Filter&gt; afterFilter)</li><li>addFilterAt(Filter filter, Class&lt;? extends Filter&gt; atFilter)</li></ol><p>这3个方法的前一个参数就是自定义Filter对象，后一个表示自定义Filter要放在哪个默认Filter的前面，或者后面，或者就放在默认Filter所在位置。</p><p>下面这个例子表示把自定义Filter放在UsernamePasswordAuthenticationFilter的前一个位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterBefore(<span class="keyword">new</span> BeforeLoginFilter(), UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure><p>有一个问题，若使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterAt(<span class="keyword">new</span> AtLoginFilter(), UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure><p>AtLoginFilter是在UsernamePasswordAuthenticationFilter的前面还是后面，还是把UsernamePasswordAuthenticationFilter覆盖？</p><p>答案是addFilterAt()不会覆盖UsernamePasswordAuthenticationFilter，且在它之前。具体原因是，<code>HttpSecurity</code>会用一个<code>List&lt;Filter&gt;</code>保存系统中所有自定义和默认的Filter，<strong>自定义过滤器是先于大部分默认过滤器被加入到List中的</strong>。在放入的同时，自定义Filter会被<code>FilterComparator</code>安排一个序号，这个序号等于UsernamePasswordAuthenticationFilter的序号。Spring在初始化过滤器链时，调用<code>HttpSecurity.performBuild()</code>方法，方法中使用FilterComparator对List中元素进行排序，<strong>序号一致的维持原序</strong>。因此使用addFilterAt()时，自定义Filter会在默认Filter之前。</p><h1 id="permitAll"><a href="#permitAll" class="headerlink" title="permitAll()"></a>permitAll()</h1><p>我在参考官方文档配置Spring Security时，看到两个<code>permitAll()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">.authorizeRequests()</span><br><span class="line">.antMatchers(<span class="string">"/favicon.ico"</span>).permitAll() <span class="comment">// 1</span></span><br><span class="line">.and()</span><br><span class="line">.formLogin()</span><br><span class="line">.permitAll()<span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>第一个permitAll是<code>ExpressionUrlAuthorizationConfigurer.AuthorizedUrl.permitAll()</code>，第二个是<code>FormLoginConfigurer&lt;HttpSecurity&gt;.permitAll()</code>。它们的作用都是，把这些指定的URI的权限字符串设置为“permitAll”，表示允许任何用户访问这些指定的URI，即这些URI无需权限访问，即使用户未登录。</p><p>第一个指定URI是自己添加的，第二个指定的URI是认证过程中会用到的loginPage、loginProcessingUrl、failureUrl这三个URI，它们有默认值。</p><p>无论使用哪个permitAll，这些URI最后会被添加到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfigAttributeRequestMatcherRegistry</span>&lt;<span class="title">C</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class"><span class="title">AbstractRequestMatcherRegistry</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// URI和对应权限保存在此变量</span></span><br><span class="line"><span class="keyword">private</span> List&lt;UrlMapping&gt; urlMappings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlMapping</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> RequestMatcher requestMatcher; <span class="comment">// URI</span></span><br><span class="line"><span class="keyword">private</span> Collection&lt;ConfigAttribute&gt; configAttrs; <span class="comment">// URI对应权限</span></span><br><span class="line"></span><br><span class="line">UrlMapping(RequestMatcher requestMatcher, Collection&lt;ConfigAttribute&gt; configAttrs) &#123;</span><br><span class="line"><span class="keyword">this</span>.requestMatcher = requestMatcher;</span><br><span class="line"><span class="keyword">this</span>.configAttrs = configAttrs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestMatcher <span class="title">getRequestMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> requestMatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getConfigAttrs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> configAttrs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些URI保存后，在创建<code>ExpressionBasedFilterInvocationSecurityMetadataSource</code>时会被取出。这个类是Spring在授权时默认使用的<code>FilterInvocationSecurityMetadataSource</code>实现类。</p><p>被取出时的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfigAttributeRequestMatcherRegistry</span>&lt;<span class="title">C</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class"><span class="title">AbstractRequestMatcherRegistry</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; createRequestMap() &#123;</span><br><span class="line"></span><br><span class="line">LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; requestMap = <span class="keyword">new</span> LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (UrlMapping mapping : getUrlMappings()) &#123;</span><br><span class="line">RequestMatcher matcher = mapping.getRequestMatcher();</span><br><span class="line">Collection&lt;ConfigAttribute&gt; configAttrs = mapping.getConfigAttrs();</span><br><span class="line">requestMap.put(matcher, configAttrs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> requestMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出后被封装为<code>LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt;</code>类型，保存了原本在List中的顺序，赋值给<code>ExpressionBasedFilterInvocationSecurityMetadataSource</code>的成员变量<code>requestMap</code>。</p><p>在Spring默认配置的授权流程中，有请求访问这些URI时，只要不是会进入认证过程的<code>POST loginProcessingUrl</code>，就会进入<code>FilterSecurityInterceptor</code>。FilterSecurityInterceptor调用<code>ExpressionBasedFilterInvocationSecurityMetadataSource.getAttribute()</code>方法，得到这些URI的权限字符串是“permitAll”，再通过<code>AccessDecisionManager.decide()</code>决定此URI允许访问（默认调用AffirmativeBased）。因此无论用户是否登录、是否有权限，都可访问此URI。</p><p>由于这些permitAll()方法是在Spring默认实现的AccessDecisionManager.decide()中起作用，若我们自定义的AccessDecisionManager.decide()不会使用“permitAll”权限字符串，则可以不用设置。</p><h1 id="WebSecurity"><a href="#WebSecurity" class="headerlink" title="WebSecurity"></a>WebSecurity</h1><p>WebSecurity一般用来设置不想被Security拦截的静态资源URI。如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">web.ignoring().antMatchers(<span class="string">"/css/**"</span>, <span class="string">"/webjars/**"</span>, <span class="string">"/img/**"</span>, <span class="string">"/js/**"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些URI会跳过Security的过滤器链，但不会跳过在Security过滤器链之后的Filter。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java Web 流处理笔记</title>
      <link href="/2020/08/01/java-stream-note/"/>
      <url>/2020/08/01/java-stream-note/</url>
      
        <content type="html"><![CDATA[<h1 id="不同ContentType的请求流读取方式"><a href="#不同ContentType的请求流读取方式" class="headerlink" title="不同ContentType的请求流读取方式"></a>不同ContentType的请求流读取方式</h1><p>读取请求流一般就用这三种方式：</p><ol><li>request.getInputStream()</li><li>request.getReader()</li><li>request.getParameterNames()/request.getParameterMap()/request.getParameter(key)</li></ol><blockquote><p>记住，流只能读取一次。</p></blockquote><p>其中，<code>request.getInputStream()</code>和<code>request.getReader()</code>适用：</p><ul><li>GET application/x-www-form-urlencoded</li><li>POST application/json</li></ul><p>不适用：</p><ul><li>GET URI参数</li><li>POST application/x-www-form-urlencoded</li></ul><p><code>request.getParameter</code>的适用场景刚好相反。</p><p>示例代码：<br><code>request.getInputStream()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/is"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">is</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">String result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(request.getInputStream());</span><br><span class="line"><span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line"><span class="keyword">while</span> ((len = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">out.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">result = out.toString();</span><br><span class="line">System.out.println(result); <span class="comment">// 打印请求内容</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(result))&#123; <span class="comment">// 读不到就返回500</span></span><br><span class="line">response.setStatus(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">response.setStatus(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>request.getReader()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/reader"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">String result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">BufferedReader reader = request.getReader();</span><br><span class="line">StringWriter writer = <span class="keyword">new</span> StringWriter();</span><br><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((count = reader.read(chars)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">writer.write(chars, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br><span class="line">result = writer.toString();</span><br><span class="line">System.out.println(result); <span class="comment">// 打印请求内容</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(result))&#123; <span class="comment">// 读不到就返回500</span></span><br><span class="line">response.setStatus(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">response.setStatus(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>request.getParameterMap()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/param"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">param</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">String result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">Set&lt;Map.Entry&lt;String, String[]&gt;&gt; entrySet = parameterMap.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String[]&gt; entry : entrySet) &#123;</span><br><span class="line">String key = entry.getKey();</span><br><span class="line">String value = Arrays.toString(entry.getValue());</span><br><span class="line">result += key + <span class="string">"="</span> + value + <span class="string">"&amp;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result); <span class="comment">// 打印请求内容</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(result))&#123; <span class="comment">// 读不到就返回500</span></span><br><span class="line">response.setStatus(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">response.setStatus(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包装请求流"><a href="#包装请求流" class="headerlink" title="包装请求流"></a>包装请求流</h1><p>我们经常要在Filter或Interceptor中提前处理请求，如果在这里读了请求流，会导致后面的Controller读不到任何请求参数。为了解决“流只能读取一次”的问题，我们需要一个<code>HttpServletRequestWrapper</code>。<br>HttpServletRequestWrapper示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String[]&gt; parameterMap = <span class="keyword">new</span> HashMap&lt;String, String[]&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String bodyString;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHttpServletRequestWrapper</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(request);</span><br><span class="line"><span class="comment">// 读请求流</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(request.getInputStream());</span><br><span class="line"><span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line"><span class="keyword">while</span> ((len = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">out.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">body = out.toByteArray(); <span class="comment">// 把请求体保存在body</span></span><br><span class="line">bodyString = <span class="keyword">new</span> String(body, StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用getInputStream没读到请求体，改用getParameterMap读</span></span><br><span class="line"><span class="keyword">if</span>(body.length == <span class="number">0</span>) &#123;</span><br><span class="line">parameterMap.putAll(request.getParameterMap());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(body);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ServletInputStream() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bais.read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReadListener</span><span class="params">(ReadListener readListener)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BufferedReader <span class="title">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(getInputStream()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">String[] values = <span class="keyword">this</span>.parameterMap.get(name);</span><br><span class="line"><span class="keyword">if</span>(values != <span class="keyword">null</span> &amp; values.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> values[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.parameterMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;(parameterMap.keySet());</span><br><span class="line"><span class="keyword">return</span> vector.elements();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBodyString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bodyString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBodyString</span><span class="params">(String bodyString)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.bodyString = bodyString;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了上面这个包装类的Filter示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@WebFilter</span>(urlPatterns = &#123;<span class="string">"/*"</span>&#125;) <span class="comment">// 拦截URI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">        HttpServletResponse httpServletResponse = (HttpServletResponse) response;</span><br><span class="line">        </span><br><span class="line">        MyHttpServletRequestWrapper requestWrapper = <span class="keyword">new</span> MyHttpServletRequestWrapper(httpServletRequest);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"请求URI: "</span> + httpServletRequest.getRequestURI());</span><br><span class="line">        System.out.println(<span class="string">"请求参数: "</span> + requestWrapper.getBodyString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把原生的httpServletRequest换成requestWrapper传给Controller</span></span><br><span class="line">        chain.doFilter(requestWrapper, httpServletResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Zuul网关包装请求流"><a href="#Zuul网关包装请求流" class="headerlink" title="Zuul网关包装请求流"></a>Zuul网关包装请求流</h2><p>Spring Cloud的组件Zuul网关的一大功能就是可以由我们自定义一串Filter链，在这些Filter中也会需要读请求流。为了在每个Filter以及网关后面的服务能重复读取请求流，是否要在Zuul网关实现一个<code>HttpServletRequestWrapper</code>？Zuul已经帮我们实现好了。</p><p>到达网关的请求一定会经过<code>Servlet30WrapperFilter</code>，在这个Filter中，会把请求封装到<code>Servlet30RequestWrapper</code>，它是<code>HttpServletRequestWrapper</code>的实现类。</p><p><code>Servlet30WrapperFilter</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet30WrapperFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Field requestField = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Servlet30WrapperFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.requestField = ReflectionUtils.findField(HttpServletRequestWrapper<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">"req", HttpServletRequest.class);</span><br><span class="line">Assert.notNull(<span class="keyword">this</span>.requestField,</span><br><span class="line"><span class="string">"HttpServletRequestWrapper.req field not found"</span>);</span><br><span class="line"><span class="keyword">this</span>.requestField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Field <span class="title">getRequestField</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.requestField;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> PRE_TYPE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SERVLET_30_WRAPPER_FILTER_ORDER; <span class="comment">// -2，值越小优先级越高</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// <span class="doctag">TODO:</span> only if in servlet 3.0 env</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">HttpServletRequest request = ctx.getRequest();</span><br><span class="line"><span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequestWrapper) &#123;</span><br><span class="line">request = (HttpServletRequest) ReflectionUtils.getField(<span class="keyword">this</span>.requestField,</span><br><span class="line">request);</span><br><span class="line">ctx.setRequest(<span class="keyword">new</span> Servlet30RequestWrapper(request)); <span class="comment">// 用wrapper封装</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RequestUtils.isDispatcherServletRequest()) &#123;</span><br><span class="line"><span class="comment">// If it's going through the dispatcher we need to buffer the body</span></span><br><span class="line">ctx.setRequest(<span class="keyword">new</span> Servlet30RequestWrapper(request)); <span class="comment">// 用wrapper封装</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在自定义Filter中，用下面两行代码获取HTTP请求时，请求的类型就是<code>Servlet30RequestWrapper</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">HttpServletRequest request = ctx.getRequest(); <span class="comment">// Servlet30RequestWrapper类型</span></span><br></pre></td></tr></table></figure><h1 id="上传文件接口的请求流"><a href="#上传文件接口的请求流" class="headerlink" title="上传文件接口的请求流"></a>上传文件接口的请求流</h1><p>WEB项目中经常要实现文件上传，这就涉及到文件流的处理。下面一段代码展示了如何接受文件并保存在本地。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/upload"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(MultipartFile file, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 除了文件以外的请求字段</span></span><br><span class="line">String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">String type = request.getParameter(<span class="string">"type"</span>);</span><br><span class="line">System.out.println(<span class="string">"name="</span> + name);</span><br><span class="line">System.out.println(<span class="string">"type="</span> + type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件保存到本地</span></span><br><span class="line">OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">InputStream is = <span class="keyword">null</span>;</span><br><span class="line">String fileName = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">is = file.getInputStream();</span><br><span class="line">fileName = file.getOriginalFilename();</span><br><span class="line">String path = <span class="string">"D:\\test\\"</span>;</span><br><span class="line"><span class="comment">// 1K的数据缓冲</span></span><br><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// 读取到的数据长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">// 输出的文件流保存到本地文件</span></span><br><span class="line">File tempFile = <span class="keyword">new</span> File(path);</span><br><span class="line"><span class="keyword">if</span> (!tempFile.exists()) &#123;</span><br><span class="line">tempFile.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">os = <span class="keyword">new</span> FileOutputStream(tempFile.getPath() + File.separator + fileName);</span><br><span class="line"><span class="keyword">while</span> ((len = is.read(bs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">os.write(bs, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="string">"fail"</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 完毕，关闭所有链接</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">is.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">os.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用Postman测试该接口时，Body中Content-Type选择<code>form-data</code>。</p></blockquote><h1 id="复制InputStream"><a href="#复制InputStream" class="headerlink" title="复制InputStream"></a>复制InputStream</h1><p>如何把一个inputStream复制成多份？需要借助<code>ByteArrayInputStream/OutputStream</code>。<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InputStream input =  httpconn.getInputStream();</span><br><span class="line">  </span><br><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();  </span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line"><span class="keyword">int</span> len;  </span><br><span class="line"><span class="keyword">while</span> ((len = input.read(buffer)) &gt; -<span class="number">1</span> ) &#123;  </span><br><span class="line">baos.write(buffer, <span class="number">0</span>, len);  </span><br><span class="line">&#125;</span><br><span class="line">baos.flush();</span><br><span class="line"><span class="comment">// 复制</span></span><br><span class="line">InputStream stream1 = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">InputStream stream2 = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br></pre></td></tr></table></figure><h1 id="附：流基本方法"><a href="#附：流基本方法" class="headerlink" title="附：流基本方法"></a>附：流基本方法</h1><p><strong>输入流读取数据，输出流写入数据</strong>。所以下面的read方法都是InputStream的，write方法都是OutputStream的。</p><h2 id="一次读取-写入一个字节"><a href="#一次读取-写入一个字节" class="headerlink" title="一次读取/写入一个字节"></a>一次读取/写入一个字节</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br></pre></td></tr></table></figure><p>读取方法返回值int，代表从input读到的一个字节内容，可以按ASCII码转为char类型。写入方法的参数int则是要写入output的一个字节。尽管int类型数据最多可以是4个字节，但在流这里就被限制在了0~255之间。循环调用这两个读写方法可以达到读取/写入多个字节的效果，但效率低下，<strong>不建议使用</strong>。</p><h2 id="一次写入多个字节"><a href="#一次写入多个字节" class="headerlink" title="一次写入多个字节"></a>一次写入多个字节</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure><p>第一个方法是把字节数组<code>byte[] data</code>的内容全部写入output，第二个方法是指定字节数组从<code>offset</code>开始连续<code>length</code>长度的子数组的内容写入output。数据流向：byte[] -&gt; output<br>PS：如果使用BufferedOutputStream，往流中写数据时，数据会先存放在一个缓冲区，当缓冲区满了，数据才会被发送出去。最好调用<code>output.flush()</code>强制缓冲区发送数据。</p><h2 id="一次读取多个字节"><a href="#一次读取多个字节" class="headerlink" title="一次读取多个字节"></a>一次读取多个字节</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure><p>第一个方法是读取input填充到字节数组<code>byte[] data</code>，第二个方法是读取input填充到字节数组<code>byte[] data</code>从<code>offset</code>开始连续<code>length</code>长度的子数组。数据流向：input -&gt; byte[]</p><p>返回值int代表实际读取的字节数。如下面方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = input.read(bytes);</span><br></pre></td></tr></table></figure><p>上面两行代码尝试从输入流input中读取1024字节，但可能一次读取只读到512字节，因此len=512。<br>如果希望读取输入流input的全部内容，需要多次调用read方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line"><span class="keyword">while</span> ((len = input.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">output.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读不到内容时，len=-1，退出循环，此时输入流in的内容全部读完了。<br>上面代码表示，从输入流input中读取数据，可能一次全部读完，也可能只读出部分，读出的数据填充到bytes，再把bytes的数据写入输出流output，这个过程循环，直到input数据读完。数据流向：input -&gt; byte[] -&gt; output</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java HashMap原理·</title>
      <link href="/2020/07/08/java-hashmap/"/>
      <url>/2020/07/08/java-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Map接口实现类包括：HashMap、TreeMap、Hashtable、LinkedHashMap、ConcurrentHashMap。根据key的hashcode值来存储数据，可以根据key获取value。</p><p>实现类之间的区别：</p><ul><li><p>HashMap</p><ul><li>不保存每个元素的插入顺序，无序存放（存放顺序与key的hash值有关）</li><li>具有很快的访问速度</li><li>最多只允许一条记录的key值为null(多条会覆盖)</li><li>允许多条记录的value为null</li><li>非同步；非线程安全</li></ul></li><li><p>TreeMap</p><ul><li>是通过红黑树实现的</li><li>默认key升序排序存放，可以写Comparator接口改变排序方式</li><li>不允许key的值为null</li><li>非同步</li></ul></li><li><p>HashTable</p><ul><li>不允许key、value的值为null</li><li>同步；线程安全（很多方法加了synchronized锁）</li><li>由于引入了线程安全，处理效率没有HashMap高</li></ul></li><li><p>LinkedHashMap</p><ul><li>基于HashMap和双向链表，有序存放</li><li>具有很快的访问速度</li><li>最多只允许一条记录的key值为null(多条会覆盖)</li><li>允许多条记录的value为null</li><li>非同步；非线程安全</li></ul></li><li><p>ConcurrentHashMap</p><ul><li>线程安全，读写快，底层实现是一种以空间换时间的结构，创建的时候直接分了16个segment，每个segment实际上存储的还是HashTable，写入的时候先找到对应的segment，然后对segment加锁，写完，解锁。锁segment的时候其他segment还可以继续工作。</li><li>使用场景：当项目中的全局变量有多线程操作时需要用ConcurrentHashMap</li></ul></li></ul><p>下面重点介绍HashMap原理。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>JDK1.8之前，HashMap是数组+链表存储。JDK1.8及其之后，先用数组+链表，当链表长度&gt;=8时，就是数组+红黑树（原链表元素组成）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>; <span class="comment">// 数组默认长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1073741824</span>; <span class="comment">// 2^30, int最大值是2^31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75F</span>; <span class="comment">// 默认负载因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 当链表长度=8时，链表转为红黑树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>; <span class="comment">// 红黑树转为链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K, V&gt;[] table; <span class="comment">// 数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">// 元素总数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">// map被修改的次数，包括put、remove操作等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> threshold; <span class="comment">// threshold=数组长度*负载因子，初始值=16*0.75=12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line">Node&lt;K, V&gt; next;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">TreeNode&lt;K, V&gt; parent;</span><br><span class="line">TreeNode&lt;K, V&gt; left;</span><br><span class="line">TreeNode&lt;K, V&gt; right;</span><br><span class="line">TreeNode&lt;K, V&gt; prev;</span><br><span class="line"><span class="keyword">boolean</span> red;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Node</code>与<code>TreeNode</code>之间的继承关系： Map.Entry&lt;K, V&gt; –&gt; HashMap.Node&lt;K, V&gt; –&gt; LinkedHashMap.Entry&lt;K, V&gt; –&gt; HashMap.TreeNode&lt;K, V&gt; 。所以<code>Node</code>是<code>TreeNode</code>的间接父类。</p><p><strong>红黑树</strong>和MySQL索引结构<strong>B+树</strong>，都属于平衡二叉树。区别在于，红黑树一个节点只含一条数据，而B+树是B树的变种，B树一个节点含多条数据，用于查找的key和数据都在节点上，B+树的非叶子节点不再保存数据，而只保存key，叶子节点保存数据，并且所有的叶子节点按顺序使用链表进行连接。</p><p><strong>相关博客</strong>：<br>红黑树的规则和原理，包括左旋右旋：<a href="https://www.cnblogs.com/LiaHon/p/11203229.html" target="_blank" rel="noopener">https://www.cnblogs.com/LiaHon/p/11203229.html</a><br>负载因子0.75的作用：<a href="http://baijiahao.baidu.com/s?id=1656137152537394906&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1656137152537394906&amp;wfr=spider&amp;for=pc</a><br>HashMap部分源码：<a href="https://itimetraveler.github.io/2017/11/25/%E3%80%90Java%E3%80%91HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88JDK1.8%EF%BC%89/#get-%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">https://itimetraveler.github.io/2017/11/25/%E3%80%90Java%E3%80%91HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88JDK1.8%EF%BC%89/#get-%E6%96%B9%E6%B3%95</a></p><h1 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h1><p>put(key,value)时，HashMap先用key的hashcode计算出一个新的hash值，再用hash值和数组长度计算出一个<strong>数组下标</strong>。如果该数组位上为空，则直接添加key-value并返回NULL。如果该数组位上已经有元素，那么就遍历该数组位上的所有元素，比较要添加的key和现有元素是否相等，若相等就覆盖旧元素，并返回旧元素的value。若没有相等的，就直接添加进去。</p><p>向链表中添加元素时，用的是“尾插法”（JDK1.7中用的是“头插法”）。</p><p>比较key是否相同时，用的是equals方法，因为equals方法默认比较的是内存地址，所以如果用自定义类的对象做key，这个类需要重写equals方法。</p><p>关于hash值和数组下标的计算可以看这篇博客：<a href="https://www.cnblogs.com/eycuii/p/12015283.html" target="_blank" rel="noopener">https://www.cnblogs.com/eycuii/p/12015283.html</a> 。理解了hash值和数组下标的原理，我们可以回答一个常见的面试题：</p><blockquote><p>HashMap数组长度为什么都是2的k次方？</p></blockquote><p>首先，对于计算机来说，使用像左移、右移、与或非这样的<strong>位运算</strong>，效率比人类习惯的加减乘除以及取模更高，所以源码里计算数组下标都是用位运算。用位运算，就要把数组长度值转为二进制，任何数都能转为二进制，为什么偏偏指定2的k次方？因为计算数组下标时，公式是<code>i = hash &amp; (length - 1)</code>，当length=2^k时，length - 1就是在低k位连续分布的1，这样在做“与”运算时，能够完全利用hash的低k位的所有值，使得多个hash的“与”结果不同，达到了分散数组位的目的。</p><blockquote><p>(2^k) - 1 = 2^(k-1) + 2^(k-2) + … + 1，这是由等比数列求和公式得到的。</p></blockquote><p>put方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K paramK, V paramV)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (V) putVal(hash(paramK), paramK, paramV, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 数组为空（第一次put）</span></span><br><span class="line">n = (tab = resize()).length; <span class="comment">// 先扩容</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 该数组位无元素</span></span><br><span class="line">tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组位上已有元素p</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p.key和要添加的key相同</span></span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">e = p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p是红黑树</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="comment">// putTreeVal()方法会判断要添加的key是否已存在，已存在就覆盖旧节点并返回旧节点，不存在就直接添加节点并返回NULL</span></span><br><span class="line">e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他情况，如p是链表</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123; <span class="comment">// 死循环，目的是遍历链表</span></span><br><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">p.next = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 尾插法</span></span><br><span class="line"><span class="comment">// 当binCount&gt;=7，即链表长度为9时，链表改为红黑树</span></span><br><span class="line"><span class="comment">// 为什么是9？因为当binCount=0时，走到这步，链表节点已经有2个了</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) </span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// e = p.next, e.key和要添加的key相同</span></span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">p = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e为key相同的旧元素，返回e.value</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">V oldValue = e.value;</span><br><span class="line"><span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">e.value = value;</span><br><span class="line">afterNodeAccess(e);</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">++modCount;  <span class="comment">// 修改次数+1</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">resize(); <span class="comment">// size+1 &gt; threshold需要扩容</span></span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RESIZE"><a href="#RESIZE" class="headerlink" title="RESIZE"></a>RESIZE</h1><p>resize()方法为私有，调用点都在HashMap内部。具体在：</p><ol><li>put(key,value)，具体见上一节源码</li><li>new HashMap(map2)或putAll(map2)，批量添加map元素</li><li>put(key,value)中链表转红黑树时treeifyBin()方法</li><li>computeIfAbsent()方法内</li><li>compute()方法内</li><li>merge()方法内</li></ol><p>resize()方法是JDK1.8和1.7的区别比较大的地方。区别在于：</p><ol><li>JDK1.8引入了红黑树的处理</li><li>重新安排链表元素时，计算新下标的方式。虽然方式不同，但结果不变</li><li>元素插入链表的方式。1.7用头插法，1.8用尾插法</li></ol><p>下面借助两个版本的resize()源码讲讲这些区别。</p><p>JDK1.7的resize方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">Entry[] oldTable = table;</span><br><span class="line"><span class="keyword">int</span> oldCapacity = oldTable.length;  </span><br><span class="line"><span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">threshold = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">return</span>;  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">transfer(newTable); <span class="comment">// 在这个方法内重新安排元素</span></span><br><span class="line">table = newTable;</span><br><span class="line">threshold = (<span class="keyword">int</span>) (newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">Entry[] src = table;</span><br><span class="line"><span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">Entry&lt;K, V&gt; e = src[j];</span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">src[j] = <span class="keyword">null</span>; <span class="comment">// 释放旧Entry数组的对象引用。for循环后，旧数组不再引用任何对象</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">Entry&lt;K, V&gt; next = e.next;  </span><br><span class="line"><span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">// 计算新数组位，和put时一致</span></span><br><span class="line">e.next = newTable[i]; <span class="comment">// 头插法</span></span><br><span class="line">newTable[i] = e;</span><br><span class="line">e = next;</span><br><span class="line">&#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> h &amp; (length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8的resize方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// MAXIMUM_CAPACITY=2^30，这里if块内代码的意思是，如果oldCap已经达到MAXIMUM_CAPACITY，就不扩容，直接把扩容阈值threshold增加到int型最大值2^31</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class="comment">// newCap = oldCap * 2</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// newThr = oldThr * 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123; <span class="comment">// e为数组位上元素</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// e是单个元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// e是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// e是链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// 拆分链表的条件</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123; <span class="comment">// 当(e.hash &amp; oldCap) == 0，元素还在原数组位上</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123; <span class="comment">// 当(e.hash &amp; oldCap) == 1，元素在原数组位+oldCap上</span></span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区别一"><a href="#区别一" class="headerlink" title="区别一"></a>区别一</h2><p>区别1：JDK1.8引入了红黑树的处理。</p><p>在TreeNode.split()方法中，会把当前树拆分成两个子链表，然后判断两个子链表的节点数，节点数&lt;=6，就按照链表存储，否则转为红黑树，即“树化”。树化时，遍历树的所有节点的时间复杂度是O(n)，插入树节点的时间复杂度是O(logn)，所以创建红黑树的总时间是O(nlogn)。</p><p>顺便一提，resize处理链表时，是一边遍历一边插入，遍历链表的时间复杂度为O(n)，插入的时间复杂度是O(1)，所以创建链表的总时间是O(n)。</p><p>附上TreeNode.split()方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 分成高位树和低位树，头尾节点先声明</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆分当前树，先用链表存储</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123; <span class="comment">// 拆分条件</span></span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD) <span class="comment">// 节点数&lt;=6，转为链表节点Node</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>)</span><br><span class="line"> <span class="comment">// 树化。在这个方法中，会先新建一个空树，遍历loHead链表元素，添加树节点，最后把这个树放入数组tab中</span></span><br><span class="line">loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考：</strong><br>HashMap内部类TreeNode主要方法源码和解释：<a href="https://www.cnblogs.com/freeorange/p/10804332.html" target="_blank" rel="noopener">https://www.cnblogs.com/freeorange/p/10804332.html</a><br>红黑树的时间复杂度O(logn)的证明：<a href="https://blog.csdn.net/l_o_s/article/details/105703296" target="_blank" rel="noopener">https://blog.csdn.net/l_o_s/article/details/105703296</a> （红黑树查找、插入和删除操作的时间复杂度都是O(logn)）</p><h2 id="区别二"><a href="#区别二" class="headerlink" title="区别二"></a>区别二</h2><p>区别2：重新安排链表元素时，计算新下标的方式。虽然方式不同，但结果不变。</p><p>在1.7中，无论什么情况，新数组位 = e.hash &amp; (newCap - 1)。在1.8中，当只有一个元素时，新数组位的计算和1.7一致；当是链表元素时，新数组位只有“原下标”和“原下标+oldCap”两种位置，而具体是哪个位置，就看(e.hash &amp; oldCap)的值是否等于0。</p><p>乍一看，在1.8中重新安排链表元素时，因为只有两种选择，似乎会加大冲突概率。但实际上，这个做法和1.7的重新计算下标的结果，是完全一致的！！</p><p>我们举例看看在1.7中计算出的新下标的规律：</p><p>设：oldCap = 16, newCap = 32, key1.hash = 107 = (0110 1011), key2.hash = 123 = (0111 1011)<br>则，key1的原下标 = (key.hash) &amp; (oldCap - 1) = (0110 1011) &amp; (0000 1111) = (0000 1011) = 11<br>扩容后，key1的新下标 = (key.hash) &amp; (newCap - 1) = (0110 1011) &amp; (0001 1111) = (0000 1011) = 11</p><p>则，key2的原下标 = (key.hash) &amp; (oldCap - 1) = (0111 1011) &amp; (0000 1111) = (0000 1011) = 11<br>扩容后，key2的新下标 = (key.hash) &amp; (newCap - 1) = (0111 1011) &amp; (0001 1111) = (0001 1011) = 27 = 16 + 11</p><p>在1.7中，即使是重新计算下标，新下标依然只有两种结果：“原下标”和“原下标+oldCap”，这是因为(newCap - 1)只是比(oldCap - 1)多了一位高位1，这个高位1的值就等于oldCap（证明如下）。而这个高位1的值是否对“与”结果起作用，就是看与此高位1对应的key.hash的位上是0还是1，是1才起作用。这就和1.8的逻辑对应上了！</p><blockquote><p>(newCap - 1) - (oldCap - 1)<br>= (2^(k+1) - 1) - (2^k - 1)<br>= (1 + … + 2^(k-1) + 2^k) - (1 + … + 2^(k-1))<br>= 2^k<br>= oldCap</p></blockquote><p>所以，1.8并没有改变新下标的结果，只是代码写得更直接了。</p><h2 id="区别三"><a href="#区别三" class="headerlink" title="区别三"></a>区别三</h2><p>区别3：元素插入链表的方式。1.7用头插法，1.8用尾插法。</p><p>1.7的头插法是HashMap线程不安全的一个原因，简单来说就是多线程会造成环形链表导致死循环。</p><p>假设原HashMap：<br>table[0]=null<br>table[1]=(3,a)-&gt;(7,b)</p><p>当在多线程进行扩容时，<br>线程A遍历到元素(3,a)-&gt;(7,b)-&gt;null停止，<br>线程B开始执行到扩容后：table[3]=(7,b)-&gt;(3,a)-&gt;null（先遍历到的是(3,a)键值对，先插入到新位置的也是(3,a)，随后遍历到(7,b)，(7,b)的新位置也在table[3]，因为使用的是头插法，所以在(3,a)前面）<br>然后线程A继续执行，计算到(3,a)新位置在table[3]，把(3,a)插入table[3]的链表，而此时table[3]=(7,b)-&gt;(3,a)-&gt;null，导致table[3]=(3,a)&lt;=&gt;(7,b)，这两个元素互相指向，在遍历table[3]位置的链表时就会进入死循环。</p><p>这篇博客：<a href="https://www.cnblogs.com/developer_chan/p/10450908.html" target="_blank" rel="noopener">https://www.cnblogs.com/developer_chan/p/10450908.html</a> 中的<code>1.1 扩容造成死循环分析过程</code>用图片讲解，可参考。</p><p>因为改用了尾插法，所以1.8避免了1.7的环形链表的问题。但是，1.8的红黑树还是会出现死循环的情况，只是没人像1.7一样给出具体的过程，仅仅做了实验，实验博客：<a href="https://blog.csdn.net/gs_albb/article/details/88091808" target="_blank" rel="noopener">https://blog.csdn.net/gs_albb/article/details/88091808</a> 。</p><h1 id="1-8的优化"><a href="#1-8的优化" class="headerlink" title="1.8的优化"></a>1.8的优化</h1><p>从源码来看，JDK1.8优化的主要是查询性能，因为1.8不会出现过长的链表（都转为红黑树了~），时间复杂度由链表的O(n)降低为红黑树的O(logn)。扩容方法resize优化了环形链表的问题，但性能看不出优化。先说简单的，计算新下标时，1.7直接用位运算得出新下标，1.8除了位运算还有加法运算，不会比1.7更快。然后，正如在<code>区别一</code>中所述，创建红黑树的时间复杂度比创建链表要大，所以1.8的resize性能肯定不会比1.7好。</p><h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><p>JDK1.7和1.8都是线程不安全的，其中一个原因是扩容时会导致死循环，另一个原因是put方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 数组为空（第一次put）</span></span><br><span class="line">n = (tab = resize()).length; <span class="comment">// 先扩容</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 两个线程同时到达这里，只有一个线程能put成功，导致另一个线程的数据丢失</span></span><br><span class="line">tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="HashTable的线程安全"><a href="#HashTable的线程安全" class="headerlink" title="HashTable的线程安全"></a>HashTable的线程安全</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean的生命周期</title>
      <link href="/2020/06/13/spring-bean-lifecycle/"/>
      <url>/2020/06/13/spring-bean-lifecycle/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文从源码（SpringBoot 2.3.0版本）入手，学习教材上所说的Bean的生命周期的4个阶段：</p><ol><li>Bean定义</li><li>Bean初始化</li><li>Bean的生存期</li><li>Bean的销毁</li></ol><p>其中，Bean初始化阶段涉及的内容较多，如依赖注入，BeanPostProcessor、Aware接口的调用，比较复杂，这里先给个结论。</p><p>Bean初始化过程中的生命周期：</p><ol><li>调用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()</li><li>Bean实例化(Instantiation)</li><li>调用InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()</li><li>完成Bean的依赖注入，如HelloController依赖注入HelloServiceImpl，注入HelloService时会触发HelloService Bean的定义、初始化，因此这是一个递归过程</li><li>调用BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</li><li>调用每个BeanPostProcessor.postProcessBeforeInitialization()，当BeanPostProcessor=ApplicationContextAwareProcessor时，调用ApplicationContextAware.setApplicationContext()</li><li>调用InitializingBean.afterPropertiesSet()</li><li>调用@Bean的init-method方法</li><li>调用每个BeanPostProcessor.postProcessAfterInitialization()</li></ol><h1 id="Bean定义"><a href="#Bean定义" class="headerlink" title="Bean定义"></a>Bean定义</h1><p>在SpringBoot启动时，根据<code>@ComponentScan</code>指定的包路径（默认是当前包及其子包）扫描，把Bean的定义保存到IoC容器中。</p><p>SpringBoot Web应用使用的IoC容器为<code>AnnotationConfigServletWebServerApplicationContext</code>，这个容器包含一个属性：DefaultListableBeanFactory。<code>DefaultListableBeanFactory</code>是<code>BeanFactory</code>的实现类之一，它的作用就是保存bean定义和实例化bean。</p><p>在启动类SpringApplication.run()方法中，先确定使用的IoC容器为<code>AnnotationConfigServletWebServerApplicationContext</code>，然后调用此容器的refresh()方法，对<code>DefaultListableBeanFactory</code>进行配置，将Bean定义添加到<code>DefaultListableBeanFactory</code>的<code>beanDefinitionMap</code>中。</p><p>下面是主要的一些源码展示，这些方法间的调用链可以debug查看。</p><p>SpringApplication.run()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 指定IoC容器为AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">context = createApplicationContext(); </span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line"><span class="comment">// 刷新容器，调用了AnnotationConfigServletWebServerApplicationContext.refresh()方法</span></span><br><span class="line">refreshContext(context);</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassPathBeanDefinitionScanner.doScan()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123; <span class="comment">// basePackages=启动类所在包</span></span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); <span class="comment">// 所有Bean类的定义，如HelloController、HelloServiceImpl</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">definitionHolder =</span><br><span class="line">AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">beanDefinitions.add(definitionHolder);</span><br><span class="line">registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry); <span class="comment">// 把Bean的定义添加到this.registry=DefaultListableBeanFactory中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultListableBeanFactory部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAutowireCapableBeanFactory</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ConfigurableListableBeanFactory</span>, <span class="title">BeanDefinitionRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line"><span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition); <span class="comment">//添加Bean定义到beanDefinitionMap</span></span><br><span class="line">List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">removeManualSingletonName(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Still in startup registration phase</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition); <span class="comment">//添加Bean定义到beanDefinitionMap</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">removeManualSingletonName(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步，IoC容器中只有Bean的定义，还没有Bean的实例化对象。</p><h1 id="Bean初始化"><a href="#Bean初始化" class="headerlink" title="Bean初始化"></a>Bean初始化</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Bean的初始化阶段的主要工作，就是实例化Bean再初始化Bean，初始化过程中就包含依赖注入。</p><p>默认配置的、单例且非懒加载的Bean，会在Bean定义步骤完成后立即初始化。</p><p>入口在IoC容器基类<code>AbstractApplicationContext.finishBeanFactoryInitialization()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单例且非懒加载的bean，beanFactory=DefaultListableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要工作的是<code>AbstractAutowireCapableBeanFactory.doCreateBean()</code>方法，这个类是<code>DefaultListableBeanFactory</code>的基类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// bean实例化</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 下面两行都是bean的初始化</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面介绍Bean初始化阶段的详细过程。</p><h2 id="Bean实例化-Instantiation"><a href="#Bean实例化-Instantiation" class="headerlink" title="Bean实例化(Instantiation)"></a>Bean实例化(Instantiation)</h2><p>在<code>AbstractAutowireCapableBeanFactory.doCreateBean()</code>方法中，<code>createBeanInstance()</code>方法负责Bean的实例化，实例化后的bean对象的属性还是空的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 用bean的构造器创建bean对象，放在instanceWrapper内，此时bean对象的属性还是空的</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean初始化-Initialization"><a href="#Bean初始化-Initialization" class="headerlink" title="Bean初始化(Initialization)"></a>Bean初始化(Initialization)</h2><p>在<code>AbstractAutowireCapableBeanFactory.doCreateBean()</code>方法中，<code>populateBean()</code>方法和<code>initializeBean()</code>方法完成Bean的属性赋值（包括依赖注入），和Bean的一些扩展接口的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 下面两行都是bean的初始化</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper); <span class="comment">// 属性赋值，包括依赖注入</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);<span class="comment">// 调用Bean的一些扩展接口，如BeanPostProcessor接口和Aware接口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>populateBean()</code>方法中完成依赖注入，如把personServiceImpl注入到personController中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 稍微提一下，这里的autowired是@Bean注解的autowired属性值，不是bean的依赖属性上的@Autowired注解</span></span><br><span class="line"><span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="comment">// InstantiationAwareBeanPostProcessor接口是BeanPostProcessor接口的子类，下面会介绍</span></span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 当bp=AutowiredAnnotationBeanPostProcessor时，这步会注入bean的依赖，如把personServiceImpl注入到personController中</span></span><br><span class="line"> <span class="comment">// 在初始化personServiceImpl这个bean时，会递归调用到上面的doCreateBean()方法，且会递归把personMapper注入到personServiceImpl中</span></span><br><span class="line"> <span class="comment">// 因此整个注入是一个递归调用的过程</span></span><br><span class="line">PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line">pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pvs = pvsToUse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上大致介绍了Bean的初始化阶段的主要工作，即实例化Bean再依赖注入。但在这个阶段，还涉及到<code>BeanPostProcessor</code>接口和<code>*Aware</code>接口的调用。下面介绍这两类接口的作用和调用时机。</p><h2 id="调用扩展接口"><a href="#调用扩展接口" class="headerlink" title="调用扩展接口"></a>调用扩展接口</h2><h3 id="BeanPostProcessor接口"><a href="#BeanPostProcessor接口" class="headerlink" title="BeanPostProcessor接口"></a>BeanPostProcessor接口</h3><p>BeanPostProcessor是Spring IOC容器给我们提供的一个扩展接口。接口声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在Bean的 InitializingBean.afterPropertiesSet()方法或<span class="doctag">@Bean</span>(init-method)属性定义的方法 执行前被调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在Bean的 InitializingBean.afterPropertiesSet()方法或<span class="doctag">@Bean</span>(init-method)属性定义的方法 执行后被调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了BeanPostProcessor接口的类，被扫描进IoC容器后，在所有Bean的初始化前后都会被调用，即它对所有Bean都生效，有点像AOP。它有个子接口<code>InstantiationAwareBeanPostProcessor</code>。</p><h4 id="InstantiationAwareBeanPostProcessor接口"><a href="#InstantiationAwareBeanPostProcessor接口" class="headerlink" title="InstantiationAwareBeanPostProcessor接口"></a>InstantiationAwareBeanPostProcessor接口</h4><p><code>InstantiationAwareBeanPostProcessor</code>接口继承自<code>BeanPostProcessor</code>接口，它不仅继承了<code>BeanPostProcessor</code>接口会在Bean<strong>初始化</strong>前后调用的两个方法，还增加了会在Bean<strong>实例化</strong>前后调用的两个方法。所以这两个方法也在Bean的生命周期内。具体的调用时机在下面介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bean实例化前调用</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bean实例化后调用</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Aware接口"><a href="#Aware接口" class="headerlink" title="Aware接口"></a>Aware接口</h3><p>Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源，Aware之前的名字就是可以拿到什么资源，例如BeanNameAware可以拿到BeanName，以此类推。<br>比较常见的Aware接口有BeanNameAware、BeanFactoryAware、ApplicationContextAware。</p><h4 id="ApplicationContextAware接口"><a href="#ApplicationContextAware接口" class="headerlink" title="ApplicationContextAware接口"></a>ApplicationContextAware接口</h4><p>ApplicationContextAware接口可以用来获取ApplicationContext，即IoC容器。我们已知<code>ApplicationContext</code>包含<code>BeanFactory</code>接口的getBean()方法，因此我们在服务中可以借助它直接获取Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在项目中，经常遇到要随时获取Bean的情况，这时就可以写一个工具类解决：ApplicationContextUtil。这个工具类就是使用了ApplicationContextAware接口的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.context = applicationContext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过name获取 Bean.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> context.getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过class获取Bean.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> context.getBean(clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过name,以及Clazz返回指定的Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> context.getBean(name, clazz);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们定义的这个Bean，ApplicationContextUtil，它的setApplicationContext()方法是在何时被调用的？答案在下面“调用时机”一节中。</p><h3 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h3><h4 id="BeanFactory注册BeanPostProcessor接口"><a href="#BeanFactory注册BeanPostProcessor接口" class="headerlink" title="BeanFactory注册BeanPostProcessor接口"></a>BeanFactory注册BeanPostProcessor接口</h4><p>在AnnotationConfigServletWebServerApplicationContext.refresh()方法中（在Bean定义阶段中有提到），会给要使用的BeanFactory=DefaultListableBeanFactory注册BeanPostProcessor接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">/*省略其他代码*/</span></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">// 这里会添加几个指定的BeanPostProcessor</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">// 这里会注册自定义的BeanPostProcessor</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用BeanPostProcessor和Aware接口方法"><a href="#调用BeanPostProcessor和Aware接口方法" class="headerlink" title="调用BeanPostProcessor和Aware接口方法"></a>调用BeanPostProcessor和Aware接口方法</h4><p>在Bean初始化阶段的initializeBean()方法中，顺序调用了BeanPostProcessor和Aware接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean); <span class="comment">// 调用Aware接口方法，见下方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 执行每个BeanPostProcessor的postProcessBeforeInitialization()方法</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);<span class="comment">// 调用afterPropertiesSet()和init-method方法，见下方</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 执行每个BeanPostProcessor的postProcessAfterInitialization()方法</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断bean是否实现了BeanNameAware等接口的方法，若实现就调用</span></span><br><span class="line"><span class="comment">// ApplicationContextAware接口的调用不在这里，后面介绍</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">ClassLoader bcl = getBeanClassLoader();</span><br><span class="line"><span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断bean是否实现了InitializingBean接口，若实现就调用afterPropertiesSet()，然后反射调用init-method()方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line"><span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="keyword">throw</span> pae.getException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">String initMethodName = mbd.getInitMethodName();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">!(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看到，每初始化一个Bean。就会遍历调用所有的BeanPostProcessor接口方法，即BeanPostProcessor接口方法对所有Bean都有效。而Aware接口是由Bean自己实现的，初始化某个Bean时，会调用Bean自己的Aware接口方法，因此Aware接口方法只针对一个Bean有效。</p><h4 id="ApplicationContextAware接口的调用"><a href="#ApplicationContextAware接口的调用" class="headerlink" title="ApplicationContextAware接口的调用"></a>ApplicationContextAware接口的调用</h4><p>ApplicationContextAware接口的调用点如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean); <span class="comment">// 这里没有调用ApplicationContextAware</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 这里调用了ApplicationContextAware</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在applyBeanPostProcessorsBeforeInitialization()方法中，会遍历执行BeanFactory的所有<code>BeanPostProcessor.postProcessBeforeInitialization()</code>方法，当遍历到<code>ApplicationContextAwareProcessor.postProcessBeforeInitialization()</code>方法时，它的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (acc != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">invokeAwareInterfaces(bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, acc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeAwareInterfaces(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext); <span class="comment">// 当bean实现了ApplicationContextAware，调用setApplicationContext()方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于这个<code>ApplicationContextAwareProcessor</code>是何时添加到BeanFactory的，答案在上面介绍的“BeanFactory注册BeanPostProcessor接口”的prepareBeanFactory()方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InstantiationAwareBeanPostProcessor接口的调用"><a href="#InstantiationAwareBeanPostProcessor接口的调用" class="headerlink" title="InstantiationAwareBeanPostProcessor接口的调用"></a>InstantiationAwareBeanPostProcessor接口的调用</h4><p>介绍<code>InstantiationAwareBeanPostProcessor</code>接口时，提到它扩展的两个方法：postProcessBeforeInstantiation()、postProcessAfterInstantiation()，分别在Bean<strong>实例化</strong>前后调用。具体的调用点如下。</p><p>postProcessBeforeInstantiation()的调用点在<code>AbstractAutowireCapableBeanFactory.createBean()</code>，在doCreateBean()方法之前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line"><span class="comment">// 这里是调用点，见下方</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 可以看到，它的调用点在doCreateBean()之前，说明此时还没有实例化bean</span></span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hasInstantiationAwareBeanPostProcessors=true时，执行postProcessBeforeInstantiation()方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">Object bean = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line"><span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>postProcessAfterInstantiation()的调用点，是我们熟悉的populateBean()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在populateBean()方法最前，此时bean已实例化但还未依赖注入</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line"><span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean初始化阶段总结"><a href="#Bean初始化阶段总结" class="headerlink" title="Bean初始化阶段总结"></a>Bean初始化阶段总结</h2><p>在Bean初始化过程中的生命周期是这样的：</p><ol start="0"><li>BeanFactory注册BeanPostProcessor接口</li><li>调用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()</li><li>createBeanInstance()进行Bean实例化</li><li>populateBean()<ol><li>调用InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()</li><li>调用AutowiredAnnotationBeanPostProcessor.postProcessProperties()，完成依赖注入，是一个递归过程</li></ol></li><li>initializeBean()<ol><li>调用BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</li><li>调用每个BeanPostProcessor.postProcessBeforeInitialization()，当BeanPostProcessor=ApplicationContextAwareProcessor时，调用ApplicationContextAware.setApplicationContext()</li><li>调用InitializingBean.afterPropertiesSet()</li><li>调用@Bean的init-method方法</li><li>调用每个BeanPostProcessor.postProcessAfterInitialization()</li></ol></li></ol><hr><p>可能有人会问，在Bean定义阶段使用的<code>DefaultListableBeanFactory</code>的成员变量<code>beanDefinitionMap</code>在Bean初始化阶段怎么没有出现？其实是出现了的。回顾<code>doCreateBean()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>第二个形参<code>RootBeanDefinition mbd</code>是从该方法的上上一层方法<code>AbstractBeanFactory.doGetBean()</code>传进来的：<br>【调用链是 AbstractBeanFactory.doGetBean() -&gt; AbstractAutowireCapableBeanFactory.createBean() -&gt; AbstractAutowireCapableBeanFactory.doCreateBean()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">createBean(beanName, mbd, args);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 其余略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>getMergedLocalBeanDefinition()</code>方法中，调用<code>DefaultListableBeanFactory.getBeanDefinition()</code>，从<code>beanDefinitionMap</code>中获得Bean定义信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedLocalBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">RootBeanDefinition mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; !mbd.stale) &#123;</span><br><span class="line"><span class="keyword">return</span> mbd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (bd == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"No bean named '"</span> + beanName + <span class="string">"' found in "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Bean的生存期"><a href="#Bean的生存期" class="headerlink" title="Bean的生存期"></a>Bean的生存期</h1><p>Bean的生存期就是SpringBoot程序启动后，我们使用Bean的过程，这里不介绍了。</p><h1 id="Bean的销毁"><a href="#Bean的销毁" class="headerlink" title="Bean的销毁"></a>Bean的销毁</h1><p>当 IoC 容器关闭时会对 Bean 进行销毁，此时会调用 Bean 的自定义销毁方法。</p><p><strong>注意：</strong>销毁方法内只做 Bean 销毁前要做的事，比如调用下 Bean 内成员的销毁方法，Bean 资源的释放还是由 JVM 完成。</p><h2 id="容器启动时记录定义了销毁方法的Bean"><a href="#容器启动时记录定义了销毁方法的Bean" class="headerlink" title="容器启动时记录定义了销毁方法的Bean"></a>容器启动时记录定义了销毁方法的Bean</h2><p>有以下3种方式来自定义 Bean 的销毁方法：</p><ol><li>实现 DisposableBean 接口</li><li>@Bean(destroyMethod=”xxx”)</li><li>@PreDestroy</li></ol><p>这3种方法的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"===================destroy person2 bean"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"===================destroy person bean"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person3</span> </span>&#123;</span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"===================destroy person3 bean"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它们注册为Bean的代码</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(destroyMethod = <span class="string">"destroy"</span>)</span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Person2 <span class="title">person2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Person3 <span class="title">person3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IoC容器启动时，在<code>AbstractAutowireCapableBeanFactory.doCreateBean()</code>方法中，完成当前 Bean 的初始化后（即调用完 initializeBean 方法后），会调用父类的<code>registerDisposableBeanIfNecessary</code>方法，判断当前 Bean 是否含自定义销毁方法，若有则记录在容器成员<code>Map&lt;String, Object&gt; disposableBeans</code>中。<br>这部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd); <span class="comment">// 调用父类方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDisposableBeanIfNecessary</span><span class="params">(String beanName, Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">       AccessControlContext acc = System.getSecurityManager() != <span class="keyword">null</span> ? <span class="keyword">this</span>.getAccessControlContext() : <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 当前Bean的作用域不是原型 且 this.requiresDestruction() = true</span></span><br><span class="line"><span class="comment">// 所以，作用域为原型的Bean，IoC容器不负责销毁</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isPrototype() &amp;&amp; <span class="keyword">this</span>.requiresDestruction(bean, mbd)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">// 单例Bean被包装成DisposableBeanAdapter添加到disposableBeans Map中</span></span><br><span class="line">               <span class="keyword">this</span>.registerDisposableBean(beanName, <span class="keyword">new</span> DisposableBeanAdapter(bean, beanName, mbd, <span class="keyword">this</span>.getBeanPostProcessors(), acc));</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               Scope scope = (Scope)<span class="keyword">this</span>.scopes.get(mbd.getScope());</span><br><span class="line">               <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + mbd.getScope() + <span class="string">"'"</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               scope.registerDestructionCallback(beanName, <span class="keyword">new</span> DisposableBeanAdapter(bean, beanName, mbd, <span class="keyword">this</span>.getBeanPostProcessors(), acc));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">requiresDestruction</span><span class="params">(Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> bean != <span class="keyword">null</span> &amp;&amp; (DisposableBeanAdapter.hasDestroyMethod(bean, mbd) || <span class="keyword">this</span>.hasDestructionAwareBeanPostProcessors() &amp;&amp; DisposableBeanAdapter.hasApplicableProcessors(bean, <span class="keyword">this</span>.getBeanPostProcessors()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>this.requiresDestruction() 方法就是用于判断一个 Bean 是否有自定义销毁方法，只要以下2个条件之一成立则返回 true：</p><ol><li>DisposableBeanAdapter.hasDestroyMethod() = true<ol><li>Bean 是否实现了 DisposableBean 或 AutoCloseable 接口；</li><li>若上条不符，那么是否指定 @Bean 注解的 destroyMethod 属性；</li><li>若上条不符，那么 Bean 类中是否有名为“close”或“shutdown”的方法。</li></ol></li><li>this.hasDestructionAwareBeanPostProcessors() &amp;&amp; DisposableBeanAdapter.hasApplicableProcessors() = true<br> 1.容器中的 beanPostProcessorList 中有<code>DestructionAwareBeanPostProcessor</code>类型的 Bean，且它对当前 Bean 适用。</li></ol><p>第二个条件中的 DestructionAwareBeanPostProcessor 接口继承自 BeanPostProcessor，扩展了2个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DestructionAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用bean自定义销毁方法前要做的事</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeforeDestruction</span><span class="params">(Object var1, String var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="comment">// 对形参中的bean是否有效【这个方法返回true，才会调用上一个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">requiresDestruction</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么容器中有 DestructionAwareBeanPostProcessor 类型的 Bean 吗？有！在容器 refresh 时，添加了一个<code>ApplicationListenerDetector</code>Bean，它只对 ApplicationListener Bean 适用；还有一个 <code>CommonAnnotationBeanPostProcessor</code>，它对使用了 @PreDestroy 注解的 Bean 适用。</p><p>所以，当 Bean 使用了3种方法中的任一种（也可以同时用）自定义销毁方法，this.requiresDestruction() 方法就会返回 true，这个 Bean 会被包装成<code>DisposableBeanAdapter</code>添加到容器的 disposableBeans Map 中。</p><h2 id="容器关闭时调用Bean的销毁方法"><a href="#容器关闭时调用Bean的销毁方法" class="headerlink" title="容器关闭时调用Bean的销毁方法"></a>容器关闭时调用Bean的销毁方法</h2><p>IoC 容器关闭时会对 Bean 进行销毁，此时会通过容器中的 BeanFactory 调用 Bean 的自定义销毁方法。</p><p><code>DefaultSingletonBeanRegistry.destroySingletons()</code>方法（DefaultSingletonBeanRegistry 是 DefaultListableBeanFactory 的间接基类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingletons</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">String[] disposableBeanNames;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>.disposableBeans) &#123;</span><br><span class="line">disposableBeanNames = StringUtils.toStringArray(<span class="keyword">this</span>.disposableBeans.keySet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历disposableBeanNames，一个一个调用destroySingleton方法【相当于遍历disposableBeans Map</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = disposableBeanNames.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">this</span>.destroySingleton(disposableBeanNames[i]); <span class="comment">// 见下方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.removeSingleton(beanName);</span><br><span class="line">DisposableBean disposableBean;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>.disposableBeans) &#123;</span><br><span class="line">disposableBean = (DisposableBean)<span class="keyword">this</span>.disposableBeans.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.destroyBean(beanName, disposableBean); <span class="comment">// 见下方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyBean</span><span class="params">(String beanName, @Nullable DisposableBean bean)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Trigger destruction of dependent beans first...</span></span><br><span class="line">Set&lt;String&gt; dependencies;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;</span><br><span class="line"><span class="comment">// Within full synchronization in order to guarantee a disconnected Set</span></span><br><span class="line">dependencies = <span class="keyword">this</span>.dependentBeanMap.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dependencies != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Retrieved dependent beans for bean '"</span> + beanName + <span class="string">"': "</span> + dependencies);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String dependentBeanName : dependencies) &#123;</span><br><span class="line">destroySingleton(dependentBeanName); <span class="comment">// 销毁bean依赖的bean</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually destroy the bean now...</span></span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">bean.destroy(); <span class="comment">// 调用自定义销毁方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Destruction of bean with name '"</span> + beanName + <span class="string">"' threw an exception"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面源码说明了销毁 Bean 的过程：遍历 disposableBeans Map，分别调用这些 Bean 的 destroy 方法完成销毁。从上一小节我们知道，disposableBeans Map 保存了所有含自定义销毁方法的 Bean，且这些 Bean 是被包装成 DisposableBeanAdapter 对象保存的，所以源码中调用<code>bean.destroy()</code>其实是调用<code>DisposableBeanAdapter.destroy()</code>。</p><p>在看 DisposableBeanAdapter.destroy() 方法之前，先看一下当初 Bean 是怎么被包装成 DisposableBeanAdapter 的。DisposableBeanAdapter 构造方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DisposableBeanAdapter</span><span class="params">(Object bean, String beanName, RootBeanDefinition beanDefinition, List&lt;BeanPostProcessor&gt; postProcessors, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">Assert.notNull(bean, <span class="string">"Disposable bean must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.bean = bean;</span><br><span class="line"><span class="keyword">this</span>.beanName = beanName;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">this</span>.invokeDisposableBean = <span class="keyword">this</span>.bean <span class="keyword">instanceof</span> DisposableBean &amp;&amp; !beanDefinition.isExternallyManagedDestroyMethod(<span class="string">"destroy"</span>);</span><br><span class="line"><span class="keyword">this</span>.nonPublicAccessAllowed = beanDefinition.isNonPublicAccessAllowed();</span><br><span class="line"><span class="keyword">this</span>.acc = acc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">String destroyMethodName = <span class="keyword">this</span>.inferDestroyMethodIfNecessary(bean, beanDefinition);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">if</span> (destroyMethodName != <span class="keyword">null</span> &amp;&amp; !(<span class="keyword">this</span>.invokeDisposableBean &amp;&amp; <span class="string">"destroy"</span>.equals(destroyMethodName)) &amp;&amp;</span><br><span class="line">!beanDefinition.isExternallyManagedDestroyMethod(destroyMethodName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.destroyMethodName = destroyMethodName;</span><br><span class="line"><span class="keyword">this</span>.destroyMethod = <span class="keyword">this</span>.determineDestroyMethod();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanDefinition.isEnforceDestroyMethod()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(<span class="string">"Couldn't find a destroy method named '"</span> + destroyMethodName + <span class="string">"' on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Class&lt;?&gt;[] paramTypes = <span class="keyword">this</span>.destroyMethod.getParameterTypes();</span><br><span class="line"><span class="keyword">if</span> (paramTypes.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(<span class="string">"Method '"</span> + destroyMethodName + <span class="string">"' of bean '"</span> + beanName + <span class="string">"' has more than one parameter - not supported as destroy method"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (paramTypes.length == <span class="number">1</span> &amp;&amp; Boolean.TYPE != paramTypes[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(<span class="string">"Method '"</span> + destroyMethodName + <span class="string">"' of bean '"</span> + beanName + <span class="string">"' has a non-boolean parameter - not supported as destroy method"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">this</span>.beanPostProcessors = <span class="keyword">this</span>.filterPostProcessors(postProcessors, bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释上面源码中标注的点：</p><ol><li>判断条件中<code>beanDefinition.isExternallyManagedDestroyMethod(&quot;destroy&quot;)</code>当使用了 @PreDestroy 注解且这个注解标注的方法名为”destroy”时为 true。这一行代码含义是，当 Bean 实现了 DisposableBean 接口且 destroy 方法未标注 @PreDestroy 时，this.invokeDisposableBean = true</li><li>this.inferDestroyMethodIfNecessary()方法中，若定义了@Bean 的 destroyMethod 属性则直接返回；若实现了 DisposableBean 接口则返回 null；若有名为”close”方法或”shutdown”方法，则返回”close”或”shutdown”，否则返回 null</li><li>这里if条件成立的场景是：(destroyMethodName != null) 且 (未实现 DisposableBean 或 实现了 DisposableBean 但 destroyMethodName!=”destory”) 且 destroyMethodName 方法未标注 @PreDestroy 注解</li><li>从容器中所有 beanPostProcessor 中筛选对当前 Bean 有效的</li></ol><p>从上面这几点还可以看出：</p><ol><li>若 @Bean(destroyMethod=”xxx”) 和 DisposableBean 同时用，且前者定义的销毁方法与后者不同（后者只能是 destory 方法），则这两者分别定义的销毁方法都会被调用</li><li>若 @Bean(destroyMethod=”xxx”) 和 @PreDestroy 同时用，且前者定义的销毁方法与后者不同，则这两者分别定义的销毁方法都会被调用</li><li>若 DisposableBean 和 @PreDestroy 同时用，且前者定义的销毁方法（只能是 destory 方法）与后者不同，则这两者分别定义的销毁方法都会被调用</li><li>若只使用了 @Bean 但未定义 destroyMethod 属性，则会自动取方法名为”close”或”shutdown”的方法作为销毁方法</li></ol><blockquote><p>这里使用了“适配器模式”，DisposableBeanAdapter 适配了自定义销毁方法的3种方式。</p></blockquote><p>倒回来看 DisposableBeanAdapter.destroy() 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="comment">// DisposableBeanAdapter本身也实现了DisposableBean接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历调用所有适合这个bean的DestructionAwareBeanPostProcessor，执行销毁前要做的事</span></span><br><span class="line"><span class="comment">// 如果是用@PreDestroy注解，那么这里会通过CommonAnnotationBeanPostProcessor调用到注解标注的方法</span></span><br><span class="line"><span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.beanPostProcessors)) &#123;</span><br><span class="line"><span class="keyword">for</span> (DestructionAwareBeanPostProcessor processor : <span class="keyword">this</span>.beanPostProcessors) &#123;</span><br><span class="line">processor.postProcessBeforeDestruction(<span class="keyword">this</span>.bean, <span class="keyword">this</span>.beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是实现了DisposableBean，则调用destroy方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Invoking destroy() on bean with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">((DisposableBean) bean).destroy();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, acc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">((DisposableBean) bean).destroy();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">String msg = <span class="string">"Invocation of destroy method failed on bean with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"'"</span>;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.warn(msg, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.warn(msg + <span class="string">": "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若使用@Bean(destroyMethod="xxx")，调用指定方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">Method methodToCall = determineDestroyMethod();</span><br><span class="line"><span class="keyword">if</span> (methodToCall != <span class="keyword">null</span>) &#123;</span><br><span class="line">invokeCustomDestroyMethod(methodToCall);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，无论使用哪一种方式自定义销毁方法，这个 Bean 会在容器启动时包装成 DisposableBeanAdapter。容器关闭时，调用 BeanFactory 方法：DefaultSingletonBeanRegistry.destroySingletons()，这个方法内再通过 DisposableBeanAdapter 执行自定义销毁方法。</p><hr><p>这里简单介绍下容器关闭的原理。</p><p>容器关闭时执行的方法是：<code>AbstractApplicationContext.doClose()</code>，就是在这个方法内调用了 DefaultSingletonBeanRegistry.destroySingletons() 方法，那么它是怎么被调用的？</p><p>IoC 容器关闭有2种情况，一个是主动调用容器的 close 方法，像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(BeanConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(context.getBean(HelloWorldController<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">context.close();<span class="comment">// IoC容器关闭，会调用AbstractApplicationContext.doClose()方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在一般项目中不会有这样的代码，所以第二种情况就是让 Spring 自动完成关闭容器的操作。Spring 怎么自己知道要关闭容器？</p><p>在<code>SpringApplication.refreshContext()</code>方法源码（如下）中可以看到，程序启动时，SpringApplication 调用完容器的 refresh 方法后，紧接着调用了容器的<code>registerShutdownHook</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.refresh(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registerShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            context.registerShutdownHook();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AccessControlException var3) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerShutdownHook 方法是接口 ConfigurableApplicationContext 定义的，由 AbstractApplicationContext（所有容器类的基类）实现。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.shutdownHook = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(AbstractApplicationContext.<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">                    AbstractApplicationContext.<span class="keyword">this</span>.doClose();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">this</span>.shutdownHook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的最后调用了 JDK 的一个方法：<code>Runtime.addShutDownHook(Thread hook)</code> ，作用是：注册一个 JVM 关闭的<strong>钩子方法</strong>。此处可以看出，这个“钩子方法”是一个线程，线程内调用了 AbstractApplicationContext.doClose() 方法 ，这个线程会在JVM <strong>正常关闭</strong>时被执行。</p><blockquote><p>什么是钩子方法？</p></blockquote><p>钩子方法是设计模式中的模板模式里用到的，它是由抽象类声明并且实现，实现内容一般是空的，子类可以选择是否扩展。钩子方法为你在实现某一个抽象类的时候提供了可选项，相当于预先提供了一个默认配置。</p><blockquote><p>JVM正常关闭的条件是？</p></blockquote><p>用”kill”命令而不是”kill -9”命令，在idea编辑器里点击”exit”按钮而不是”stop”按钮。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IoC原理</title>
      <link href="/2020/05/31/spring-ioc/"/>
      <url>/2020/05/31/spring-ioc/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring IoC是一种通过<strong>描述</strong>来生成或者获取对象的技术，和我们平时在需要时直接new一个对象是不一样的，它就是通过你给的针对对象的描述，如对象的名字或者类型，来生成这个对象（若已生成，就直接取）。在Spring中，这些被管理的对象叫作<code>Bean</code>。Spring会统一管理这些Bean，包括Bean之间的依赖关系，负责管理这些Bean的是<code>IoC容器</code>。</p><blockquote><p>IoC（控制反转）的意思就是，原本是我们自己控制对象，现在变成由Spring控制，我们需要对象的时候要从容器中取。</p></blockquote><p>文中出现的Spring源码都是SpringBoot 2.3.0版本。</p><h1 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h1><p>IoC容器，在程序中就是实现了<code>BeanFactory</code>接口的类。<code>BeanFactory</code>接口中提供了用name和requiredType获取Bean的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**其他方法和属性省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationContext</code>接口间接继承了<code>BeanFactory</code>接口，它包含<code>BeanFactory</code>接口的所有方法，还提供了额外功能，Spring将它作为默认的启动容器。</p><p>当我们用<code>SpringApplication.run(XXXApplication.class, args);</code>启动时，Spring就会根据依赖的jar包来指定要使用的IoC容器，看SpringApplication类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line"><span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line"><span class="keyword">case</span> SERVLET:</span><br><span class="line">contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> REACTIVE:</span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"Unable create a default ApplicationContext, please specify an ApplicationContextClass"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webApplicationType</code>的值由依赖的jar包决定，默认值是SERVLET，所以IoC容器一般是DEFAULT_SERVLET_WEB_CONTEXT_CLASS=<code>AnnotationConfigServletWebServerApplicationContext</code>，这个类间接实现了<code>ApplicationContext</code>接口。</p><h1 id="用注解装配Bean"><a href="#用注解装配Bean" class="headerlink" title="用注解装配Bean"></a>用注解装配Bean</h1><p>SpringBoot多是用注解把Bean装配到IoC容器中，但也可以使用XML配置文件来装配，这里只介绍注解的方式。</p><h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"><span class="comment">// 内容省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlMultipleDemoApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(MysqlMultipleDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类加上@Component注解后，在SpringBoot启动时，它就会被扫描进IoC容器，原因就是SpringBoot启动类的注解<code>@SpringBootApplication</code>里面包含了<code>@ComponentScan</code>注解，而<code>@ComponentScan</code>的作用就是扫描类当前包及其子包下的被<code>@Component</code>修饰的类。<code>@ComponentScan</code>也可以指定要扫描的包路径。<br>顺便一提，我们熟悉的@Controller、@Service，以及下面说到的@Configuration都包含了@Component注解，所以这些注解修饰的类都会被装配到IoC容器中。</p><h2 id="Configuration和-Bean组合"><a href="#Configuration和-Bean组合" class="headerlink" title="@Configuration和@Bean组合"></a>@Configuration和@Bean组合</h2><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">ApplicationContextUtil <span class="title">applicationContextUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ApplicationContextUtil();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就在IoC容器中生成了一个叫”applicationContextUtil”的Bean。Bean的名字可以在@Bean注解中指定，不指定就为方法名。在一个@Configuration类中，可以写多个@Bean。</p><h2 id="上面两种方法的区别"><a href="#上面两种方法的区别" class="headerlink" title="上面两种方法的区别"></a>上面两种方法的区别</h2><p>从效果上来说没有区别，都可以装配Bean。但后者有一个专门的使用场景，就是装配依赖jar包中的Bean。如上面的示例代码，若<code>ApplicationContextUtil</code>是依赖包中的类，不在自己程序中，就只能用@Configuration和@Bean装配。</p><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>类之间免不了有依赖关系，如我们经常在Service类中这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">personMapper.insertPerson(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就说明PersonServiceImpl类依赖PersonMapper类，但这个PersonMapper的实例对象不是我们自己new的，是通过@Autowired注解，让IoC容器为我们注入的，因此称之为<strong>“依赖注入”</strong>。</p><blockquote><p>这里有个疑问，PersonMapper一般是接口，无实现类，也没有@Component修饰，为什么会被装配到IoC容器中？<br>答案是，Mybatis为每个Mapper接口实现了一个动态代理类（即Mapper接口的实现类），这些动态代理类会被<code>MapperFactoryBean</code>保存起来。<code>MapperFactoryBean</code>作为接口类型被添加到IoC容器中，当需要依赖注入Mapper接口的Bean时，调用<code>MapperFactoryBean</code>的getObject()方法得到Mapper的代理类。<br>这其中的原理足够再写一篇文章，这里就不展开介绍，具体内容可以上网搜索“mapper接口依赖注入”。</p></blockquote><h2 id="Autowired和-Resource"><a href="#Autowired和-Resource" class="headerlink" title="@Autowired和@Resource"></a>@Autowired和@Resource</h2><p>@Autowired和@Resource两个注解的作用都是找到对应的Bean注入到依赖它的类中。区别是：</p><ol><li>@Autowired是Spring注解，@Resource是JDK注解</li><li>@Autowired先按类型注入，找不到再按名称注入，@Resource相反</li></ol><h2 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h2><h3 id="设值注入（set注入）"><a href="#设值注入（set注入）" class="headerlink" title="设值注入（set注入）"></a>设值注入（set注入）</h3><p>设值注入是指IoC容器通过set方法来注入被依赖对象。这种注入方式简单、直观。<br>把上面的PersonServiceImpl代码改为这样就是设值注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersonMapper</span><span class="params">(PersonMapper personMapper)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.personMapper = personMapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">personMapper.insertPerson(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><p>利用构造器来设置依赖对象的方式，被称为构造注入。通俗来说，就是驱动Spring在底层以反射方式执行带指定参数的构造器，当执行带参数的构造器时，就可利用构造器参数对成员变量执行初始化。<br>PersonServiceImpl代码改为这样就是构造注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PersonServiceImpl</span><span class="params">(@Autowired PersonMapper personMapper)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.personMapper = personMapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">personMapper.insertPerson(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Primary和-Quelifier"><a href="#Primary和-Quelifier" class="headerlink" title="@Primary和@Quelifier"></a>@Primary和@Quelifier</h2><p>这两个注解解决了一个问题：当@Autowired按类型寻找Bean，找到了多个符合条件的Bean时，应该注入哪一个？<br>举个例子，SpringBoot的官方给出的“在项目中配置多个数据源”的示例代码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.first"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">firstDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.first.configuration"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">firstDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstDataSourceProperties().initializeDataSourceBuilder().type(HikariDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.second"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">secondDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.second.configuration"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">secondDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> secondDataSourceProperties().initializeDataSourceBuilder().type(BasicDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了两个名字不同但类型相同的DataSourceProperties Bean，当有个Bean不指定名字地要求注入它依赖的DataSourceProperties对象，IoC容器就会优先注入被<code>@Primary</code>修饰的那个DataSourceProperties Bean。</p><p>当然我们更希望由自己决定注入哪一个Bean，这样更准确。这时就用<code>@Quelifier</code>注解指定要注入的Bean的名字。使用方法类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">ds1TransactionManager</span><span class="params">(@Qualifier(<span class="string">"firstDataSource"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h1><p>用<code>@Scope</code>注解可以指定Bean的作用域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig1</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="function">MyBean1 <span class="title">myBean1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyBean1 myBean1 = <span class="keyword">new</span> MyBean1();</span><br><span class="line">myBean1.setName(<span class="string">"hello1"</span>);</span><br><span class="line"><span class="keyword">return</span> myBean1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>@Scope</code>注解源码，可以看到它支持的作用域定义在<code>ConfigurableBeanFactory</code>和<code>WebApplicationContext</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scope &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"scopeName"</span>)</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specifies the name of the scope to use for the annotated component/bean.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Defaults to an empty string (&#123;<span class="doctag">@code</span> ""&#125;) which implies</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConfigurableBeanFactory#SCOPE_SINGLETON SCOPE_SINGLETON&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableBeanFactory#SCOPE_PROTOTYPE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableBeanFactory#SCOPE_SINGLETON</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.WebApplicationContext#SCOPE_SESSION</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line"><span class="function">String <span class="title">scopeName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ScopedProxyMode <span class="title">proxyMode</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ConfigurableBeanFactory</code>接口中，有两个作用域：单例和原型，它们在所有Spring IoC容器都可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableBeanFactory</span> <span class="keyword">extends</span> <span class="title">HierarchicalBeanFactory</span>, <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for the standard singleton scope: &#123;<span class="doctag">@value</span>&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Custom scopes can be added via &#123;<span class="doctag">@code</span> registerScope&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerScope</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_SINGLETON = <span class="string">"singleton"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for the standard prototype scope: &#123;<span class="doctag">@value</span>&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Custom scopes can be added via &#123;<span class="doctag">@code</span> registerScope&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerScope</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_PROTOTYPE = <span class="string">"prototype"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其他属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>WebApplicationContext</code>接口中，有三个作用域：request、session、application。它们只在实现了<code>WebApplicationContext</code>接口的容器中可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for request scope: "request".</span></span><br><span class="line"><span class="comment"> * Supported in addition to the standard scopes "singleton" and "prototype".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_REQUEST = <span class="string">"request"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for session scope: "session".</span></span><br><span class="line"><span class="comment"> * Supported in addition to the standard scopes "singleton" and "prototype".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_SESSION = <span class="string">"session"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for the global web application scope: "application".</span></span><br><span class="line"><span class="comment"> * Supported in addition to the standard scopes "singleton" and "prototype".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_APPLICATION = <span class="string">"application"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其他属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="request-session-application"><a href="#request-session-application" class="headerlink" title="request session application"></a>request session application</h2><p>单例和原型的含义大家都熟悉，这里先介绍下另外三个作用域。</p><ol><li>request: 在一次HTTP请求中，bean是单例的，再来一个HTTP请求就再实例化一个bean（容器中有保留一份bean定义，用bean定义实例化bean）。不同的HTTP请求的bean实例不同，自然也不会互相影响。HTTP请求结束bean实例就销毁</li><li>session: 和request作用于类似，但是范围是一次HTTP session</li><li>application: 在一个ServletContext中，bean是单例的。和singleton的区别是，singleton是指在一个IoC容器中bean是单例的。</li></ol><blockquote><p>ServletContext是什么？<br>一个Java Web应用都有一个ServletContext，这个应用里的所有servlet都可通过ServletContext获取初始化参数（web.xml中的<context-param>节点定义的配置）、文件路径等等，同时servlet之间还可通过ServletContext.set/getAttribute()修改和访问共有的属性。ServletContext是servlet之间，以及项目容器（如Tomcat）和WEB项目之间的桥梁。</p></blockquote><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式是一个很出名的设计模式，常见的是懒汉式和饿汉式，但Spring采用的是登记式，且Spring允许你设置是否用懒加载（默认不用）。<br>饿汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式（线程安全）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登记式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放beanName和bean实例的map，就像bean的登记表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; registry = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Object object = registry.get(<span class="string">"singleton"</span>);</span><br><span class="line"><span class="keyword">if</span>(object == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registry.put(<span class="string">"singleton"</span>, <span class="keyword">new</span> Singleton());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">object = registry.get(<span class="string">"singleton"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (Singleton) object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这种方式的好处在于，不要求单例类的构造方法是private。因此尽管我们的controller、service未声明private构造方法，在Spring中依然可以是单例。</p><h3 id="Spring单例模式的实现"><a href="#Spring单例模式的实现" class="headerlink" title="Spring单例模式的实现"></a>Spring单例模式的实现</h3><p>Spring中的单例的概念是，在一个IoC容器中，一个Bean定义只有一个实例。上面说到Spring的单例模式是登记式，有一个bean的“登记表”，保存beanName和bean实例，当登记表中不存在bean实例，就立即创建一个并“登记”，若已有bean实例就直接返回。</p><p>“登记表”的接口<code>SingletonBeanRegistry</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the given existing object as singleton in the bean registry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the (raw) singleton object registered under the given name.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Object <span class="title">getSingleton</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其他方法，没有属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“登记表”的接口实现类<code>DefaultSingletonBeanRegistry</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面3个Map都是用于缓存</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登记表</span></span><br><span class="line"><span class="comment">/** Set of registered singletons, containing the bean names in registration order. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">Assert.notNull(singletonObject, <span class="string">"Singleton object must not be null"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">Object oldObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (oldObject != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not register object ["</span> + singletonObject +</span><br><span class="line"><span class="string">"] under bean name '"</span> + beanName + <span class="string">"': there is already object ["</span> + oldObject + <span class="string">"] bound"</span>);</span><br><span class="line">&#125;</span><br><span class="line">addSingleton(beanName, singletonObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);<span class="comment">// 加入缓存</span></span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.registeredSingletons.add(beanName); <span class="comment">// 登记</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getSingleton方法1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);<span class="comment">// 从缓存中取</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject(); <span class="comment">// 有工厂就用工厂实例化</span></span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);<span class="comment">// 加入缓存</span></span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getSingleton方法2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName); <span class="comment">// 从缓存中取</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line"><span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line"><span class="string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">beforeSingletonCreation(beanName);</span><br><span class="line"><span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject(); <span class="comment">// 从第二个参数取</span></span><br><span class="line">newSingleton = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line"><span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">ex.addRelatedCause(suppressedException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">afterSingletonCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">addSingleton(beanName, singletonObject); <span class="comment">// 加入缓存并登记</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 其他属性和方法省略 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，bean实例是何时被注册的？在IoC容器启动，和程序中使用ApplicationContext.getBean()方法时。</p><p>IoC容器启动时，调用入口在IoC容器基类<code>AbstractApplicationContext.finishBeanFactoryInitialization()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单例且非懒加载的bean，beanFactory=DefaultListableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中使用ApplicationContext.getBean()方法时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">assertBeanFactoryActive();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个调用点，都会进入到AbstractBeanFactory.doGetBean()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName); <span class="comment">//调用getSingleton方法1</span></span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">//调用getSingleton方法2，后一个参数是createBean()方法返回的bean实例（且已初始化）</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可对比看下原型作用域，就是一次getBean就会调用createBean()方法返回bean实例（且已初始化）</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring为什么默认单例模式"><a href="#Spring为什么默认单例模式" class="headerlink" title="Spring为什么默认单例模式"></a>Spring为什么默认单例模式</h3><p><strong>单例bean的优势：</strong></p><ol><li>减少了新生成实例的消耗。新生成实例消耗包括两方面，第一spring会通过反射或者cglib来生成bean实例，这都是耗性能的操作，第二给对象分配内存也会涉及复杂算法</li><li>减少jvm垃圾回收。由于不会给每个请求都新生成bean实例，所以自然回收的对象少了</li><li>可以快速获取到bean。因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的，所以很快</li></ol><p><strong>单例bean的劣势：</strong><br>单例的bean一个很大的劣势就是他不能做到线程安全。下面详细说明。</p><h3 id="单例模式的线程安全问题"><a href="#单例模式的线程安全问题" class="headerlink" title="单例模式的线程安全问题"></a>单例模式的线程安全问题</h3><ol><li>线程安全问题都是由单例bean的成员变量及静态变量引起的</li><li>若每个线程中对成员变量、静态变量只有读操作，而无写操作，那么不存在线程安全问题；若有写操作，就存在线程安全问题</li><li>成员变量、静态变量的线程安全问题是因为成员变量在堆中，静态变量在方法区中，堆和方法区是线程共享的（局部变量在栈中，是线程私有的）</li><li>当多个线程调用方法时会不会出现线程安全问题呢？答案是不会，方法存在虚拟机栈中，是线程私有的</li></ol><p>这也是为什么我们声明的bean，如controller、service，基本上不含除了依赖bean以外的成员变量，也不会去修改成员变量值。</p><p>如果一定要在单例bean中使用会被修改的成员变量，可以在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中。</p><blockquote><p>ThreadLocal是线程局部变量，所谓的线程局部变量，就是仅仅只能被本线程访问，不能在线程之间进行共享访问的变量。</p></blockquote><p>举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法只能访问本线程内的sqlSession</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</span><br><span class="line">Session s = (Session) threadSession.get();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">s = getSessionFactory().openSession();</span><br><span class="line">threadSession.set(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上ThreadLocal的普通用法。在一个线程中，controller经常要传参给service，如果固定要传某个参数，方法形参的声明会很臃肿，所以可以把一些必须要传的参数写到ThreadLocal中。<br>举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusiUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal_logindex = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLogIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> threadLocal_logindex.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLogIndex</span><span class="params">(String logIndex)</span> </span>&#123;</span><br><span class="line">threadLocal_logindex.set(logIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeLogIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">threadLocal_logindex.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在controller中调用BusiUtil.setLogIndex("123456789")</span></span><br><span class="line"><span class="comment">// 在service中调用BusiUtil.getLogIndex()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot配置数据源</title>
      <link href="/2020/05/30/springboot-datasource-config/"/>
      <url>/2020/05/30/springboot-datasource-config/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为工作项目的新需求涉及到在SpringBoot中配置多个MySQL数据库，为了理解如何配置，学习了SpringBoot自动配置数据源的原理，在此记录。这篇文章先介绍SpringBoot配置单个数据源的原理，再介绍多个数据源的配置方法。</p><h1 id="SpringBoot配置单个数据源"><a href="#SpringBoot配置单个数据源" class="headerlink" title="SpringBoot配置单个数据源"></a>SpringBoot配置单个数据源</h1><h2 id="未指定spring-datasource-type时，SpringBoot的默认数据源"><a href="#未指定spring-datasource-type时，SpringBoot的默认数据源" class="headerlink" title="未指定spring.datasource.type时，SpringBoot的默认数据源"></a>未指定spring.datasource.type时，SpringBoot的默认数据源</h2><p>以下面application.yml为例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server.port:</span> <span class="number">18081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span> </span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>执行Junit Test看下SpringBoot使用的默认数据源是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MysqlDemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dataSource: "</span> + dataSource.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在未指定spring.datasource.type的情况下，SpringBoot会使用默认数据源，在1.X版本中，默认数据源是org.apache.tomcat.jdbc.pool.DataSource；在2.X版本中，默认数据源是com.zaxxer.hikari.HikariDataSource。</p><blockquote><p>以下源码版本都是SpringBoot 2.3.0</p></blockquote><p>SpringBoot是怎么指定数据源的？道理在<code>DataSourceConfiguration</code>这个类，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createDataSource</span><span class="params">(DataSourceProperties properties, Class&lt;? extends DataSource&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (T) properties.initializeDataSourceBuilder().type(type).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tomcat Pool DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(org.apache.tomcat.jdbc.pool.DataSource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">DataSource</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.type"</span>, havingValue = <span class="string">"org.apache.tomcat.jdbc.pool.DataSource"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.tomcat"</span>)</span><br><span class="line">org.apache.tomcat.jdbc.pool.<span class="function">DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">org.apache.tomcat.jdbc.pool.DataSource dataSource = createDataSource(properties,</span><br><span class="line">org.apache.tomcat.jdbc.pool.DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">DatabaseDriver databaseDriver = DatabaseDriver.fromJdbcUrl(properties.determineUrl());</span><br><span class="line">String validationQuery = databaseDriver.getValidationQuery();</span><br><span class="line"><span class="keyword">if</span> (validationQuery != <span class="keyword">null</span>) &#123;</span><br><span class="line">dataSource.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">dataSource.setValidationQuery(validationQuery);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hikari DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(HikariDataSource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">DataSource</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.type"</span>, havingValue = <span class="string">"com.zaxxer.hikari.HikariDataSource"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hikari</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.hikari"</span>)</span><br><span class="line"><span class="function">HikariDataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">HikariDataSource dataSource = createDataSource(properties, HikariDataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(properties.getName())) &#123;</span><br><span class="line">dataSource.setPoolName(properties.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DBCP DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(org.apache.commons.dbcp2.BasicDataSource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">DataSource</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.type"</span>, havingValue = <span class="string">"org.apache.commons.dbcp2.BasicDataSource"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dbcp2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.dbcp2"</span>)</span><br><span class="line">org.apache.commons.dbcp2.<span class="function">BasicDataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> createDataSource(properties, org.apache.commons.dbcp2.BasicDataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generic DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(DataSource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.type"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前三个内部类Tomcat、Hikari、Dbcp2上的注解：</p><ol><li>@Configuration(proxyBeanMethods = false)：会装配Bean的配置类</li><li>@ConditionalOnClass(XXX.class)：给定的XXX.class在系统中存在时，就实例化当前Bean</li><li>@ConditionalOnMissingBean(DataSource.class)：若IOC容器中还不存在DataSource这个Bean，就在IOC容器中实例化DataSource Bean</li><li>@ConditionalOnProperty(name = “spring.datasource.type”, havingValue = “XXX”,matchIfMissing = true)：配置中，是否有<code>spring.datasource.type=XXX</code>的配置。<code>matchIfMissing = true</code>表示，即使没有指定配置，该配置类也生效</li></ol><p>因此，以Tomcat类为例，这些注解表示，若系统存在<code>org.apache.tomcat.jdbc.pool.DataSource.class</code>，即使没有配置<code>spring.datasource.type=org.apache.tomcat.jdbc.pool.DataSource</code>，也是使用<code>org.apache.tomcat.jdbc.pool.DataSource</code>作为数据源。</p><p>当我们指定了spring.datasource.type时，就使最后一个类Generic生效，它会初始化spring.datasource.type配置项指定的数据源。</p><blockquote><p>PS：为什么1.X和2.X两个版本默认的数据源不同？<br>因为在<code>spring-boot-start-jdbc 1.X</code>中，默认引入依赖<code>tomcat-jdbc</code>；而在<code>spring-boot-start-jdbc 2.X</code>中，默认引入依赖<code>HikariCP</code></p></blockquote><h2 id="指定spring-datasource-type，使用Druid数据源"><a href="#指定spring-datasource-type，使用Druid数据源" class="headerlink" title="指定spring.datasource.type，使用Druid数据源"></a>指定spring.datasource.type，使用Druid数据源</h2><p>application.yml更新为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server.port:</span> <span class="number">18081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span> </span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>再执行上面的Junit Test，可以看到dataSource换成了com.alibaba.druid.pool.DruidDataSource。这个就是由上面的<code>DataSourceConfiguration</code>类下的<code>Generic</code>初始化的。</p><h2 id="配置Druid数据库连接池参数并使其生效"><a href="#配置Druid数据库连接池参数并使其生效" class="headerlink" title="配置Druid数据库连接池参数并使其生效"></a>配置Druid数据库连接池参数并使其生效</h2><p>application.yml更新为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">filters:</span> <span class="string">stat</span></span><br><span class="line">    <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">initialSize:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">minIdle:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">    <span class="attr">validationQuery:</span> <span class="string">select</span> <span class="string">'x'</span></span><br><span class="line">    <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">maxOpenPreparedStatements:</span> <span class="number">20</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">server.port:</span> <span class="number">18081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span> </span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>但是，通过运行下面的Junit Test，我们可以看到，数据库连接池的属性如maxActive并没有生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MysqlDemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dataSource: "</span> + dataSource.getClass());</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(<span class="string">"connection: "</span> + connection);</span><br><span class="line">        <span class="keyword">if</span>(dataSource <span class="keyword">instanceof</span> DruidDataSource) &#123;</span><br><span class="line">        DruidDataSource dDataSource = (DruidDataSource) dataSource;</span><br><span class="line">        System.out.println(<span class="string">"maxActive: "</span> + dDataSource.getMaxActive());</span><br><span class="line">        System.out.println(<span class="string">"minIdle: "</span> + dDataSource.getMinIdle());</span><br><span class="line">        &#125;</span><br><span class="line">        connection.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们配置的是maxActive=20，minIdle=1，打印出来的是maxActive=8，minIdle=0。<br>什么原因呢？我们先看上面那个<code>DataSourceConfiguration</code>类下的<code>Generic</code>的方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>DataSourceProperties</code>类的源码，它用注解<code>@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</code>把”spring.datasource”下的属性映射到自己的同名属性中了，但在这个类中，和我们配置项同名的只有url、username、password、driver-class-name、type这5个属性，并没有maxActive这样的数据库连接池属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProperties</span> <span class="keyword">implements</span> <span class="title">BeanClassLoaderAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fully qualified name of the connection pool implementation to use. By default, it</span></span><br><span class="line"><span class="comment"> * is auto-detected from the classpath.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? extends DataSource&gt; type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String driverClassName;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC URL of the database.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Login username of the database.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Login password of the database.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*省略其他属性*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize a &#123;<span class="doctag">@link</span> DataSourceBuilder&#125; with the state of this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> DataSourceBuilder&#125; initialized with the customizations defined on</span></span><br><span class="line"><span class="comment"> * this instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> DataSourceBuilder&lt;?&gt; initializeDataSourceBuilder() &#123;</span><br><span class="line"><span class="keyword">return</span> DataSourceBuilder.create(getClassLoader()).type(getType()).driverClassName(determineDriverClassName())</span><br><span class="line">.url(determineUrl()).username(determineUsername()).password(determinePassword());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*省略其他方法*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@ConfigurationProperties(prefix=”spring.datasource”)注解表示把”spring.datasource”下的属性映射到实体类的同名属性上。具体可以上网搜索<code>@ConfigurationProperties</code>的原理。</p></blockquote><p>再查看<code>DataSourceBuilder</code>类build()方法源码，可以看到这里只是反射调用DruidDataSource()构造函数，建立DruidDataSource对象，没有给这个对象属性赋值。DruidDataSource中的maxActive属性是有默认值的，这个默认值就是我们打印出的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Class&lt;? extends DataSource&gt; type = getType();</span><br><span class="line">DataSource result = BeanUtils.instantiateClass(type);</span><br><span class="line">maybeGetDriverClassName();</span><br><span class="line">bind(result);</span><br><span class="line"><span class="keyword">return</span> (T) result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么怎样让我们的配置生效呢？SpringBoot的官方文档给了我们三种方法。<br>新建一个配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  第一种</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  第二种</span></span><br><span class="line"><span class="comment">//@Bean</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties("spring.datasource")</span></span><br><span class="line"><span class="comment">//public DataSource dataSource() &#123;</span></span><br><span class="line"><span class="comment">//    return DataSourceBuilder.create().type(DruidDataSource.class).build();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  第三种</span></span><br><span class="line"><span class="comment">//@Bean</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties(prefix = "spring.datasource")</span></span><br><span class="line"><span class="comment">//public DataSource dataSource(</span></span><br><span class="line"><span class="comment">//DataSourceProperties properties) &#123;</span></span><br><span class="line"><span class="comment">//return properties.initializeDataSourceBuilder().type(DruidDataSource.class).build();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种方法都能使我们的配置生效。第二种和第三种方法的里面就是反射调用DruidDataSource()构造函数。因为<code>@ConfigurationProperties</code>注解的作用，我们的配置属性被映射到了DruidDataSource对象属性上，即使DruidDataSource是通过反射建立的也会生效。</p><p>关于第三种方法，若我们的url、username、password、driver-class-name、type五个配置和别的数据库连接池配置是分开的，例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">druid:</span> </span><br><span class="line">  <span class="attr">filters:</span> <span class="string">stat</span></span><br><span class="line">  <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">initialSize:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxWait:</span> <span class="number">60000</span></span><br></pre></td></tr></table></figure><p>第三种方法就应该这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">dataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"druid"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> properties.initializeDataSourceBuilder().type(DruidDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因就是，”spring.datasource.*“属性只映射到<code>DataSourceProperties</code>对象，properties反射创建DruidDataSource对象后，”druid.*“属性才映射到DruidDataSource对象。</p><h1 id="SpringBoot-Mybatis配置多个数据源"><a href="#SpringBoot-Mybatis配置多个数据源" class="headerlink" title="SpringBoot+Mybatis配置多个数据源"></a>SpringBoot+Mybatis配置多个数据源</h1><p>这里指的是配置多个Mysql数据源。<br>配置文件application.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">db1:</span> </span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">db2:</span> </span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test2?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">filters:</span> <span class="string">stat</span></span><br><span class="line">    <span class="attr">minIdle:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">initialSize:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span>  </span><br><span class="line">    <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">3000000</span></span><br><span class="line">    <span class="attr">validationQuery:</span> <span class="string">select</span> <span class="string">'x'</span>  </span><br><span class="line">    <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">maxOpenPreparedStatements:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>理解了配置单个数据源的方法后，很容易写出多个数据源的配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.db1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">ds1DataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">ds1DataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ds1DataSourceProperties().initializeDataSourceBuilder().type(DruidDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.db2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">ds2DataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">ds2DataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ds2DataSourceProperties().initializeDataSourceBuilder().type(DruidDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用Junit Test验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MysqlMultipleDemoApplicationTests</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Object ds1DataSource = ApplicationContextUtil.getBean(<span class="string">"ds1DataSource"</span>);</span><br><span class="line"><span class="keyword">if</span>(ds1DataSource <span class="keyword">instanceof</span> DruidDataSource) &#123;</span><br><span class="line">DruidDataSource ds = (DruidDataSource) ds1DataSource;</span><br><span class="line">System.out.println(ds.getUrl());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object ds2DataSource = ApplicationContextUtil.getBean(<span class="string">"ds2DataSource"</span>);</span><br><span class="line"><span class="keyword">if</span>(ds2DataSource <span class="keyword">instanceof</span> DruidDataSource) &#123;</span><br><span class="line">DruidDataSource ds = (DruidDataSource) ds2DataSource;</span><br><span class="line">System.out.println(ds.getUrl());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的内容与我们的配置相对应。</p><p>如果是用JdbcTemplate，给不同的JdbcTemplate指定不同的数据源即可。但现在项目多是用Mybatis，有多个数据源存在时，需要把mapper.xml和mapper.java文件与数据源对应起来。<br>新建两个数据库的Mybatis配置类：<br>1.MybatisConfigDB1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// basePackages为要扫描的mapper.java所在包</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages =<span class="string">"com.example.demo.mysql.multiple.dao.test"</span>, sqlSessionTemplateRef  = <span class="string">"ds1SqlSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfigDB1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主数据源 ds1数据源</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"ds1SqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">ds1SqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"ds1DataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSessionFactoryBean sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactory.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactory.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().</span><br><span class="line">                        getResources(<span class="string">"classpath:mapper/test/*.xml"</span>));<span class="comment">// mapper.xml目录</span></span><br><span class="line">        sqlSessionFactory.setTypeAliasesPackage(<span class="string">"com.example.demo.mysql.multiple.domain.test"</span>);<span class="comment">//实体类所在包，用于生成实体类别名</span></span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ds1TransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">ds1TransactionManager</span><span class="params">(@Qualifier(<span class="string">"ds1DataSource"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ds1SqlSessionTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">ds1SqlSessionTemplate</span><span class="params">(@Qualifier(<span class="string">"ds1SqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.MybatisConfigDB2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages =<span class="string">"com.example.demo.mysql.multiple.dao.test2"</span>, sqlSessionTemplateRef  = <span class="string">"ds2SqlSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfigDB2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ds2数据源</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"ds2SqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">ds1SqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"ds2DataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSessionFactoryBean sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactory.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactory.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().</span><br><span class="line">                        getResources(<span class="string">"classpath:mapper/test2/*.xml"</span>));  </span><br><span class="line">        sqlSessionFactory.setTypeAliasesPackage(<span class="string">"com.example.demo.mysql.multiple.domain.test2"</span>);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ds2TransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">ds1TransactionManager</span><span class="params">(@Qualifier(<span class="string">"ds2DataSource"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ds2SqlSessionTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">ds1SqlSessionTemplate</span><span class="params">(@Qualifier(<span class="string">"ds2SqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以自己写个Junit Test验证，看每个数据源下的mapper.java和mapper.xml是否有效。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> 实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL笔记</title>
      <link href="/2020/05/16/mysql-note/"/>
      <url>/2020/05/16/mysql-note/</url>
      
        <content type="html"><![CDATA[<h1 id="CHAR和VARCHAR的区别"><a href="#CHAR和VARCHAR的区别" class="headerlink" title="CHAR和VARCHAR的区别"></a>CHAR和VARCHAR的区别</h1><ol><li>CHAR(m)所占字节数都是m个字节，这表示CHAR(m)是固定长度；VARCHAR(m)所占字节数是实际长度+1个字节</li><li>VARCHAR多出的一个字节是用来保存实际长度值</li><li>因为CHAR无论存储的数据长度本身是多少，都会占用固定的长度，因此存储空间会有一定的浪费；VARCHAR由于是可变长度，更节约存储空间</li><li>VARCHAR的缺点是影响性能，若UPDATE后VARCHAR列的字符串长度变长了，就需要重新分配存储空间</li><li>对于InnoDB引擎，VARCHAR的性能影响可以忽略，具体见下面存储引擎的介绍 ———</li></ol><h1 id="DATETIME和TIMESTAMP的区别"><a href="#DATETIME和TIMESTAMP的区别" class="headerlink" title="DATETIME和TIMESTAMP的区别"></a>DATETIME和TIMESTAMP的区别</h1><ol><li>TIMESTAMP类型的字段在insert和update时可指定更新为当前时间</li><li>TIMESTAMP类型显示的时间与系统时间所处的时区有关。例如，系统时间设为东八区时，显示的值为’2018-05-24 14:59:59’；系统时间设为东九区时，显示的值为’2018-05-24 15:59:59’<br>DATETIME类型只显示插入时的时间，即显示的时间不考虑时区变化</li><li>TIMESTAMP表示的日期范围比DATETIME要短得多</li></ol><h1 id="时间类型DATETIME直接相减的结果"><a href="#时间类型DATETIME直接相减的结果" class="headerlink" title="时间类型DATETIME直接相减的结果"></a>时间类型DATETIME直接相减的结果</h1><p>如语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  create_time, update_time, update_time-create_time <span class="keyword">as</span> pay_time <span class="keyword">from</span> t_order;</span><br></pre></td></tr></table></figure><p>这样写是错的！<br>因为，mysql在时间相减时，做了个转换，但不是UNIX_TIMESTAMP(create_time)这样的转换，而是把DATETIME直接转成了整数，如create_time=’2020-05-15 08:55:25’转成了20200515085525，因此得到的是两个无意义的整数相减的结果。<br>因此，对于时间类型的相减，正确处理应该是 UNIX_TIMESTAMP(update_time)-UNIX_TIMESTAMP(create_time)</p><h2 id="HAVING和WHERE的不同使用场景"><a href="#HAVING和WHERE的不同使用场景" class="headerlink" title="HAVING和WHERE的不同使用场景"></a>HAVING和WHERE的不同使用场景</h2><p>WHERE 就用在普通的SELECT语句作为查询条件，而 HAVING 用在聚合函数的字段上。如语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> currency_type, <span class="keyword">sum</span>(amount) <span class="keyword">as</span> total_amount <span class="keyword">from</span> t_order <span class="keyword">where</span> merchant_id=<span class="string">'123456'</span> <span class="keyword">group</span> <span class="keyword">by</span> currency_type <span class="keyword">having</span> total_amount&gt;<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h1><ul><li><p>UNIX_TIMESTAMP() 返回秒数，也可以带上时间。示例：<br>SELECT UNIX_TIMESTAMP(‘2020-06-16’); == 1592265600<br>SELECT UNIX_TIMESTAMP(‘2020-06-16 02:00:00’); == 1592272800</p></li><li><p>FROM_UNIXTIME() 输入秒数返回日期字符串，日期格式可指定<br>SELECT FROM_UNIXTIME(1592265600); == 2020-06-16 00:00:00<br>SELECT FROM_UNIXTIME(1592265600, ‘%Y-%m-%d’); == 2020-06-16</p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务的四要素ACID的含义是：</p><ul><li>原子性（Atomicity）：要么全部完成，要么全部不完成</li><li>一致性（Consistency）：一个事务单元需要提交之后才会被其他事务可见</li><li>隔离性（Isolation）：并发事务之间不会互相影响，设立了不同程度的<strong>隔离级别</strong>，通过适度的破坏一致性，得以提高性能</li><li>持久性（Durability）：事务提交后即持久化到磁盘不会丢失</li></ul><p>其中，隔离级别包括：</p><ul><li>读未提交（Read Uncommitted）：可以读取未提交的记录，会出现脏读，幻读，不可重复读，所有并发问题都可能遇到</li><li>读已提交（Read Committed）：事务中只能看到已提交的修改，不会出现脏读现象，但是会出现幻读，不可重复读（大多数数据库的默认隔离级别都是 RC，但是MySQL InnoDb默认是 RR）</li><li>可重复读（Repeatable Read）：MySQL InnoDb 默认的隔离级别，解决了不可重复读问题，但是仍然存在幻读问题</li><li>序列化（Serializable）：最高隔离级别，啥并发问题都没有</li></ul><p>MySQL对事务的处理默认是“自动提交模式”。当你用<code>SHOW GLOBAL VARIABLES LIKE &#39;%autocommit%&#39;</code>可以查看autocommit开关是否打开，默认是打开的。这意味着，MySQL会在每条SQL执行完后自动提交事务，即一条SQL就是一个事务。</p><p>当你需要让多条SQL在一个事务中，需要先把autocommit开关关闭，再用SQL关键字：BEGIN、COMMIT、ROLLBACK手动开始、提交、回滚事务。需要注意，只有InnoDB引擎的表才支持事务，即在事务中只能操作InnoDB表。</p><p>和数据库有关的几个理论缩写：ACID、CAP、BASE。他们的区别可以看这篇博客：<a href="https://www.cnblogs.com/minikobe/p/11137256.html" target="_blank" rel="noopener">https://www.cnblogs.com/minikobe/p/11137256.html</a> 。总的来说，ACID不考虑数据库是否是分布式的，都要求强一致性。CAP和BASE考虑的是分布式数据库在一致性问题上的取舍。</p><h2 id="相关博客"><a href="#相关博客" class="headerlink" title="相关博客"></a>相关博客</h2><p>事务与隔离级别：<a href="https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html" target="_blank" rel="noopener">https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html</a></p><p>菜鸟教程，手动处理事务的SQL：<a href="https://www.runoob.com/mysql/mysql-transaction.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-transaction.html</a></p><p>ACID、CAP、BASE的介绍：<a href="https://www.cnblogs.com/minikobe/p/11137256.html" target="_blank" rel="noopener">https://www.cnblogs.com/minikobe/p/11137256.html</a></p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>关系数据库表是用于存储和组织信息的数据结构。我们在实际开发过程中，可能需要各种各样的表，如查询快且少更新的表、经常更新的表。表的用途上的区别，就是对数据处理上的区别。对于MySQL来说，它提供了很多种类型的存储引擎，我们可以根据对数据处理的需求，选择不同的存储引擎，从而最大限度的利用MySQL强大的功能。</p><p>MySQL存储引擎包括：InnoDB、CSV、MyISAM、MEMORY等等。使用<code>SHOW ENGINES</code>命令可以查看你的Mysql支持的所有存储引擎。</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>特点：</p><ul><li>支持行级锁（也支持表级锁）</li><li>支持事务</li><li>支持外键（MySQL支持事务和外键的存储引擎只有InnoDB）</li><li>支持AUTO_INCREMENT列</li><li>数据和索引放在同一个文件<br>创建InnoDB表时，在”MYSQL_HOME/data/db_name”文件夹下，新增2个文件：<br>table_name.frm -&gt; 存储表定义<br>table_name.ibd -&gt; 存储数据和索引</li><li>使用聚集索引，因此表中一定有主键ID。若用户未指定，InnoDB会自动指定。聚集索引在“索引”一节介绍</li></ul><p>应用场景：</p><ul><li>要求事务安全</li></ul><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>特点：</p><ul><li>只支持表级锁</li><li>不支持事务和外键</li><li>支持AUTO_INCREMENT列</li><li>数据和索引分开放在两个文件<br>创建MyISAM表时，在”MYSQL_HOME/data/db_name”文件夹下，新增3个文件：<br>table_name.frm -&gt; 存储表定义<br>table_name.MYD -&gt; 存储数据<br>table_name.MYI -&gt; 存储索引</li><li>支持3种表：静态表、动态表、压缩表<ul><li>静态表：记录都是固定长度，存储非常迅速，容易缓存，出现故障容易恢复；但是占用的空间比较多。PS：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。</li><li>动态表：记录不是固定长度的，占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能</li><li>压缩表：因为每个记录是被单独压缩的，所以只有非常小的访问开支</li></ul></li><li>不使用聚集索引，因此表中可以没有主键ID</li></ul><p>应用场景：</p><ul><li>不要求事务安全</li><li>不经常UPDATE的表。这与“MyISAM的锁机制”有关</li></ul><blockquote><p>要对比两者的SELECT、INSERT效率,需要先了解它们在锁机制和索引上的区别。</p></blockquote><h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><p>锁的分类：</p><ul><li>表级锁：保证同一时刻只有一个线程操作<strong>该表</strong>，避免冲突<ul><li>读锁：也叫共享锁（S锁）。不拒绝其他对<strong>同张表</strong>的读请求，会拒绝对<strong>同张表</strong>的写请求。持有该锁的线程只能进行读操作</li><li>写锁：也叫排它锁（X锁）。拒绝对<strong>同张表</strong>的所有请求。持有该锁的线程可以进行读、写操作</li></ul></li><li>行级锁：保证同一时刻只有一个线程操作<strong>该记录</strong>，避免冲突<ul><li>读锁：也叫共享锁（S锁）。不拒绝其他对<strong>同条记录</strong>的读请求，会拒绝对<strong>同条记录</strong>的写请求。持有该锁的线程只能进行读操作</li><li>写锁：也叫排它锁（X锁）。拒绝对<strong>同条记录</strong>的所有请求。持有该锁的线程可以进行读、写操作</li></ul></li></ul><p>总之，在同一级中，读锁与写锁互斥，不能同时存在。写锁与其他写锁互斥，读锁与其他读锁兼容。读锁不阻碍读请求，阻碍写请求。写锁阻碍所有读写请求。</p><h2 id="MyISAM的锁机制"><a href="#MyISAM的锁机制" class="headerlink" title="MyISAM的锁机制"></a>MyISAM的锁机制</h2><p>MyISAM只支持表级锁。</p><p>什么时候锁：</p><ul><li>执行SELECT前，会自动给所有涉及到的表加读锁</li><li>执行INSERT、UPDATE、DELETE前，会自动给所有涉及到的表加写锁</li></ul><p>锁调度：</p><ul><li>线程到来时，该表已经被锁的话，锁会放入锁等待队列中</li><li>写锁优先。同时有两个线程对同一张表分别请求读锁与写锁，先加写锁。在锁等待队列中，即使读锁请求时间更早，写锁也会放到读锁之前（用户可以修改这个规则）</li></ul><blockquote><p>因为经常性的UPDATE会不断请求表写锁，写锁优先，会导致SELECT操作阻塞，所以MyISAM表不适合经常UPDATE。</p></blockquote><p>MyISAM不会出现死锁，原因：因为MyISAM总是一次性获得所需的全部锁，例如SELECT两张表时要求一次性获得这两张表的读锁，不能全部获得就等待，直到可以全部获得为止。（可对比下面的“InnoDB为什么会出现死锁”）</p><h2 id="InnoDB的锁机制"><a href="#InnoDB的锁机制" class="headerlink" title="InnoDB的锁机制"></a>InnoDB的锁机制</h2><p>InnoDB支持行级锁、表级锁。但InnoDB的表级锁属于<strong>意向锁</strong>，和MyISAM的表级锁有点不同。</p><p>什么时候锁：</p><ul><li>行读锁：SELECT语句显式加行读锁(SELECT … LOCK IN SHARE MODE)（普通SELECT语句不会加任何锁）</li><li>行写锁：执行INSERT、UPDATE、DELETE前，会自动给所有涉及到的行加行写锁；SELECT语句显式加行写锁(SELECT … FOR UPDATE)</li><li>表读锁：也叫意向共享锁（IS锁）。给行加行读锁前，先加表读锁</li><li>表写锁：也叫意向排他锁（IX锁）。给行加行写锁前，先加表写锁</li></ul><p>总之，一个事务要查询某一行，不需要任何锁；一个事务要修改某一行，需要行写锁+表写锁。</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>行锁这个名字听起来像是这个锁加在某个数据行上，实际上在InnoDB中，行锁是加在索引上的。</p><p>这意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁（非意向锁）！</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>意向锁的含义是，MySQL察觉到事务有意向对表中的某条记录加读锁/写锁，就给整张表加个表锁。但这个表锁的兼容性和MyISAM的表级锁不同。</p><h4 id="意向锁的兼容性"><a href="#意向锁的兼容性" class="headerlink" title="意向锁的兼容性"></a>意向锁的兼容性</h4><ol><li>意向锁之间：<ol><li>IS和IS兼容</li><li>IS和IX兼容</li><li>IX和IX兼容</li></ol></li><li>意向锁IX、IS和<strong>行级</strong>S锁、X锁之间：全部互相兼容！</li><li>意向锁IX、IS和<strong>表级</strong>S锁、X锁之间：<ol><li>IS和S兼容</li><li>IS和X互斥</li><li>IX和S互斥</li><li>IX和X互斥</li></ol></li></ol><p>这里所说的不同种类的锁兼容的含义是，一张表可以同时加上这些互相兼容的锁。例如“IS和IX兼容”是指，一张表中可以同时存在多个IS锁和多个IX锁。</p><h3 id="意向锁的作用"><a href="#意向锁的作用" class="headerlink" title="意向锁的作用"></a>意向锁的作用</h3><p>第一，在没有意向锁存在的情况下，当事务A准备给t_order表加表读锁（非意向锁）时，需要确认：</p><ol><li>当前表没有被加表写锁</li><li>当前表中没有记录被加行写锁</li></ol><p>为了确认第2点，事务A需要检查每一行记录的锁，效率很低。有了意向锁之后，事务A准备给t_order表加表读锁（非意向锁）时，只需要确认：</p><ol><li>当前表没有被加IX锁</li></ol><p>若确认当前表存在IX锁，事务A就能得知当前表中一定存在行写锁，就不需要检查每行记录，只需等待IX锁释放就行。</p><p>第二，意向锁之间的互相兼容，可以提高并发性能，也能保证并发环境下的事务隔离。举个例子，<br>事务A执行SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>此时t_order表存在两把锁：表上的IX锁、id=1的记录上的X锁。</p><p>事务B执行SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>因为IX锁可以兼容，所以事务B也可以给t_order表加上IX锁，再因为id=10的记录上不存在X锁，所以事务B不需要等事务A释放锁。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>InnoDB为什么会发生死锁？</p><p>在InnoDB中，锁是<strong>逐步获得</strong>的，这就决定了在InnoDB中发生死锁是可能的。</p><p>举例，下面这句SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> score = <span class="number">100</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>这一条SQL就是一个事务，这条SQL会更新满足条件的多条记录。找到第一条记录时，会给第一条记录上锁，第一条记录更新完成后，找到第二条记录并加锁，第二条更新完成再给第三条加锁，以此类推。</p><p>若这句SQL和上面那句同时开始：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> score = <span class="number">100</span> <span class="keyword">where</span> age &gt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>假设第一条SQL的加锁顺序：id = 15 -&gt; 18 -&gt; 20，第二条SQL的加锁顺序（age为普通索引，所以会用行锁）：(age, id) = (24, 18) -&gt; (24, 20) -&gt; (25, 15) -&gt; (25, 49)。其中，对 id 的加锁顺序为 id = 18 -&gt; 20 -&gt; 15 -&gt; 49。可以看到事务A先锁15，再锁18，而事务B先锁18，再锁15，从而形成死锁。</p><h2 id="推荐博客"><a href="#推荐博客" class="headerlink" title="推荐博客"></a>推荐博客</h2><p>常见的锁类型，还介绍了索引结构：<a href="https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html" target="_blank" rel="noopener">https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html</a></p><p>意向锁的作用：<a href="https://juejin.im/post/5b85124f5188253010326360" target="_blank" rel="noopener">https://juejin.im/post/5b85124f5188253010326360</a></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引就好比一本书的目录，它会让你更快的找到内容。但目录（索引）并不是越多越好，假如这本书1000页，有500页是目录，它当然效率低，目录是要占纸张的，而索引是要占磁盘空间的。</p><p>索引用于快速找出在某个列中有一特定值的行。如果不使用索引，MySQL必须从第1条记录开始然后读完整个表直到找出相关的行。表越大，花费的时间越多。如果表中查询的列有一个索引，MySQL能快速到达一个位置去搜寻数据文件的中间，没有必要看所有数据。（这里的原理见下面B+TREE索引的介绍）</p><p>索引是帮助MySQL高效获取数据的<strong>数据结构</strong>。</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul><li>普通索引：最基本的索引，没有任何限制</li><li>唯一索引（约束）：与”普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。可指定多个列构成一个唯一索引</li><li>主键索引（约束）：它是一种特殊的唯一索引，不允许有空值</li><li>全文索引：仅可用于MyISAM表，针对较大的数据，生成全文索引很耗时间和空间</li><li>组合索引：遵循“最左”原则。创建组合索引时应该将最常用作查询条件的列放在最左边，依次递减</li></ul><h2 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h2><p><strong>单列索引：</strong><br>    SELECT UPDATE DELETE语句中WHERE条件带上索引列<br>    SELECT语句的ORDER BY/GROUP BY带上索引列</p><p><strong>组合索引：</strong><br>    SELECT UPDATE DELETE语句中WHERE条件中一定要包含最左边的索引列</p><p><strong>注意：</strong></p><ol><li>若where条件中用到索引，则order by不会再用索引</li><li>order by不使用普通索引和组合索引</li><li>模糊查询中，若查询条件这样写：… where name like ‘%cai%’，则不会用到索引（原因是%放在最前）</li><li>mysql认为全文扫描比使用索引快时，即使where条件有索引也不会用索引，例如：在一张共100条记录的表中select前90条记录<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_order <span class="keyword">where</span> <span class="keyword">id</span>&lt;=<span class="number">90</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h2><p>B+Tree是BTree的变种，MySQL的BTree索引就使用它来作为数据结构。MyISAM表、InnoDB表的索引就是用B+Tree存储，一个索引就是一个B+Tree。在B+Tree中，非叶子节点只保存key与指针，叶子节点的两个域分别是key与data。</p><h3 id="MyISAM的B-Tree索引"><a href="#MyISAM的B-Tree索引" class="headerlink" title="MyISAM的B+Tree索引"></a>MyISAM的B+Tree索引</h3><p>在MyISAM的B+Tree中，叶子节点的data域存放的是<strong>数据记录的地址</strong>，这是因为MyISAM的索引和数据是分两个文件存放的。</p><p>下面是MyISAM索引的原理图。</p><p>主键索引（key为主键列值）：</p><img src="/2020/05/16/mysql-note/myisam_primary_key.png" class="" title="MyISAM主键索引"><p>普通索引（key为普通索引列值）：</p><img src="/2020/05/16/mysql-note/myisam_key.png" class="" title="MyISAM普通索引"><p>MyISAM的主键索引和普通索引在结构上没有任何区别，只是主键索引要求key是唯一的，而普通索引的key可以重复。<br>因此，MyISAM中索引检索的算法是：首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><h3 id="InnoDB的B-Tree索引"><a href="#InnoDB的B-Tree索引" class="headerlink" title="InnoDB的B+Tree索引"></a>InnoDB的B+Tree索引</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p>第一，MyISAM的data域仅保存数据记录的地址。而InnoDB的数据和索引存放在一个文件里，数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了<strong>完整的数据记录</strong>，key是主键列值。</p><img src="/2020/05/16/mysql-note/innodb_primary_key.png" class="" title="InnoDB主键索引"><p>这种索引就叫<strong>聚集索引</strong>，即数据和主键聚在一起。正因为InnoDB的数据文件要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>第二，InnoDB的普通索引data域存储相应记录主键的值而不是地址</p><img src="/2020/05/16/mysql-note/innodb_key.png" class="" title="InnoDB普通索引"><p>这样导致使用普通索引搜索需要检索两遍索引：首先检索普通索引获得主键，然后用主键到主索引中检索获得记录。</p><p>知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整（如主键最大是id=500，现在要插入id=400），十分低效，而使用自增字段作为主键则是一个很好的选择。另外，若使用int型字段做主键，InnoDB也会强制要求该字段设置AUTO_INCREMENT。</p><h1 id="MyISAN和InnoDB的对比"><a href="#MyISAN和InnoDB的对比" class="headerlink" title="MyISAN和InnoDB的对比"></a>MyISAN和InnoDB的对比</h1><p>在介绍MyISAM时说了它的INSERT效率高，一个原因是它不像InnoDB要检查外键约束，还要维护事务，减少了一部分开销。另一个原因是，B+Tree结构在插入新记录时要分裂调整，但MyISAM的data域存的是数据的物理地址，和InnoDB的data域就是记录相比，内容较小，分裂调整的速度更快。但是，MyISAM的INSERT效率不一定就比InnoDB高，一个是因为MyISAM的表锁，一个是因为InnoDB如果使用自增主键，B+Tree的调整就不会那么麻烦。</p><blockquote><p>什么是页？<br>“页”是指存储引擎从磁盘读取数据时，每次可以读取多少数据。换个说法，存储引擎每次从磁盘中读取一整页的数据，这“一整页的数据”有多少。为什么一次读取可以读到多条数据？这是因为B+Tree的一个叶子节点上就有多条数据，所以当查找到这个叶子节点时，就可以把这个叶子节点上的所有数据一次性读出来。</p></blockquote><blockquote><p>InnoDB插入数据会进行什么分裂调整？<br>因为InnoDB的数据位置是按照主键的顺序安排的，主键相近的，数据会在一个叶子节点上。若主键不是规律自增的，就会在插入时要B+Tree重新调整主键位置，即调整了数据的位置，原本靠在一起的数据也许会被分开。靠在一起的数据在一个叶子节点上，即在一个“页”上，所以这就导致了“页”的分裂。而如果主键自增，那么每次插入都是在B+Tree的最后新增数据，不会改变前面数据的位置，不用进行页分裂。</p></blockquote><p>另外，在查询效率上，也不能确定MyISAM和InnoDB谁更高，只能说各自都有优势。MyISAM的主键索引和普通索引的data域都是数据的物理地址，而InnoDB用普通索引检索时要搜两遍索引。但是，MyISAM和InnoDB的缓存机制不同，MyISAM只缓存索引，InnoDB缓存索引和数据。因此，MyISAM每次查找就要从磁盘里拿数据，而InnoDB首先从内存里获取数据，如果没有再到磁盘里拿。InnoDB内存里的数据不是一下子就缓存。InnoDB在一次IO读取中，就会把这个节点上的所有数据缓存，若下次查找的数据还在这个节点上，就可以直接从缓存中取了。如果InnoDB内存足够大，查询足够多，InnoDB速率可能会超过MyISAM。</p><p>再者，如果InnoDB用主键进行范围查找，效率是很高的，因为它相近的数据都因为主键的原因在一个“页”上，这就是聚集索引，而MyISAM的主键不是聚集索引，数据的物理地址并不会靠在一起。</p><p>但是，需要注意的是，InnoDB查找时用到了索引，才会加行锁，否则是加表锁。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法谜题》笔记</title>
      <link href="/2020/05/16/algorithmic-puzzles-note/"/>
      <url>/2020/05/16/algorithmic-puzzles-note/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　《算法谜题》中的题目，主要目的在于训练一种思维方式。这篇博客就是整理这本书中一些我认为有意思的题目。</p><h1 id="三阶幻方"><a href="#三阶幻方" class="headerlink" title="三阶幻方"></a>三阶幻方</h1><p>将1~9这9个不同的数字填入3x3的幻方，使得每行、每列、每条对角线的和相等。</p><h2 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h2><p>第一个格子可填9个数，第二个格子可填8个数，第三个格子可填7个数，以此类推，产生的可能解有9!（9的阶乘）个。对于n阶幻方，可能解数量是 (n^2)! 个。</p><h2 id="缩小范围的解法"><a href="#缩小范围的解法" class="headerlink" title="缩小范围的解法"></a>缩小范围的解法</h2><p>按以下步骤进行：</p><ol><li>这个每行、每列、每条对角线的和（称为幻和）等于15：1加到9的总和为45，3行，每行和为15</li><li>中间格子应该填5：经过中间格子的有4条线（横竖2条，斜的2条），这4条线上数字总和=15*4=45+中间格*3=15*3+中间格*3，即15=中间格*3，因此中间格=5</li><li>4组数字对(1,9) (2,8) (3,7) (4,6)，2条对角线上应该填偶数对(2,8) (4,6)：因为幻和15为奇数，所以在不经过中间格的4条线上的数字组合必须为2个偶数+1个奇数（2奇+1偶=偶），只有当对角线上都是偶数时才满足这个条件</li></ol><p>按照以上步骤，就可以得到三阶幻方的一种答案，其他答案就是由这个答案镜面翻转得到（三阶幻方一共有8个答案）。</p><h2 id="楼梯法"><a href="#楼梯法" class="headerlink" title="楼梯法"></a>楼梯法</h2><p>世界上已经有很多构造奇数阶幻方的方法了，如楼梯法、杨辉法，其中楼梯法比较适合写程序（楼梯法的介绍可以上网查）。<br>下面是实现构造k阶奇数幻方的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSquareOdd</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[][] sq = <span class="keyword">new</span> <span class="keyword">int</span>[k][k];</span><br><span class="line"><span class="comment">// 第一个数填在第一行中间</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>; <span class="comment">// 行</span></span><br><span class="line"><span class="keyword">int</span> y = k / <span class="number">2</span>; <span class="comment">// 列</span></span><br><span class="line"><span class="keyword">int</span> total = k * k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= total; i++) &#123; <span class="comment">// 按照顺序填数</span></span><br><span class="line">sq[x][y] = i;</span><br><span class="line"><span class="comment">// 下一个数填在当前位置的右上格子</span></span><br><span class="line"><span class="keyword">int</span> nextX = (x - <span class="number">1</span> + k) % k; <span class="comment">// 行-1</span></span><br><span class="line"><span class="keyword">int</span> nextY = (y + <span class="number">1</span>) % k; <span class="comment">// 列+1</span></span><br><span class="line"><span class="keyword">if</span> (sq[nextX][nextY] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 右上格子已经有数字，则填在当前位置的下一格（行+1，列不变）</span></span><br><span class="line">x = (x + <span class="number">1</span>) % k;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x = nextX;</span><br><span class="line">y = nextY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; k; n++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">System.out.print(sq[n][m] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h1><p>将n个皇后放置在n*n的国际象棋棋盘上，其中没有任何两个皇后处于同一行、同一列、同一对角线上。</p><h2 id="穷举法-1"><a href="#穷举法-1" class="headerlink" title="穷举法"></a>穷举法</h2><p>组合公式，从n个对象中选k个对象，不考虑k个对象的排列顺序：C(n,k)<br>穷举法要考虑的所有可能解的个数，即从n*n个格子中选出n个格子的组合个数C(n^2,n)。当n=4时，C(16,4)=1820，因此用穷举法解4皇后问题需要遍历1820个组合。</p><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>回溯法是对穷举法的一种改进，它采用走一步添加一个组件的方式，同时评估这一步中添加的组件是否符合题目要求，若不符合就返回上一步（回溯），从上一步重新开始考虑其他走法，若上一步往下的所有路都走不通，则再往上回溯；若符合就从这一步继续往下走，直到得出答案。<br>因此，回溯法需要遍历的可能解的数量会比穷举法少，当n=4时，考虑皇后必须放置在不同行和不同列，即第1个皇后有4种放法，第2个有3种，以此类推，可能解的数量为4!=24。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">// 存储每行放置的列的位置，如 result[0]=1 表示放在第一行第二列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">findColumn(r); <span class="comment">// 递归方法，因为要回溯，所以想到用递归实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 因为是按照每行来填，所以检查时只考虑前几行的放置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line"><span class="comment">// 和当前位置同列 || 和当前位置同一对角线</span></span><br><span class="line"><span class="keyword">if</span> ((result[i] == c) || (Math.abs(r - i) == Math.abs(c - result[i]))) &#123;</span><br><span class="line">System.out.println(<span class="string">"当前坐标：("</span> + r + <span class="string">","</span> + c + <span class="string">")和已有位置("</span> + i + <span class="string">","</span> + result[i] + <span class="string">")冲突"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findColumn</span><span class="params">(<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r == n) &#123; <span class="comment">// 每行都放完了，打印这条路的解,这条路结束</span></span><br><span class="line"><span class="comment">// print</span></span><br><span class="line">System.out.println(<span class="string">"result: "</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">System.out.println(result[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"----------------------"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++) &#123; <span class="comment">// 列</span></span><br><span class="line">System.out.println(<span class="string">"当前坐标：("</span> + r + <span class="string">","</span> + c + <span class="string">")"</span>);</span><br><span class="line"><span class="keyword">if</span> (isValid(r, c)) &#123;</span><br><span class="line">System.out.println(<span class="string">"当前坐标：("</span> + r + <span class="string">","</span> + c + <span class="string">")填1"</span>);</span><br><span class="line">result[r] = c;</span><br><span class="line">findColumn(r + <span class="number">1</span>);<span class="comment">// 寻找下一行的列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码时间复杂度为O(n^n)，即n的n次方，因为有n次递归，每次递归中遍历n列。空间复杂度为O(n)，因为用到了result[n]数组。</p><h3 id="位运算改进版实现"><a href="#位运算改进版实现" class="headerlink" title="位运算改进版实现"></a>位运算改进版实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">4</span>; <span class="comment">// n皇后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 解的总数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">find(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> row</span></span><br><span class="line"><span class="comment"> *            标记每列已占用的位置，已占用为1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ld</span></span><br><span class="line"><span class="comment"> *            标记左对角线上不能放的位置，不能放为1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rd</span></span><br><span class="line"><span class="comment"> *            标记右对角线上不能放的位置，不能放为1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> ld, <span class="keyword">int</span> rd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos, p;</span><br><span class="line"><span class="keyword">int</span> all1 = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; <span class="comment">// 1左移n位再减0001，得到n个1组成的二进制数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (row != all1) &#123;</span><br><span class="line"><span class="comment">// row，ld，rd进行“或”运算，求得所有可以放置皇后的列,对应位为0</span></span><br><span class="line"><span class="comment">// 然后取反后“与”上全1的数，来求得当前所有可以放置皇后的位置，对应列改为1</span></span><br><span class="line">pos = all1 &amp; (~(row | ld | rd));</span><br><span class="line">System.out.println(<span class="string">"可放的位置："</span> + Integer.toBinaryString(pos));</span><br><span class="line"><span class="keyword">while</span> (pos != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// pos取反+1 &amp; pos 得到pos中最右边的1</span></span><br><span class="line">p = pos &amp; (~pos + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// pos去掉最右列（最右列已占用）</span></span><br><span class="line">pos = pos - p;</span><br><span class="line"><span class="comment">// rowp 下一行已占用的列</span></span><br><span class="line"><span class="comment">// (ld|p)&lt;&lt;1 下一行不能放的列（因为左对角线被占用）</span></span><br><span class="line"><span class="comment">// (rd|p)&gt;&gt;1 下一行不能放的列（因为右对角线被占用）</span></span><br><span class="line">find(row | p, (ld | p) &lt;&lt; <span class="number">1</span>, (rd | p) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 每列都放了</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="n-gt-3时的通用解法"><a href="#n-gt-3时的通用解法" class="headerlink" title="n&gt;3时的通用解法"></a>n&gt;3时的通用解法</h2><p>因为n=1有一个解，n=2和n=3无解，所以只研究n&gt;3的通用解法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot AOP 实践与原理</title>
      <link href="/2020/03/02/springboot-aop/"/>
      <url>/2020/03/02/springboot-aop/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客先从AOP的代码编写讲起，接着介绍AOP的实现原理，其中包括动态代理的概念，最后介绍Spring中可以直接用的AOP注解。</p><h1 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h1><h2 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建切面类"><a href="#创建切面类" class="headerlink" title="创建切面类"></a>创建切面类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//声明这是一个组件</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//声明这是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义切入点"><a href="#定义切入点" class="headerlink" title="定义切入点"></a>定义切入点</h2><p>切入点就是你要在哪个包下的哪个类的哪个方法执行切面逻辑，或者说指定切入哪里。<strong>Spring AOP的切入点只能是方法。</strong><br>可以在一个切面类中定义多个切入点，再给每个切入点指定不同的Advice方法（Advice方法介绍见下一节）。<br>定义切入点有两种方式：</p><ol><li>用execution表达式定义切入点</li><li>用自定义注解定义切入点</li></ol><h3 id="用execution表达式定义切入点"><a href="#用execution表达式定义切入点" class="headerlink" title="用execution表达式定义切入点"></a>用execution表达式定义切入点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.sample.service.impl..*.*(..)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例表示在com.sample.service.impl包（含子包）下的所有类的所有方法切入。下面把这个示例拆解看看execution表达式的格式。</p><table><thead><tr><th align="left">符号</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">第一个”*”符号</td><td align="left">表示返回值的类型任意</td></tr><tr><td align="left">com.sample.service.impl</td><td align="left">要切入的类所在包名</td></tr><tr><td align="left">包名后面的”..”</td><td align="left">表示当前包及子包</td></tr><tr><td align="left">第二个”*“符号</td><td align="left">表示类名，*即任意类，也可指定具体的类，或带前后缀的类，如 *Service</td></tr><tr><td align="left">.*(..)</td><td align="left">表示任何方法名，括号表示参数，两个点表示任何参数类型</td></tr></tbody></table><p>如何使用这个切入点？示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)<span class="comment">// 这个注解以及它所修饰的方法的介绍见下一节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要同时指定<strong>多个切入点</strong>，用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut1() || pointcut2()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用自定义注解定义切入点"><a href="#用自定义注解定义切入点" class="headerlink" title="用自定义注解定义切入点"></a>用自定义注解定义切入点</h3><p>假设已有自定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME )</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义切入点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.example.demo.aop.Log)"</span>) <span class="comment">// 自定义注解的限定类名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例表示切入所有加了<code>@Log</code>属性的方法，比如下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"><span class="meta">@Log</span>(<span class="string">"添加用户操作"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user/add"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"add"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个切入点的方法和用“execution表达式”定义的切入点没有区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)<span class="comment">// 这个注解以及它所修饰的方法的介绍见下一节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这只是“自定义注解”定义的切入点的其中一种使用方式，这种使用方式的一个缺点是不能访问自定义注解<code>@Log</code>的value属性。<br>另一种使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(log)"</span>) <span class="comment">// 括号里的名字和注解参数名必须相同</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint, Log log)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 方法逻辑...</span></span><br><span class="line">     System.out.println(log.value()); <span class="comment">// 可以访问注解属性值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种使用方式的区别就是，切入点直接写在<code>@Before</code>注解中，不需要再用pointcut()方法定义切入点</p><p>和execution表达式相比，用自定义注解定义切入点，可以灵活安排切入的方法（想切哪里注解就加在哪里），且通过自定义注解的属性，在切面类中也能了解到被切方法的业务逻辑，若要在切面类中统一打印被切方法的日志，这点很好用。</p><h2 id="根据业务逻辑编写Advice方法"><a href="#根据业务逻辑编写Advice方法" class="headerlink" title="根据业务逻辑编写Advice方法"></a>根据业务逻辑编写Advice方法</h2><p>Advice，有翻译为“增强处理”，也有翻译为“通知”，本质含义就是要执行的切面逻辑，如要在每个方法开始前打印入参日志，就可以编写Before类型的Advice方法，如要在每个方法抛出异常后统一处理，就可以编写AfterThrowing类型的Advice方法。Advice一共有五种类型：</p><ul><li>Before</li><li>After</li><li>AfterReturning</li><li>AfterThrowing</li><li>Around</li></ul><p>这些类型的共同特点：</p><ul><li>所有类型的注解都有两个属性：value、argNames。value属性用于指定切入点，argNames属性可以用来访问目标方法的入参</li><li>除<code>Around</code>之外，其他四种类型的方法的连接点参数都只能是JoinPoint，不能是ProceedingJoinPoint（ProceedingJoinPoint是JoinPoint的子类）</li><li>只有<code>Around</code>方法能改变目标方法的入参和返回值</li></ul><p>下面分别介绍这五种类型的特点和使用方法。</p><h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><p>在目标方法执行前织入，不能访问目标方法的返回值，可选参数有JoinPoint。<br><code>@Before</code>注解属性：value、argNames</p><blockquote><p>JoinPoint简单介绍：<br>JoinPoint参数不必须，但需要时必须作为第一个参数！<br>常用方法有：<br>Object[] getArgs：返回目标方法的参数<br>Signature getSignature：返回目标方法的签名(含方法名和参数表)</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"============before============"</span>);</span><br><span class="line">    System.out.println(<span class="string">"目标方法名为:"</span> + joinPoint.getSignature().getName()); <span class="comment">// 打印方法名add</span></span><br><span class="line">    System.out.println(<span class="string">"目标方法所属类的类名:"</span> + joinPoint.getSignature().getDeclaringTypeName());<span class="comment">// 打印全限定类名com.example.demo.controller.UserController</span></span><br><span class="line">    <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"第"</span> + (i+<span class="number">1</span>) + <span class="string">"个参数为:"</span> + args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><p>在目标方法结束后织入，不管目标方法如何结束（正常还是异常），它都会被织入，可选参数有JoinPoint。<br><code>@After</code>注解和<code>@Before</code>注解属性相同：value、argNames<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"============after============"</span>);</span><br><span class="line">    <span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AfterReturning"><a href="#AfterReturning" class="headerlink" title="AfterReturning"></a>AfterReturning</h3><p>在目标方法正常完成后被织入，抛出异常了不织入，可选参数有JoinPoint和Object（目标方法的返回值）。<br><code>@AfterReturning</code>注解除了value、argNames这两个属性外，还有一个属性：</p><ul><li>returning：指定一个返回值形参名，可以通过该形参名来访问目标方法的返回值，但不可修改目标方法的返回值</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(pointcut = <span class="string">"pointcut()"</span>, returning = <span class="string">"returnObject"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(JoinPoint joinPoint, Object returnObject)</span> </span>&#123; <span class="comment">// 返回值的形参名与注解中的保持一致</span></span><br><span class="line">    System.out.println(<span class="string">"============afterReturning============"</span>);</span><br><span class="line">    <span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line">    <span class="comment">// 访问目标方法的返回值</span></span><br><span class="line">    System.out.println(<span class="string">"返回值："</span> + returnObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AfterThrowing"><a href="#AfterThrowing" class="headerlink" title="AfterThrowing"></a>AfterThrowing</h3><p>在目标方法抛出异常时织入，正常完成不织入，可选参数有JoinPoint和Throwable（目标方法抛出的异常）。<br><code>@AfterThrowing</code>注解除了value、argNames这两个属性外，还有一个属性：</p><ul><li>throwing：指定一个异常形参名，形参可用于访问目标方法抛出的异常</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(throwing = <span class="string">"e"</span>, pointcut = <span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable e)</span> </span>&#123; <span class="comment">// 异常的形参名与注解中的保持一致</span></span><br><span class="line">System.out.println(<span class="string">"============afterThrowing============"</span>);</span><br><span class="line"><span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line"><span class="comment">// 打印异常</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这个AfterThrowing只能用在打印异常信息，不能对抛出的异常做更多处理，也不能针对异常来改变目标方法的返回值。<br>想要根据异常信息修改目标方法返回值，只能用下面讲的Around。</p><h3 id="Around"><a href="#Around" class="headerlink" title="Around"></a>Around</h3><ul><li>可以在执行目标方法前织入，也可以在执行后织入</li><li>可以决定目标方法在什么时候执行，如何执行，可以完全阻止目标方法的执行</li><li>可以修改目标方法的参数值，也可以修改目标方法的返回值</li><li>至少包含一个参数，且第一个参数必须是ProceedingJoinPoint</li><li>在方法体内，调用ProceedingJoinPoint的proceed()方法才会执行目标方法。如果方法体内没有调用这个proceed()方法，则目标方法不会执行</li><li>最后必须把获得的目标方法的返回值，作为@Around方法的返回值return回去(因为如果无返回值的话，将不会继续执行目标方法)</li></ul><p><code>@Around</code>注解属性：value、argNames</p><p>第一个示例，没修改目标方法入参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">          <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">          Object[] args = joinPoint.getArgs();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">              System.out.println(<span class="string">"第"</span> + (i+<span class="number">1</span>) + <span class="string">"个参数为:"</span> + args[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 返回值</span></span><br><span class="line">          Object re = joinPoint.proceed();</span><br><span class="line">          <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第二个示例，修改了目标方法入参（入参为基本类型和String）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">        <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 修改参数值</span></span><br><span class="line">            args[i] += <span class="string">"updated"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        Object re = joinPoint.proceed(args); <span class="comment">// 这里要把修改后的args作为proceed方法的参数</span></span><br><span class="line">        <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个示例，修改了目标方法入参（入参为对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">        <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        Object param = args[<span class="number">0</span>];</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">if</span>(param <span class="keyword">instanceof</span> Person)</span><br><span class="line">        person = (Person) param;</span><br><span class="line">        person.setAddress(<span class="string">"address"</span>); <span class="comment">// 修改参数对象属性</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        Object re = joinPoint.proceed(); <span class="comment">// 这里不用再把修改后的args作为proceed方法的参数</span></span><br><span class="line">        <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，关于Around中的异常捕获：</p><ol><li>只有从目标方法中抛出的异常才会被捕获，若目标方法内自己try-catch异常了没有抛出，就不会触发Around的异常捕获</li><li>Around中处理异常，返回的响应类型必须和目标方法声明的一致，即必须是目标方法的返回类及其子类，否则会出现强制转换报错</li></ol><h1 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h1><p>AOP的全称是Aspect Oriented Programming，面向切面编程，它是通过动态代理技术，将Aspect方法中的逻辑完整织入到切入点中。下面开始先介绍静态代理（即设计模式中的代理模式），再介绍动态代理，最后再说说Spring是怎么用动态代理实现AOP的。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在设计模式中，常用到代理模式，它一般由一个接口和这个接口的两个实现类组成。<br>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"message: "</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProxy</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Service service; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceProxy</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">doBefore();</span><br><span class="line"><span class="keyword">this</span>.service.printMessage(msg);</span><br><span class="line">doAfter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行代理方法前的处理（前置处理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========proxy start========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行完代理方法后的处理（后置处理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========proxy end========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代理类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">ServiceProxy proxy = <span class="keyword">new</span> ServiceProxy(service);</span><br><span class="line">proxy.printMessage(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，静态代理需要我们自己编写代理类ServiceProxy，在它的printMessage方法中加上前置处理和后置处理。而动态代理，就不用我们自己写代理类，就能把我们指定的前置后置处理方法加到被代理方法的前后流程中。下面介绍动态代理的实现。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理，简单地说，就是不用自己写代理类，而是在<strong>运行时</strong>自动生成代理类和代理类对象。<br>接口Service和实现类ServiceImpl代码同上，不再赘述。</p><p>动态代理类：<br>作用：在运行时生成被代理类对象，规定执行被代理对象的目标方法的流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object _obj = <span class="keyword">null</span>; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object _obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>._obj = _obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   proxy 代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   method 被代理对象的目标方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   args 被代理对象的目标方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  被代理对象的目标方法的执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// 此处可以编写前置处理...</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(_obj, args); <span class="comment">// 反射执行被代理对象的目标方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用动态代理类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(service); <span class="comment">// 放入被代理对象</span></span><br><span class="line"><span class="comment">// 使用JDK中的Proxy类生成Service类的代理对象</span></span><br><span class="line">Service proxy = (Service) Proxy.newProxyInstance(service.getClass().getClassLoader(),</span><br><span class="line">service.getClass().getInterfaces(), dynamicProxy); </span><br><span class="line">proxy.printMessage(<span class="string">"hello"</span>); <span class="comment">// 这一步其实就是执行dynamicProxy.invoke方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码很简单地实现了动态代理：自己不用写Service类的代理类，运行时才生成Service类的代理类和代理对象。</p><p>当然AOP的实现没有这么简单，它还需要把切面类织入到切入点中。</p><h2 id="AOP的动态代理"><a href="#AOP的动态代理" class="headerlink" title="AOP的动态代理"></a>AOP的动态代理</h2><p>以下代码可以简单实现AOP逻辑。<br>接口Service和实现类ServiceImpl代码同上，不再赘述。</p><p>切面接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aspect</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">useAround</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectImpl</span> <span class="keyword">implements</span> <span class="title">Aspect</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doBefore========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAfter========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAfterReturning========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAfterThrowing========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAround Start========"</span>);</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">System.out.println(<span class="string">"========doAround End========"</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">useAround</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object _obj = <span class="keyword">null</span>; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Aspect _aspect; <span class="comment">// 切面类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object _obj, Aspect _aspect)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>._obj = _obj;</span><br><span class="line"><span class="keyword">this</span>._aspect = _aspect;</span><br><span class="line">Object proxy = Proxy.newProxyInstance(_obj.getClass().getClassLoader(), _obj.getClass().getInterfaces(), <span class="keyword">this</span>); <span class="comment">// 代理对象</span></span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment"> *            代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> *            被代理对象的目标方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> *            被代理对象的目标方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被代理对象的目标方法的执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">Object result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">_aspect.doBefore();</span><br><span class="line"><span class="keyword">if</span> (_aspect.useAround()) &#123;</span><br><span class="line">result = _aspect.doAround(_obj, method, args);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = method.invoke(_obj, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">hasException = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_aspect.doAfter();</span><br><span class="line"><span class="keyword">if</span> (hasException) &#123;</span><br><span class="line">_aspect.doAfterThrowing();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">_aspect.doAfterReturning();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用动态代理类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy();</span><br><span class="line">Service proxy = (Service) dynamicProxy.getProxy(service, <span class="keyword">new</span> AspectImpl());</span><br><span class="line">proxy.printMessage(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doBefore&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAround Start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">message: hello</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAround End&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAfter&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAfterReturning&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>可以看出，以上代码成功把切面类AspectImpl的逻辑织入到了被代理对象的目标方法中。因此，Spring AOP的原理就是，Spring中有一个类似于动态代理类DynamicProxy的类，帮我们把切面类织入到切入点了。</p><h1 id="Spring中已实现的AOP"><a href="#Spring中已实现的AOP" class="headerlink" title="Spring中已实现的AOP"></a>Spring中已实现的AOP</h1><p>Spring中有一些已经写好的切面逻辑，可以直接拿来用。</p><h2 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h2><p>用<code>@ControllerAdvice</code>注解修饰的类，可以对Controller中用<code>@RequestMapping</code>修饰的方法做切面处理，最常用的是统一处理Controller方法抛出的异常。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span> <span class="comment">// 响应体是json格式就必须加这个注解</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>) // 指定抛出的异常类型</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">JSONObject</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123; <span class="comment">// 在这个方法中写抛出异常后的处理</span></span><br><span class="line">System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">json.put(<span class="string">"code"</span>, <span class="string">"9999"</span>);</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"System Error"</span>);</span><br><span class="line"><span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例是指，当Conrtroller方法中抛出异常时，统一返回<strong>{“msg”:”System Error”,”code”:”9999”}</strong>响应体。<br>若需要统一跳到某个页面，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>) // 指定抛出的异常类型</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ModelAndView</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123; <span class="comment">// 在这个方法中写抛出异常后的处理</span></span><br><span class="line">    System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">//指定错误页面的模板页</span></span><br><span class="line">        mav.setViewName(<span class="string">"error"</span>);</span><br><span class="line">        mav.addObject(<span class="string">"code"</span>, ex.getCode());</span><br><span class="line">        mav.addObject(<span class="string">"msg"</span>, ex.getMsg());</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：当AOP切面和@ControllerAdvice同时存在，且AOP切面里也会统一处理Controller抛出的异常，@ControllerAdvice就不一定会执行。请看下面的例子。<br>AOP切面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(log)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint, Log log)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">            <span class="comment">// 返回值</span></span><br><span class="line">            Object re = joinPoint.proceed();</span><br><span class="line">            <span class="keyword">if</span>(re <span class="keyword">instanceof</span> JSONObject)</span><br><span class="line">            result = (JSONObject) re;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            result.put(<span class="string">"code"</span>, <span class="string">"9998"</span>);</span><br><span class="line">            result.put(<span class="string">"msg"</span>, <span class="string">"error"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ControllerAdvice的修饰类同上，不再赘述。<br>运行时发现，目标方法抛出异常时，会统一返回<strong>{“msg”:”error”,”code”:”9998”}</strong>，而不会返回@ControllerAdvice中的<strong>{“msg”:”System Error”,”code”:”9999”}</strong>。原因就是AOP中已经处理好异常了。<br>若仍然想把异常交给@ControllerAdvice处理，AOP切面可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(log)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint, Log log)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">            <span class="comment">// 返回值</span></span><br><span class="line">            Object re = joinPoint.proceed();</span><br><span class="line">            <span class="keyword">if</span>(re <span class="keyword">instanceof</span> JSONObject)</span><br><span class="line">            result = (JSONObject) re;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e; <span class="comment">// 把异常抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，目标方法抛出异常时，会统一返回@ControllerAdvice中的<strong>{“msg”:”System Error”,”code”:”9999”}</strong>。原因就是AOP中把异常抛出了。</p><h3 id="404异常处理"><a href="#404异常处理" class="headerlink" title="404异常处理"></a>404异常处理</h3><p>没有什么特殊配置的情况下，Spring Boot遇到404就会自动跳到Spring Boot的error页面。若想要自己处理404异常，可以使用@ControllerAdvice。顺便一提，由于接口不存在，所以404异常肯定不会被AOP切面处理。<br>要处理404异常，必须在配置文件中加上：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出现错误时, 直接抛出异常</span></span><br><span class="line"><span class="attr">spring.mvc.throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 不要为我们工程中的资源文件建立映射</span></span><br><span class="line"><span class="attr">spring.resources.add-mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这个配置一定要加，否则Spring Boot总是会帮我们处理404异常，而不会进入我们定义的方法中。<br>然后就是在@ControllerAdvice中处理404，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">JSONObject</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line"><span class="keyword">if</span>(ex <span class="keyword">instanceof</span> NoHandlerFoundException) &#123; <span class="comment">// 404异常</span></span><br><span class="line">json.put(<span class="string">"code"</span>, <span class="string">"9997"</span>);</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"No Found"</span>);</span><br><span class="line"><span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line">json.put(<span class="string">"code"</span>, <span class="string">"9999"</span>);</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"System Error"</span>);</span><br><span class="line"><span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以发现，访问不存在的URI时，会统一返回<strong>{“msg”:”No Found”,”code”:”9997”}</strong>。</p><h2 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h2><p>这个注解帮你实现了数据库事务逻辑，尤其是事务回滚。<br>举个例子，删除用户时，要把用户关联的权限一起删除，当删除用户成功但删除权限不成功时，应该把删除用户的操作回滚，使得数据一致。<br>服务层示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaintainService</span> <span class="keyword">implements</span> <span class="title">IMaintainService</span></span>&#123;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">// 事务回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，当deletePersonPrivilege方法抛出异常时，deleteById方法会被回滚，即数据库中用户和用户权限依然存在，说明回滚成功。另外，回滚成功后，依然会进入AOP切面中的异常捕获。<br>下面介绍<code>@Transactional</code>注解使用的注意点。</p><h3 id="Transactional只能用在public方法上"><a href="#Transactional只能用在public方法上" class="headerlink" title="@Transactional只能用在public方法上"></a>@Transactional只能用在public方法上</h3><p>Spring在回滚前会检查方法修饰符是不是public，是才回滚。</p><h3 id="Transactional的rollbackFor属性"><a href="#Transactional的rollbackFor属性" class="headerlink" title="@Transactional的rollbackFor属性"></a>@Transactional的<strong>rollbackFor</strong>属性</h3><p>默认情况下，只有抛出Error类，或RuntimeException类及其子类的异常，Spring才会回滚。其他类型的异常不会回滚。<br>若需要在抛出其他异常时回滚，可以指定<strong>rollbackFor</strong>属性，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor=Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">deletePerson</span>(<span class="title">int</span> <span class="title">personId</span>) </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，只有抛出Exception类及其子类的异常，Spring才会回滚。</p><h3 id="自调用问题"><a href="#自调用问题" class="headerlink" title="自调用问题"></a>自调用问题</h3><p>上面的示例，<code>@Transactional</code>注解修饰的方法会直接被Controller层接口调用，这种情况下都能回滚成功。但也有一些特殊情况。<br>情况1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，<code>@Transactional</code>不会生效。应改为下面这样才能生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 异步调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 异步调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种有异步线程存在的情况下，<code>@Transactional</code>无论加在哪个方法都不会生效。<br>因此，只有把<code>@Transactional</code>注解加在直接被外部调用的方法才能生效。</p><h1 id="Spring-AOP和AspectJ的关系"><a href="#Spring-AOP和AspectJ的关系" class="headerlink" title="Spring AOP和AspectJ的关系"></a>Spring AOP和AspectJ的关系</h1><p>AspectJ是一个独立的AOP框架，它有自己的一套语法用来实现AOP，用它的语法写的代码文件是.aj文件，还有自己的编译器ajc（Java编译器是javac），负责把.aj编译为.class文件。AspectJ在编译时就生成了代理类，所以它是静态代理。Spring的切入点只能是方法，但AspectJ可以用于字段、类等等，它的实现比Spring AOP要复杂的多。</p><p>在我们上面的实践中，都是用注解来编写切面类，这些注解是AspectJ的jar包提供的，但对于AOP功能的实现，用的是JDK或CGLIB的动态代理。因此，Spring AOP和AspectJ的关系就是，Spring用到了AspectJ的注解，但没有用它的语法和编译器，也没有用AspectJ的静态代理来实现功能。</p><h1 id="JDK和CGLIB"><a href="#JDK和CGLIB" class="headerlink" title="JDK和CGLIB"></a>JDK和CGLIB</h1><ol><li>JDK动态代理。只能代理实现了接口的类。上面代码所展现的就是这个机制。它是用Proxy.newProxyInstance()方法生成代理类，用InvocationHandler向代理类织入AOP逻辑</li><li>CGLIB动态代理。不要求被代理类必须实现接口，但不能代理final类。它是用Enhancer类创建<em>被代理类的子类</em>作为代理类，底层是用字节码创建子类，用MethodInterceptor向子类织入AOP逻辑</li></ol><p>在SpringBoot2.0之前，Spring默认用JDK动态代理，只有当被代理类没有实现接口时，Spring才用CGLIB动态代理。在SpringBoot2.0之后，无论被代理类是否实现接口，Spring默认都用CGLIB动态代理。</p><blockquote><p>想要自行实现CGLIB动态代理，看这篇博客：<a href="https://www.jianshu.com/p/13fa41aa18d8" target="_blank" rel="noopener">https://www.jianshu.com/p/13fa41aa18d8</a></p></blockquote><blockquote><p>JDK为什么只能代理实现了接口的类？</p></blockquote><p>JDK用Proxy.newProxyInstance()方法生成的代理类类似于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">HelloService</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>因为既要继承Proxy，又要继承接口，所以另一个只能是接口。</p><blockquote><p>SpringBoot2.0之后，为什么默认用CGLIB动态代理？</p></blockquote><p>官方的回答是，We’ve generally found cglib proxies less likely to cause unexpected cast exceptions.他们认为使用cglib更不容易出现转换错误。<br>如果我们的代码写成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserServiceImpl userService;</span><br></pre></td></tr></table></figure><p>这个时候，如果是JDK动态代理，那在启动时就会报错：因为JDK动态代理是基于接口的，代理生成的对象只能赋值给接口类型。CGLIB就不会报错<br>如果想设置默认使用JDK动态代理，可以加上配置项spring.aop.proxy-target-class=false。</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><ol><li>JDK和CGLIB都是在运行期生成代理类的字节码。区别在于，JDK是直接写Class字节码，CGLIB使用ASM框架写Class字节码，CGLIB代理实现更复杂，生成代理类的效率比JDK低。</li><li>JDK调用代理方法，是通过反射机制调用。CGLIB是通过FastClass机制直接调用方法，CGLIB执行效率更高。但，在JDK1.8后，Java的反射调用效率有所改善，整体的动态代理速度已经可以和CGLIB媲美了。</li></ol><blockquote><p>什么是FastClass机制？</p></blockquote><p>FastClass机制的原理简单来说就是：为代理类和被代理类各生成一个Class，这个Class会为代理类或被代理类的方法分配一个index(int类型)。这个index当做一个入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比JDK动态代理通过反射调用高。</p><blockquote><p>JDK1.8后，Java的反射调用效率有哪些改善？</p></blockquote><p>在1.8之前，JVM把缓存放在Class的属性SoftReference<ReflectionData> reflectionData。这个属性的类型是SoftReference（软引用），所谓软引用就是在资源紧张的情况下GC会进行回收，这就可能导致缓存丢失。SoftReference的泛型是ReflectionData，ReflectionData就是缓存数据的真正格式。ReflectionData将所有的Constructor、Method、Field对象存储下来供反射进行使用。</p><p>在1.8，放弃使用ReflectionData存储，而是在Class中直接将Constructor、Method、Field数组放进软引用中作为缓存。这样就将缓存分散，当资源紧张时，缓存不会全部被GC回收。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理描述 </tag>
            
            <tag> 实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 时间类型转换</title>
      <link href="/2020/02/25/java-date-trans/"/>
      <url>/2020/02/25/java-date-trans/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java中表示时间有三种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String dateStr = <span class="string">"2020-01-01 15:00:11"</span>; <span class="comment">// String类型</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(); <span class="comment">// Date类型</span></span><br><span class="line"><span class="keyword">long</span> time = date.getTime(); <span class="comment">// long类型</span></span><br></pre></td></tr></table></figure><p>　　这三种类型的不同在于，String类型不带时区信息，Date和long类型会带时区信息。开发项目时，接口参数的时间字段最好用long类型表示，这样发送方和接收方收到的时间会一致。用String类型也能一致，但双方可能都要做格式转换。用Date类型做接口参数时，接收方和收到的值可能与发送方的不一致，不适合验签。</p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><h3 id="Date转String"><a href="#Date转String" class="headerlink" title="Date转String"></a>Date转String</h3><p>看一下电脑上的时间，得知当前时间是8时区的2020-02-25 15:41:21（系统时区是8时区）。<br>按照<code>yyyy-MM-dd HH:mm:ss</code>的格式打印当前时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date(); <span class="comment">// 当前时间</span></span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>; <span class="comment">// 注意，月份M大写，分钟m小写</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">System.out.println(sdf.format(d)); <span class="comment">// 2020-02-25 15:41:21</span></span><br></pre></td></tr></table></figure><p>打印结果和电脑上显示的一致。</p><h4 id="转换时考虑时区"><a href="#转换时考虑时区" class="headerlink" title="转换时考虑时区"></a>转换时考虑时区</h4><p>若想知道当前时间对应的GMT0时间是多少，就要在转换时加上时区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date(); <span class="comment">// 当前时间</span></span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">String timezone = <span class="string">"GMT+0"</span>; <span class="comment">// 时区</span></span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">System.out.println(sdf.format(d)); <span class="comment">// 2020-02-25 07:41:21</span></span><br></pre></td></tr></table></figure><p>打印结果<strong>2020-02-25 07:41:21(GMT0)</strong>和当前时间<strong>2020-02-25 15:41:21(GMT8)</strong>可以对应。</p><h3 id="Date转long"><a href="#Date转long" class="headerlink" title="Date转long"></a>Date转long</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="keyword">long</span> time = date.getTime();</span><br></pre></td></tr></table></figure><h2 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h2><h3 id="long转Date"><a href="#long转Date" class="headerlink" title="long转Date"></a>long转Date</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">Date d = <span class="keyword">new</span> Date(currentTimeMillis);</span><br></pre></td></tr></table></figure><h3 id="long转String"><a href="#long转String" class="headerlink" title="long转String"></a>long转String</h3><p>先long转Date，再Date转String。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String转Date"><a href="#String转Date" class="headerlink" title="String转Date"></a>String转Date</h3><p>若已知时间字符串”2020-02-25 10:44:05”是8时区，系统也是8时区，那么转换时可以简单的写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"2020-02-25 10:44:05"</span>;</span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>; <span class="comment">// 时间字符串的格式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Tue Feb 25 10:44:05 CST 2020</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>10:44:05</strong>和时间字符串<strong>2020-02-25 10:44:05(GMT8)</strong>一致。</p><blockquote><p>CST时间：China Standard Time，中国标准时间，等于GMT8</p></blockquote><h4 id="转换时考虑时区-1"><a href="#转换时考虑时区-1" class="headerlink" title="转换时考虑时区"></a>转换时考虑时区</h4><p>但如果已知”2020-02-25 10:44:05”这个字符串是0时区，那么就要指定时区转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"2020-02-25 10:44:05"</span>;</span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>; <span class="comment">// 时间字符串的格式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">String timezone = <span class="string">"GMT+0"</span>; <span class="comment">// 时间字符串的时区</span></span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Tue Feb 25 18:44:05 CST 2020</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>18:44:05</strong>和时间字符串<strong>2020-02-25 10:44:05(GMT0)</strong>一致。</p><h4 id="复杂格式的时间字符串转换"><a href="#复杂格式的时间字符串转换" class="headerlink" title="复杂格式的时间字符串转换"></a>复杂格式的时间字符串转换</h4><p>处理复杂的时间字符串，如<strong>PDT时间</strong>：</p><blockquote><p>PDT时间：Pacific Daylight Time，太平洋夏季时间，等于UTC-7，UTC=GMT0，因此PDT=GMT8-15<br>PST时间：Pacific Standard Timee，太平洋标准时间，等于PDT-1，因此PST=GMT8-16</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"03:00:14 Jun 13, 2019 PDT"</span>; <span class="comment">// pdt时间2019-06-13 03:00:14</span></span><br><span class="line">String format = <span class="string">"HH:mm:ss MMM dd, yyyy z"</span>; <span class="comment">// z表示时区</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format, Locale.ENGLISH); <span class="comment">// 当字符串中有英文单词时要加上Locale参数</span></span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Thu Jun 13 18:00:14 CST 2019</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>18:00:14</strong>和时间字符串<strong>2019-06-13 03:00:14(PDT)</strong>一致。</p><p>处理<strong>UTC时间</strong>（UTC=GMT0）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"2019-04-24T02:30:00"</span>;</span><br><span class="line">String format = <span class="string">"yyyy-MM-dd'T'HH:mm:ss"</span>; <span class="comment">// 时间格式，注意T带引号</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">String timezone = <span class="string">"GMT+0"</span>; <span class="comment">// 时间字符串的时区</span></span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Wed Apr 24 10:30:00 CST 2019</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>10:30:00</strong>和时间字符串<strong>2019-04-24 02:30:00(UTC)</strong>一致。</p><h3 id="String转long"><a href="#String转long" class="headerlink" title="String转long"></a>String转long</h3><p>先String转Date，再Date转long。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《算法图解》笔记</title>
      <link href="/2020/02/23/grokking-algorithms-note/"/>
      <url>/2020/02/23/grokking-algorithms-note/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　《算法图解》这本书真的非常好懂，它结合图画，对算法基础知识讲得很透，把“每一步要怎么做”和“为什么这样做”都交代了。这些知识以前在学校也学习过，但那时候只记住算法每一步怎么做，时间复杂度也是硬背的，根本没去理解背后的原因。这样的后果就是学完就忘。这本书就很适合我这种对算法稍微懂点但又不是很懂的人，它帮我把以前的疑惑都解开了。但它有个局限性就是，只讲基础，对稍微难点的内容都是一笔带过，只能靠个人去学，真正的入门书。<br>　　因为作者就像聊天似的教算法，图画也多，所以这本书的知识点比较散，这篇博客就是将我从这本书学到的知识点记录下来。</p><h1 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h1><ul><li>大O表示法体现的是随着元素数量n的增多，操作次数的增长趋势。如O(logn)（二分查找）的增长趋势明显比0(n)（简单查找）要慢得多，因此可以说二分查找比简单查找更好</li><li>大O表示法一般是该算法在最糟情况下的速度，但算法也有平均情况（也是最优情况）下的速度。如快速排序最糟O(n^2)，平均O(nlogn)</li><li>大O表示法不含常量的原因：当元素数量很多时，常量对速度的影响可忽略不计</li><li>O(1)表示常量时间，含义是无论元素数量多少，所需时间都一样</li></ul><p><strong>注：</strong></p><ol><li>这本书里只讨论时间复杂度，没讲空间复杂度</li><li>logn就是log2n，即2的幂</li></ol><h1 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h1><ul><li>在内存方面：数组元素的内存地址是相邻的，链表元素的内存地址不用相邻，链表的每个元素中都会存放下一个元素的内存地址</li><li>在查找方面：链表只能顺序查找，而数组可以随机访问到任一元素，因此说数组的查找效率更好</li><li>在插入和删除方面：链表的插入和删除只是改变某个元素存储的下一个元素的地址，数组的插入要重新分配内存，删除时要把后面的元素往前移</li><li>链表的插入和删除都是O(1)，这不包括“查找插入/删除位置”的时间</li></ul><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ul><li>递归没有什么性能优势，只是让代码更清晰。可以用递归实现的也能用循环实现</li><li>每个递归都包含两个条件：递归条件–让函数调用自己的条件，基线条件–函数return的条件（即不再递归的条件）</li><li>每次递归调用都会加入到调用栈，占用内存，执行完就会从调用栈弹出</li></ul><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>　　在调用栈过高的情况下，可以写成尾递归的形式。尾递归就是手动把本次调用的计算结果作为递归函数的参数，这样在return时就直接return递归，而不是还要先处理递归结果再return。<br>　　下面以阶乘函数为例，展示递归和尾递归的不同写法：</p><p><strong>普通递归：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> n * fac(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尾递归：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fac2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">//第一次调用时t=1</span></span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> fac2(n - <span class="number">1</span>, n * t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　写成尾递归后，若编译器会自动帮你把尾递归代码优化就会很好用（jvm不会），否则需要你手动把尾递归代码优化了才会有节省栈内存的效果。尾递归可以优化的原因：每次递归都计算出了一个结果，上一次递归的结果就没必要保留，可以释放内存。</p><h1 id="分而治之（D-amp-C）"><a href="#分而治之（D-amp-C）" class="headerlink" title="分而治之（D&amp;C）"></a>分而治之（D&amp;C）</h1><ul><li><p>分而治之是一种递归式的问题解决方法。思路是缩小问题范围，思考解决小问题的方法，能解决小问题的方法也适用于大问题。欧几里得算法就是这个思路</p><blockquote><p>两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数</p></blockquote></li><li><p>工作过程：a.找出基线条件，这个条件必须尽可能简单；b.缩小问题的规模，使其符合基线条件</p></li><li><p>要处理的对象是数组时，基线条件一般是数组为空或只含一个元素</p></li></ul><p><strong>举例：</strong>求数组[1,2,3,4,5]的总和，基线条件为：当数组只有一个元素时数组总和就等于这个元素。做法就是：不断挑出一个元素，使数组规模变小，求(挑出的元素+数组剩余元素总和)的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span>[] aArr = <span class="keyword">new</span> <span class="keyword">int</span>[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">aArr[i - <span class="number">1</span>] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">0</span>] + sum(aArr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码只是为了说明“分而治之”的思想，一般情况下求数组总和还用不到递归。</p><p><strong>注：</strong>这本书说的“分而治之”的概念是其他一些教材说的“减而治之”。一些人把“减而治之”看作是“分而治之”的一种特殊情况，作者这样写也没错。</p><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><ul><li>由数组和散列函数组成，通过散列函数将要存储的值计算成数组索引，值就放在索引处</li><li>良好的散列函数会尽量覆盖数组的每个位置，即每个值都放在不同位置</li></ul><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><ul><li>只适用于有序数列</li><li>运行时间为O(logn)，就是把一串数字对半分，直到只剩一个数字的次数</li><li>操作过程也运用了递归思想。基线条件：数组中间元素与目标相同；递归条件：当中间的元素不对，对一半数组继续二分查找</li></ul><p><strong>循环式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> high = n.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> i = n[mid];</span><br><span class="line"><span class="keyword">if</span> (i == target)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &lt; target) &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[] n, <span class="keyword">int</span> target, <span class="keyword">int</span> high, <span class="keyword">int</span> low)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> num = n[mid];</span><br><span class="line"><span class="keyword">if</span> (num == target)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num &lt; target) &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> binarySearch2(n, target, high, low);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>在实际使用中，当数组元素值都很大时，上面求中值的算式<code>int mid = (high + low) / 2</code>会有int溢出的可能，把它替换为<code>low + (high - low) / 2</code>会更好。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><ul><li>重复从数组中挑出最大或最小的元素放入新数组，直到原数组没有元素了</li><li>运行时间为0(n^2)，从n个元素中挑最大或最小（相当于把每个元素检查一遍），要挑n次，所以是n*n</li></ul><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><ul><li>过程：选出一个基准值pivot，比基准值小的数作为一个子数组a1，比基准值大的数作为子数组a2，qsort(a1) + pivot + qsort(a2)就是结果</li><li>平均情况下运行时间是O(nlogn)，即<strong>随机选取基准值</strong>，子数组a1和a2的元素个数基本是原数组的一半，调用栈高为logn，每一层栈要处理的元素数是n，所以是n*logn</li><li>最糟情况下运行时间是O(n^2)，即<strong>选取的基准值是最大或最小数</strong>，子数组a1和a2中总有一个为空，此时调用栈高为n，每一层栈要处理的元素数是n，所以是n*n</li></ul><p><strong>附：</strong>合并排序（Merge Sort）<br>　　合并排序就是把数组对半分，再递归把子数组对半分直到只有一个元素（栈高度logn），每一次对半分好后通过比较两个子数组的元素合并为一个有序数组（操作元素数n），合并排序的平均和最糟情况都是0(nlogn)</p><h1 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h1><ul><li><p>图的结构包含：节点(V)和边(E)</p></li><li><p><strong>树</strong>是一种特殊的图：不存在子节点往父节点指的边</p></li><li><p>节点之间有严格的先后顺序的图，叫<strong>拓扑排序</strong></p></li><li><p>非加权图找最短路径：<strong>广度优先搜索</strong>（下节详细说明）</p></li><li><p>加权图（不含负权边）找最短路径（即权重之和最小）：<strong>狄克斯特拉算法</strong><br>狄克斯特拉算法的思路：</p><ol><li>从所在节点的相邻节点中，找出“最便宜”的节点，即到达此相邻节点的权重最小</li><li>到达上一步所述的“最便宜”的节点后，更新从起点到达该“最便宜”节点的相邻节点的权重和</li><li>重复这个过程，直到对图中的每个节点都这样做了</li><li>计算最终路径的权重之和</li></ol></li><li><p>加权图（含负权边）找最短路径（即权重之和最小）：贝尔曼-福德算法</p></li><li><p>狄克斯特拉算法不适合用在带环的图</p></li></ul><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>广度优先搜索就是，从起点开始，判断走一步能到达的顶点中有没有终点，若没有，就判断走两步能到达的顶点中有没有终点。。。找到终点后，走的步数就是最短路径。</p><p>广度优先搜索可以解决2个问题：</p><ol><li>是否能到达终点</li><li>到达终点的最短路径</li></ol><p>专门用于找非加权图的最短路径。</p><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>广度优先搜索的运行时间：O(V+E)。V是图的节点数，E是边数。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li>用一个<strong>散列表</strong>存图的节点和边，key为每个节点，value为这个节点的相邻节点（邻居）列表</li><li>准备一个空<strong>队列</strong></li><li>从第一个节点开始，把该节点的邻居加入空队列</li><li>遍历队列中的每个节点，判断它们是不是终点，如果是，则返回最短步数；如果不是，把该节点的邻居加入队列（尾插），并删除该节点（头删）</li><li>用一个列表保存被判断过的节点，避免同一个节点被重复判断</li></ol><h2 id="广度优先和深度优先"><a href="#广度优先和深度优先" class="headerlink" title="广度优先和深度优先"></a>广度优先和深度优先</h2><h1 id="NP完全问题（NPC）"><a href="#NP完全问题（NPC）" class="headerlink" title="NP完全问题（NPC）"></a>NP完全问题（NPC）</h1><ul><li><p>无法快速找到最优解的就是NP完全问题</p></li><li><p><em>集合覆盖问题</em> 和 <em>旅行商问题</em> 就是典型的NP完全问题。背包问题属于集合覆盖问题。</p></li><li><p>解决NP完全问题，最好使用近似算法。贪婪算法就是近似算法的一种，无法得到最优解，但也接近最优解<br>贪婪算法，就是在限制的条件内，每一步都采取最优的做法。如背包问题中，每次都放入价值最高的物品，直到放不下为止</p></li><li><p>动态规划可以帮助找到NP完全问题的最优解</p><ul><li><p>可以使用动态规划的条件有：</p><ul><li>问题可以分解为互相独立的子问题。如背包问题中，放手机和放电脑彼此是独立的，谁先放都不会影响到另一个的价值</li><li>使用动态规划，问题的对象只有两种状态，有和没有，不能考虑“有一部分”这样的情况。如背包问题中，放一袋大米，只能考虑放整袋，不能考虑把米袋拆了只拿一部分</li></ul></li><li><p>动态规划的步骤</p><ol><li>绘制网格</li><li>决定网格的坐标轴代表什么。因为每个网格都代表一个子问题，所以要考虑怎么划分子问题。如对比两个字符串中相同字母的个数（求最长公共子序列问题），子问题就是一个字母一个字母的比较，所以坐标轴就是两个字符串</li><li>决定网格内的值代表什么。一般就是要优化的值。如求最长公共子序列问题，网格内的值就是相同字母的个数</li><li>决定网格内的值的计算公式。这个要通过经验和尝试来决定</li></ol></li></ul></li></ul><ul><li>NP完全问题的特征：<ol><li>元素数越多，算出最优解的时间越长</li><li>不能使用“分而治之”，必须考虑所有情况的问题</li><li>可以转化为集合覆盖问题或旅行商问题</li></ol></li></ul><p><strong>附：</strong>数学建模中其实有四类问题：P问题、NP问题、NP完全问题（NPC）、NP难问题（NPH），概念涉及到多项式，很复杂，这里不讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建vue开发环境</title>
      <link href="/2020/02/19/vue-env-build/"/>
      <url>/2020/02/19/vue-env-build/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为自己工作是搞后台的，偶尔要写下前端的时候，发现连前端项目怎么启动都忘记了= =||甚至不知道开发环境是怎么稀里糊涂地就搭好了。这种“学过的东西又还给网上教程”的感觉十分不愉快，但如果是还给自己写的教程，那…应该会庆幸还好写下来了吧╭(′▽`)╯。<br>这篇博客先简单地介绍“搭建vue开发环境”的4个步骤：</p><ol><li>安装Node.js</li><li>配置npm命令</li><li>初始化一个vue项目看看效果</li><li>编辑器VSCode的安装和配置</li></ol><p>说完“搭建环境”后，再顺便说说vue项目是怎么添加依赖模块和怎么打包部署的。</p><ul><li>给vue项目安装模块</li><li>打包vue项目</li></ul><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>进入官网下载：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 。安装好之后，在任一目录打开cmd输入命令测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>有打印版本号，类似于v13.5.0，就算安装成功。</p><h2 id="配置npm命令"><a href="#配置npm命令" class="headerlink" title="配置npm命令"></a>配置npm命令</h2><h3 id="设置依赖模块下载地址"><a href="#设置依赖模块下载地址" class="headerlink" title="设置依赖模块下载地址"></a>设置依赖模块下载地址</h3><p>开发vue项目时经常要安装项目所需模块（和后台项目下载jar包差不多），默认的下载地址 <a href="https://registry.npmjs.org/" target="_blank" rel="noopener">https://registry.npmjs.org/</a> 很慢，一般使用国内镜像地址 <a href="https://registry.npm.taobao.org/" target="_blank" rel="noopener">https://registry.npm.taobao.org/</a> 。<br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>执行成功后没有任何打印。</p><h3 id="设置全局模块和缓存目录"><a href="#设置全局模块和缓存目录" class="headerlink" title="设置全局模块和缓存目录"></a>设置全局模块和缓存目录</h3><p>在node.js的安装目录下，如<code>D:\Program Files\nodejs</code>，新建文件夹<code>node_cache</code>（名字可以任意起），这个文件夹是缓存目录。<br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> cache <span class="string">"D:\Program Files\nodejs\node_cache"</span></span><br></pre></td></tr></table></figure><p>全局模块目录就和本地maven仓库差不多。在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">"D:\Program Files\nodejs"</span></span><br></pre></td></tr></table></figure><p>这两个命令执行成功后没有任何打印。</p><h3 id="检查已设置内容"><a href="#检查已设置内容" class="headerlink" title="检查已设置内容"></a>检查已设置内容</h3><p>目前要自定义设置的就是这三个配置。要查看是否设置成功有两种方法：<br><strong>第一种：</strong><br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config ls</span><br></pre></td></tr></table></figure><p>结果会展示已自定义设置的内容：</p><img src="/2020/02/19/vue-env-build/npm_config_ls_result.png" class="" title="已设置内容"><p><strong>第二种：</strong><br>进入<code>C:\Users\个人目录</code>下，查看<code>.npmrc</code>文件，内容就是自定义配置项。</p><h3 id="其他有用的npm-config命令"><a href="#其他有用的npm-config命令" class="headerlink" title="其他有用的npm config命令"></a>其他有用的npm config命令</h3><ul><li><p>查看npm所有配置项（包括默认配置项）： npm config ls -l</p></li><li><p>修改某一个配置项： npm config set &lt;配置项名&gt; &lt;配置项值&gt;</p></li><li><p>查看某一个配置项值：npm config get &lt;配置项名&gt;</p></li><li><p>查看npm config命令的使用帮助： npm config -h</p></li></ul><h2 id="初始化一个vue项目"><a href="#初始化一个vue项目" class="headerlink" title="初始化一个vue项目"></a>初始化一个vue项目</h2><blockquote><p><strong>如果不打算自己创建项目，而是直接用已有的项目框架来开发，这一步可以跳过</strong></p></blockquote><h3 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h3><p>vue-cli叫做vue脚手架，它可以自动生成vue+webpack的项目模板。<br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure><p>这个命令还可以简写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g vue-cli</span><br></pre></td></tr></table></figure><p>这个命令表示<strong>全局</strong>安装vue-cli。执行过程中会打印一堆模块的名字，没看到<strong>ERROR</strong>之类的字眼就安装成功了。<br>若想验证是否安装成功，可以在cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue</span><br></pre></td></tr></table></figure><p>看到有vue命令的使用帮助就代表安装成功了。<br>另外，这个vue-cli模块安装到了刚刚执行这个命令<code>npm config set prefix &quot;...&quot;</code>时设置的目录下的<code>node_modules</code>文件夹中。<br>npm install命令的更多介绍可以看“扩展内容”-“给vue项目安装模块”部分。</p><h3 id="创建vue项目"><a href="#创建vue项目" class="headerlink" title="创建vue项目"></a>创建vue项目</h3><p>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack hello-demo</span><br></pre></td></tr></table></figure><p>这个命令表示在当前目录下创建hello-demo项目。</p><p>创建过程中，会问你一些问题，在看到<code>Install vue-router?</code>问题前都按<code>回车</code>，<code>Install vue-router?</code>这个问题输入<code>Y</code>，剩下的目前用不到就输入<code>N</code>。示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">? Project name hello-demo</span><br><span class="line">? Project description A Vue.js project</span><br><span class="line">? Author abc &lt;123456@qq.com&gt;</span><br><span class="line">? Vue build standalone</span><br><span class="line">? Install vue-router? Yes</span><br><span class="line">? Use ESLint to lint your code? No</span><br><span class="line">? Set up unit tests No</span><br><span class="line">? Setup e2e tests with Nightwatch? No</span><br><span class="line">? Should we run `npm install` <span class="keyword">for</span> you after the project has been created? (recommended) npm</span><br></pre></td></tr></table></figure><p>创建完成后有如下提示，说明创建成功。</p><img src="/2020/02/19/vue-env-build/vue_init_result.png" class="" title="创建成功"><h3 id="运行vue项目"><a href="#运行vue项目" class="headerlink" title="运行vue项目"></a>运行vue项目</h3><p>按照创建完成后给出的提示命令，在cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hello-demo</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><code>npm run dev</code>命令简单地说就是用hello-demo项目中的<code>node_modules\webpack-dev-server</code>模块启动项目，用的是开发环境的配置<code>build\webpack.dev.conf.js</code>，详细一点的解释可以在网上找得到，这里就不展开了。<br>启动成功后，访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 可以看到如下页面：</p><img src="/2020/02/19/vue-env-build/run_result.png" class="" title="项目主页"><h2 id="编辑器VSCode的安装和配置"><a href="#编辑器VSCode的安装和配置" class="headerlink" title="编辑器VSCode的安装和配置"></a>编辑器VSCode的安装和配置</h2><p>可以用来做vue开发的编辑器有vscode、webstorm等等，这里介绍的vscode，优点是免费而且轻量，缺点是使用一些必要的功能还要额外装插件。<br>在官网下载：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a> ，安装过程很普通所以不讲了。</p><h3 id="下载vetur插件实现vue代码高亮"><a href="#下载vetur插件实现vue代码高亮" class="headerlink" title="下载vetur插件实现vue代码高亮"></a>下载vetur插件实现vue代码高亮</h3><p>vscode打开vue项目时没有任何语法高亮。要下载vetur插件来实现。</p><ul><li><p>常规安装<br>在vscode界面最左侧的工具栏，如下图点击图标出现<code>Extensions</code>页面。</p><img src="/2020/02/19/vue-env-build/vscode_extensions.png" class="" title="Extensions"><p>在输入框输入vetur，点击安装，安装好后重新打开vscode即可看到vue代码已高亮。</p></li><li><p>离线安装<br>因为开发环境很有可能是不联网的，所以有时候要采取特殊手段来安装插件。<br>先在有网的环境，进入官网下载插件包：<a href="https://marketplace.visualstudio.com/vscode" target="_blank" rel="noopener">https://marketplace.visualstudio.com/vscode</a> ，搜索vetur，点击图中的下载按钮下载。</p><img src="/2020/02/19/vue-env-build/vetur_download.png" class="" title="vetur"><p>下载后的插件包是<code>.vsix</code>后缀的。<br>然后把这个<code>.vsix</code>文件放到vscode的安装目录的bin目录下。<br>接着在bin目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code --install-extension octref.vetur-0.23.0.vsix</span><br></pre></td></tr></table></figure><p>离线安装其他插件也是用这样的方法。</p></li></ul><h3 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h3><p>点击File -&gt; Preference -&gt; Keyboard Shortcuts，可以查看和修改快捷键。</p><h2 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h2><p>以上步骤已经把vue开发环境搭建好了。下面扩展地讲一下vue项目依赖模块的安装和打包。</p><h3 id="给vue项目安装模块"><a href="#给vue项目安装模块" class="headerlink" title="给vue项目安装模块"></a>给vue项目安装模块</h3><h4 id="安装axios模块"><a href="#安装axios模块" class="headerlink" title="安装axios模块"></a>安装axios模块</h4><p>假设现在在开发hello-demo项目，发现需要一个axios插件，用来实现HTTP请求。<br>在项目根目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save axios</span><br></pre></td></tr></table></figure><p>这个命令执行完，你会发现，此项目的<code>node_modules</code>文件夹中多了一个<code>axios</code>模块，且在项目的<code>package.json</code>文件中的<code>dependencies</code>括号内，多了<code>&quot;axios&quot;: &quot;^0.19.2&quot;</code>这一行。现在就可以在项目中使用axios了。</p><p><code>package.json</code>文件中的<code>dependencies</code>和<code>devDependencies</code>这两部分都表示项目依赖的模块，不同的是，<code>dependencies</code>代表<strong>生产环境</strong>需要依赖的模块，<code>devDependencies</code>代表<strong>开发</strong>时需要依赖的模块。</p><p>把模块添加到<code>devDependencies</code>下的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev &lt;模块名&gt;</span><br></pre></td></tr></table></figure><h4 id="常用的npm-install命令"><a href="#常用的npm-install命令" class="headerlink" title="常用的npm install命令"></a>常用的npm install命令</h4><ul><li><p>查看npm install命令的使用帮助：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -h</span><br></pre></td></tr></table></figure></li><li><p>全局安装模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g &lt;模块名&gt;</span><br></pre></td></tr></table></figure><p>安装到这个命令<code>npm config set prefix &quot;...&quot;</code>设置的目录下的<code>node_modules</code>文件夹中。</p></li><li><p>局部安装模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;模块名&gt;</span><br><span class="line">npm install --save &lt;模块名&gt;</span><br></pre></td></tr></table></figure><p>这两个命令效果一样，都是安装到当前项目下的<code>node_modules</code>文件夹中，同时添加到<code>package.json</code>文件中的<code>dependencies</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev &lt;模块名&gt;</span><br></pre></td></tr></table></figure><p>这个命令是安装到当前项目下的<code>node_modules</code>文件夹中，同时添加到<code>package.json</code>文件中的<code>devDependencies</code>。</p></li><li><p>下载项目依赖模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>这个命令会下载<code>package.json</code>文件中的<code>dependencies</code>和<code>devDependencies</code>中的所有依赖模块。<br>这个使用场景一般是git clone了项目，项目文件中通常不会包含依赖模块，依赖模块都写在<code>package.json</code>文件里，需要自己手动npm install下载一下。【和后台项目初次启动前先maven update一样</p></li><li><p>指定版本号下载模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install [-g|--save|--save-dev] &lt;模块名&gt;@&lt;版本号&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="打包vue项目"><a href="#打包vue项目" class="headerlink" title="打包vue项目"></a>打包vue项目</h3><p>进入要打包的项目目录，cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>打包完成后会打印<code>Build complete</code>。可以发现，项目目录下多出一个dist文件夹。</p><img src="/2020/02/19/vue-env-build/dist.png" class="" title="dist"><p>这个dist文件夹中就是项目的所有静态文件（做过混淆的），可以用nginx部署，nginx的配置文件基本是这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8080;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    root &#x2F;hellodemo&#x2F;dist; # dist文件所在目录</span><br><span class="line">    index index.html;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">      # 此处的 @router 实际上是引用下面的转发，否则在 Vue 路由刷新时可能会抛出 404</span><br><span class="line">      try_files $uri $uri&#x2F; @router;</span><br><span class="line">      # 请求指向的首页</span><br><span class="line">      index index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 由于路由的资源不一定是真实的路径，无法找到具体文件</span><br><span class="line">    # 所以需要将请求重写到 index.html 中，然后交给真正的 Vue 路由处理请求资源</span><br><span class="line">    location @router &#123;</span><br><span class="line">      rewrite ^.*$ &#x2F;index.html last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 这里配置后台接口地址转发，假设后台服务的IP端口是10.1.75.23:18081</span><br><span class="line">    # 比方说，前端“添加用户”的请求地址是http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;user&#x2F;add，就会被转发到 http:&#x2F;&#x2F;10.1.75.23:18081&#x2F;user&#x2F;add</span><br><span class="line">    location &#x2F;api&#x2F; &#123;</span><br><span class="line">          # 后端的真实接口</span><br><span class="line">          proxy_pass http:&#x2F;&#x2F;10.1.75.23:18081&#x2F;;</span><br><span class="line">          proxy_redirect off;</span><br><span class="line">          proxy_set_header Host $host;</span><br><span class="line">          proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">          proxy_set_header   Cookie $http_cookie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署完后浏览器输入localhost:8080就能跳到项目主页了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天依激励法</title>
      <link href="/2020/02/18/tianyi-fight/"/>
      <url>/2020/02/18/tianyi-fight/</url>
      
        <content type="html"><![CDATA[<p>爱天依就更要好好学习！</p><img src="/2020/02/18/tianyi-fight/tianyi_fight.jpg" class="" title="天依激励法">]]></content>
      
      
      
        <tags>
            
            <tag> 洛天依 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/12/hello-world/"/>
      <url>/2020/02/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
