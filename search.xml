<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot AOP 实践与原理</title>
      <link href="/2020/03/02/springboot-aop/"/>
      <url>/2020/03/02/springboot-aop/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇博客先从AOP的代码编写讲起，接着介绍AOP的实现原理，其中包括动态代理的概念，最后介绍Spring中可以直接用的AOP注解。</p><h2 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h2><h3 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建切面类"><a href="#创建切面类" class="headerlink" title="创建切面类"></a>创建切面类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//声明这是一个组件</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//声明这是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义切入点"><a href="#定义切入点" class="headerlink" title="定义切入点"></a>定义切入点</h3><p>切入点就是你要在哪个包下的哪个类的哪个方法执行切面逻辑，或者说指定切入哪里。<strong>Spring AOP的切入点只能是方法。</strong><br>可以在一个切面类中定义多个切入点，再给每个切入点指定不同的Advice方法（Advice方法介绍见下一节）。<br>定义切入点有两种方式：</p><ol><li>用execution表达式定义切入点</li><li>用自定义注解定义切入点</li></ol><h4 id="用execution表达式定义切入点"><a href="#用execution表达式定义切入点" class="headerlink" title="用execution表达式定义切入点"></a>用execution表达式定义切入点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.sample.service.impl..*.*(..)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例表示在com.sample.service.impl包（含子包）下的所有类的所有方法切入。下面把这个示例拆解看看execution表达式的格式。</p><table><thead><tr><th align="left">符号</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">第一个”*”符号</td><td align="left">表示返回值的类型任意</td></tr><tr><td align="left">com.sample.service.impl</td><td align="left">要切入的类所在包名</td></tr><tr><td align="left">包名后面的”..”</td><td align="left">表示当前包及子包</td></tr><tr><td align="left">第二个”*“符号</td><td align="left">表示类名，*即任意类，也可指定具体的类，或带前后缀的类，如 *Service</td></tr><tr><td align="left">.*(..)</td><td align="left">表示任何方法名，括号表示参数，两个点表示任何参数类型</td></tr></tbody></table><p>如何使用这个切入点？示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)<span class="comment">// 这个注解以及它所修饰的方法的介绍见下一节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用自定义注解定义切入点"><a href="#用自定义注解定义切入点" class="headerlink" title="用自定义注解定义切入点"></a>用自定义注解定义切入点</h4><p>假设已有自定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME )</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义切入点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.example.demo.aop.Log)"</span>) <span class="comment">// 自定义注解的限定类名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例表示切入所有加了<code>@Log</code>属性的方法，比如下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"><span class="meta">@Log</span>(<span class="string">"添加用户操作"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user/add"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"add"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个切入点的方法和用“execution表达式”定义的切入点没有区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)<span class="comment">// 这个注解以及它所修饰的方法的介绍见下一节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这只是“自定义注解”定义的切入点的其中一种使用方式，这种使用方式的一个缺点是不能访问自定义注解<code>@Log</code>的value属性。<br>另一种使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(log)"</span>) <span class="comment">// 括号里的名字和注解参数名必须相同</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint, Log log)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 方法逻辑...</span></span><br><span class="line">     System.out.println(log.value()); <span class="comment">// 可以访问注解属性值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种使用方式的区别就是，切入点直接写在<code>@Before</code>注解中，不需要再用pointcut()方法定义切入点</p><p>和execution表达式相比，用自定义注解定义切入点，可以灵活安排切入的方法（想切哪里注解就加在哪里），且通过自定义注解的属性，在切面类中也能了解到被切方法的业务逻辑，若要在切面类中统一打印被切方法的日志，这点很好用。</p><h3 id="根据业务逻辑编写Advice方法"><a href="#根据业务逻辑编写Advice方法" class="headerlink" title="根据业务逻辑编写Advice方法"></a>根据业务逻辑编写Advice方法</h3><p>Advice，有翻译为“增强处理”，也有翻译为“通知”，本质含义就是要执行的切面逻辑，如要在每个方法开始前打印入参日志，就可以编写Before类型的Advice方法，如要在每个方法抛出异常后统一处理，就可以编写AfterThrowing类型的Advice方法。Advice一共有五种类型：</p><ul><li>Before</li><li>After</li><li>AfterReturning</li><li>AfterThrowing</li><li>Around</li></ul><p>这些类型的共同特点：</p><ul><li>所有类型的注解都有两个属性：value、argNames。value属性用于指定切入点，argNames属性可以用来访问目标方法的入参</li><li>除<code>Around</code>之外，其他四种类型的方法的连接点参数都只能是JoinPoint，不能是ProceedingJoinPoint（ProceedingJoinPoint是JoinPoint的子类）</li><li>只有<code>Around</code>方法能改变目标方法的入参和返回值</li></ul><p>下面分别介绍这五种类型的特点和使用方法。</p><h4 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h4><p>在目标方法执行前织入，不能访问目标方法的返回值，可选参数有JoinPoint。<br><code>@Before</code>注解属性：value、argNames</p><blockquote><p>JoinPoint简单介绍：<br>JoinPoint参数不必须，但需要时必须作为第一个参数！<br>常用方法有：<br>Object[] getArgs：返回目标方法的参数<br>Signature getSignature：返回目标方法的签名(含方法名和参数表)</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"============before============"</span>);</span><br><span class="line">    System.out.println(<span class="string">"目标方法名为:"</span> + joinPoint.getSignature().getName()); <span class="comment">// 打印方法名add</span></span><br><span class="line">    System.out.println(<span class="string">"目标方法所属类的类名:"</span> + joinPoint.getSignature().getDeclaringTypeName());<span class="comment">// 打印全限定类名com.example.demo.controller.UserController</span></span><br><span class="line">    <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"第"</span> + (i+<span class="number">1</span>) + <span class="string">"个参数为:"</span> + args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="After"><a href="#After" class="headerlink" title="After"></a>After</h4><p>在目标方法结束后织入，不管目标方法如何结束（正常还是异常），它都会被织入，可选参数有JoinPoint。<br><code>@After</code>注解和<code>@Before</code>注解属性相同：value、argNames<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"============after============"</span>);</span><br><span class="line">    <span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AfterReturning"><a href="#AfterReturning" class="headerlink" title="AfterReturning"></a>AfterReturning</h4><p>在目标方法正常完成后被织入，抛出异常了不织入，可选参数有JoinPoint和Object（目标方法的返回值）。<br><code>@AfterReturning</code>注解除了value、argNames这两个属性外，还有一个属性：</p><ul><li>returning：指定一个返回值形参名，可以通过该形参名来访问目标方法的返回值，但不可修改目标方法的返回值</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(pointcut = <span class="string">"pointcut()"</span>, returning = <span class="string">"returnObject"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(JoinPoint joinPoint, Object returnObject)</span> </span>&#123; <span class="comment">// 返回值的形参名与注解中的保持一致</span></span><br><span class="line">    System.out.println(<span class="string">"============afterReturning============"</span>);</span><br><span class="line">    <span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line">    <span class="comment">// 访问目标方法的返回值</span></span><br><span class="line">    System.out.println(<span class="string">"返回值："</span> + returnObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AfterThrowing"><a href="#AfterThrowing" class="headerlink" title="AfterThrowing"></a>AfterThrowing</h4><p>在目标方法抛出异常时织入，正常完成不织入，可选参数有JoinPoint和Throwable（目标方法抛出的异常）。<br><code>@AfterThrowing</code>注解除了value、argNames这两个属性外，还有一个属性：</p><ul><li>throwing：指定一个异常形参名，形参可用于访问目标方法抛出的异常</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(throwing = <span class="string">"e"</span>, pointcut = <span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable e)</span> </span>&#123; <span class="comment">// 异常的形参名与注解中的保持一致</span></span><br><span class="line">System.out.println(<span class="string">"============afterThrowing============"</span>);</span><br><span class="line"><span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line"><span class="comment">// 打印异常</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这个AfterThrowing只能用在打印异常信息，不能对抛出的异常做更多处理，也不能针对异常来改变目标方法的返回值。<br>想要根据异常信息修改目标方法返回值，只能用下面讲的Around。</p><h4 id="Around"><a href="#Around" class="headerlink" title="Around"></a>Around</h4><ul><li>可以在执行目标方法前织入，也可以在执行后织入</li><li>可以决定目标方法在什么时候执行，如何执行，可以完全阻止目标方法的执行</li><li>可以修改目标方法的参数值，也可以修改目标方法的返回值</li><li>至少包含一个参数，且第一个参数必须是ProceedingJoinPoint</li><li>在方法体内，调用ProceedingJoinPoint的proceed()方法才会执行目标方法。如果方法体内没有调用这个proceed()方法，则目标方法不会执行</li><li>最后必须把获得的目标方法的返回值，作为@Around方法的返回值return回去(因为如果无返回值的话，将不会继续执行目标方法)</li></ul><p><code>@Around</code>注解属性：value、argNames</p><p>第一个示例，没修改目标方法入参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">          <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">          Object[] args = joinPoint.getArgs();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">              System.out.println(<span class="string">"第"</span> + (i+<span class="number">1</span>) + <span class="string">"个参数为:"</span> + args[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 返回值</span></span><br><span class="line">          Object re = joinPoint.proceed();</span><br><span class="line">          <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第二个示例，修改了目标方法入参（入参为基本类型和String）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">        <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 修改参数值</span></span><br><span class="line">            args[i] += <span class="string">"updated"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        Object re = joinPoint.proceed(args); <span class="comment">// 这里要把修改后的args作为proceed方法的参数</span></span><br><span class="line">        <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个示例，修改了目标方法入参（入参为对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">        <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        Object param = args[<span class="number">0</span>];</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">if</span>(param <span class="keyword">instanceof</span> Person)</span><br><span class="line">        person = (Person) param;</span><br><span class="line">        person.setAddress(<span class="string">"address"</span>); <span class="comment">// 修改参数对象属性</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        Object re = joinPoint.proceed(); <span class="comment">// 这里不用再把修改后的args作为proceed方法的参数</span></span><br><span class="line">        <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，关于Around中的异常捕获：</p><ol><li>只有从目标方法中抛出的异常才会被捕获，若目标方法内自己try-catch异常了没有抛出，就不会触发Around的异常捕获</li><li>Around中处理异常，返回的响应类型必须和目标方法声明的一致，即必须是目标方法的返回类及其子类，否则会出现强制转换报错</li></ol><h2 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h2><p>AOP的全称是Aspect Oriented Programming，面向切面编程，它是通过动态代理技术，将Aspect方法中的逻辑完整织入到切入点中。下面开始先介绍静态代理（即设计模式中的代理模式），再介绍动态代理，最后再说说Spring是怎么用动态代理实现AOP的。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>在设计模式中，常用到代理模式，它一般由一个接口和这个接口的两个实现类组成。<br>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"message: "</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProxy</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Service service; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceProxy</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">doBefore();</span><br><span class="line"><span class="keyword">this</span>.service.printMessage(msg);</span><br><span class="line">doAfter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行代理方法前的处理（前置处理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========proxy start========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行完代理方法后的处理（后置处理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========proxy end========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代理类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">ServiceProxy proxy = <span class="keyword">new</span> ServiceProxy(service);</span><br><span class="line">proxy.printMessage(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，静态代理需要我们自己编写代理类ServiceProxy，在它的printMessage方法中加上前置处理和后置处理。而动态代理，就不用我们自己写代理类，就能把我们指定的前置后置处理方法加到被代理方法的前后流程中。下面介绍动态代理的实现。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理，简单地说，就是不用自己写代理类，而是在运行时自动生成代理类和代理类对象。<br>接口Service和实现类ServiceImpl代码同上，不再赘述。</p><p>动态代理类：<br>作用：在运行时生成被代理类对象，规定执行被代理对象的目标方法的流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object _obj = <span class="keyword">null</span>; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object _obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>._obj = _obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   proxy 代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   method 被代理对象的目标方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   args 被代理对象的目标方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  被代理对象的目标方法的执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// 此处可以编写前置处理...</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(_obj, args); <span class="comment">// 反射执行被代理对象的目标方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用动态代理类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(service); <span class="comment">// 放入被代理对象</span></span><br><span class="line"><span class="comment">// 使用JDK中的Proxy类生成Service类的代理对象</span></span><br><span class="line">Service proxy = (Service) Proxy.newProxyInstance(service.getClass().getClassLoader(),</span><br><span class="line">service.getClass().getInterfaces(), dynamicProxy); </span><br><span class="line">proxy.printMessage(<span class="string">"hello"</span>); <span class="comment">// 这一步其实就是执行dynamicProxy.invoke方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码很简单地实现了动态代理：自己不用写Service类的代理类，运行时才生成Service类的代理类和代理对象。</p><p>当然AOP的实现没有这么简单，它还需要把切面类织入到切入点中。</p><h3 id="AOP的动态代理"><a href="#AOP的动态代理" class="headerlink" title="AOP的动态代理"></a>AOP的动态代理</h3><p>以下代码可以简单实现AOP逻辑。<br>接口Service和实现类ServiceImpl代码同上，不再赘述。</p><p>切面接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aspect</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">useAround</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectImpl</span> <span class="keyword">implements</span> <span class="title">Aspect</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doBefore========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAfter========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAfterReturning========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAfterThrowing========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAround Start========"</span>);</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">System.out.println(<span class="string">"========doAround End========"</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">useAround</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object _obj = <span class="keyword">null</span>; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Aspect _aspect; <span class="comment">// 切面类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object _obj, Aspect _aspect)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>._obj = _obj;</span><br><span class="line"><span class="keyword">this</span>._aspect = _aspect;</span><br><span class="line">Object proxy = Proxy.newProxyInstance(_obj.getClass().getClassLoader(), _obj.getClass().getInterfaces(), <span class="keyword">this</span>); <span class="comment">// 代理对象</span></span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment"> *            代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> *            被代理对象的目标方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> *            被代理对象的目标方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被代理对象的目标方法的执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">Object result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">_aspect.doBefore();</span><br><span class="line"><span class="keyword">if</span> (_aspect.useAround()) &#123;</span><br><span class="line">result = _aspect.doAround(_obj, method, args);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = method.invoke(_obj, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">hasException = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_aspect.doAfter();</span><br><span class="line"><span class="keyword">if</span> (hasException) &#123;</span><br><span class="line">_aspect.doAfterThrowing();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">_aspect.doAfterReturning();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用动态代理类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy();</span><br><span class="line">Service proxy = (Service) dynamicProxy.getProxy(service, <span class="keyword">new</span> AspectImpl());</span><br><span class="line">proxy.printMessage(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doBefore&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAround Start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">message: hello</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAround End&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAfter&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAfterReturning&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>可以看出，以上代码成功把切面类AspectImpl的逻辑织入到了被代理对象的目标方法中。因此，Spring AOP的原理就是，Spring中有一个类似于动态代理类DynamicProxy的类，帮我们把切面类织入到切入点了。<br>Spring的动态代理机制：</p><ol><li>JDK动态代理。只能代理实现了接口的类，是Spring的首选机制。上面代码所展现的就是这个机制。</li><li>CGLIB动态代理。不要求被代理类必须实现接口，但不能代理final类。当被代理类没有实现接口时，Spring就用这个机制。</li></ol><h2 id="Spring中已实现的AOP"><a href="#Spring中已实现的AOP" class="headerlink" title="Spring中已实现的AOP"></a>Spring中已实现的AOP</h2><p>Spring中有一些已经写好的切面逻辑，可以直接拿来用。</p><h3 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h3><p>用<code>@ControllerAdvice</code>注解修饰的类，可以对Controller中用<code>@RequestMapping</code>修饰的方法做切面处理，最常用的是统一处理Controller方法抛出的异常。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span> <span class="comment">// 响应体是json格式就必须加这个注解</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>) // 指定抛出的异常类型</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">JSONObject</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123; <span class="comment">// 在这个方法中写抛出异常后的处理</span></span><br><span class="line">System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">json.put(<span class="string">"code"</span>, <span class="string">"9999"</span>);</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"System Error"</span>);</span><br><span class="line"><span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例是指，当Conrtroller方法中抛出异常时，统一返回<strong>{“msg”:”System Error”,”code”:”9999”}</strong>响应体。<br>若需要统一跳到某个页面，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>) // 指定抛出的异常类型</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ModelAndView</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123; <span class="comment">// 在这个方法中写抛出异常后的处理</span></span><br><span class="line">    System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">//指定错误页面的模板页</span></span><br><span class="line">        mav.setViewName(<span class="string">"error"</span>);</span><br><span class="line">        mav.addObject(<span class="string">"code"</span>, ex.getCode());</span><br><span class="line">        mav.addObject(<span class="string">"msg"</span>, ex.getMsg());</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：当AOP切面和@ControllerAdvice同时存在，且AOP切面里也会统一处理Controller抛出的异常，@ControllerAdvice就不一定会执行。请看下面的例子。<br>AOP切面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(log)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint, Log log)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">            <span class="comment">// 返回值</span></span><br><span class="line">            Object re = joinPoint.proceed();</span><br><span class="line">            <span class="keyword">if</span>(re <span class="keyword">instanceof</span> JSONObject)</span><br><span class="line">            result = (JSONObject) re;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            result.put(<span class="string">"code"</span>, <span class="string">"9998"</span>);</span><br><span class="line">            result.put(<span class="string">"msg"</span>, <span class="string">"error"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ControllerAdvice的修饰类同上，不再赘述。<br>运行时发现，目标方法抛出异常时，会统一返回<strong>{“msg”:”error”,”code”:”9998”}</strong>，而不会返回@ControllerAdvice中的<strong>{“msg”:”System Error”,”code”:”9999”}</strong>。原因就是AOP中已经处理好异常了。<br>若仍然想把异常交给@ControllerAdvice处理，AOP切面可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(log)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint, Log log)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">            <span class="comment">// 返回值</span></span><br><span class="line">            Object re = joinPoint.proceed();</span><br><span class="line">            <span class="keyword">if</span>(re <span class="keyword">instanceof</span> JSONObject)</span><br><span class="line">            result = (JSONObject) re;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e; <span class="comment">// 把异常抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，目标方法抛出异常时，会统一返回@ControllerAdvice中的<strong>{“msg”:”System Error”,”code”:”9999”}</strong>。原因就是AOP中把异常抛出了。</p><h4 id="404异常处理"><a href="#404异常处理" class="headerlink" title="404异常处理"></a>404异常处理</h4><p>没有什么特殊配置的情况下，Spring Boot遇到404就会自动跳到Spring Boot的error页面。若想要自己处理404异常，可以使用@ControllerAdvice。顺便一提，由于接口不存在，所以404异常肯定不会被AOP切面处理。<br>要处理404异常，必须在配置文件中加上：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出现错误时, 直接抛出异常</span></span><br><span class="line"><span class="attr">spring.mvc.throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 不要为我们工程中的资源文件建立映射</span></span><br><span class="line"><span class="attr">spring.resources.add-mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这个配置一定要加，否则Spring Boot总是会帮我们处理404异常，而不会进入我们定义的方法中。<br>然后就是在@ControllerAdvice中处理404，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">JSONObject</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line"><span class="keyword">if</span>(ex <span class="keyword">instanceof</span> NoHandlerFoundException) &#123; <span class="comment">// 404异常</span></span><br><span class="line">json.put(<span class="string">"code"</span>, <span class="string">"9997"</span>);</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"No Found"</span>);</span><br><span class="line"><span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line">json.put(<span class="string">"code"</span>, <span class="string">"9999"</span>);</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"System Error"</span>);</span><br><span class="line"><span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以发现，访问不存在的URI时，会统一返回<strong>{“msg”:”No Found”,”code”:”9997”}</strong>。</p><h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h3><p>这个注解帮你实现了数据库事务逻辑，尤其是事务回滚。<br>举个例子，删除用户时，要把用户关联的权限一起删除，当删除用户成功但删除权限不成功时，应该把删除用户的操作回滚，使得数据一致。<br>服务层示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaintainService</span> <span class="keyword">implements</span> <span class="title">IMaintainService</span></span>&#123;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">// 事务回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，当deletePersonPrivilege方法抛出异常时，deleteById方法会被回滚，即数据库中用户和用户权限依然存在，说明回滚成功。另外，回滚成功后，依然会进入AOP切面中的异常捕获。<br>下面介绍<code>@Transactional</code>注解使用的注意点。</p><h4 id="Transactional只能用在public方法上"><a href="#Transactional只能用在public方法上" class="headerlink" title="@Transactional只能用在public方法上"></a>@Transactional只能用在public方法上</h4><p>Spring在回滚前会检查方法修饰符是不是public，是才回滚。</p><h4 id="Transactional的rollbackFor属性"><a href="#Transactional的rollbackFor属性" class="headerlink" title="@Transactional的rollbackFor属性"></a>@Transactional的<strong>rollbackFor</strong>属性</h4><p>默认情况下，只有抛出Error类，或RuntimeException类及其子类的异常，Spring才会回滚。其他类型的异常不会回滚。<br>若需要在抛出其他异常时回滚，可以指定<strong>rollbackFor</strong>属性，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor=Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">deletePerson</span>(<span class="title">int</span> <span class="title">personId</span>) </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，只有抛出Exception类及其子类的异常，Spring才会回滚。</p><h4 id="自调用问题"><a href="#自调用问题" class="headerlink" title="自调用问题"></a>自调用问题</h4><p>上面的示例，<code>@Transactional</code>注解修饰的方法会直接被Controller层接口调用，这种情况下都能回滚成功。但也有一些特殊情况。<br>情况1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，<code>@Transactional</code>不会生效。应改为下面这样才能生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 异步调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 异步调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种有异步线程存在的情况下，<code>@Transactional</code>无论加在哪个方法都不会生效。<br>因此，只有把<code>@Transactional</code>注解加在直接被外部调用的方法才能生效。</p>]]></content>
      
      
      <categories>
          
          <category> 后台 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的时间类型转换</title>
      <link href="/2020/02/25/java-date-trans/"/>
      <url>/2020/02/25/java-date-trans/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java中表示时间有三种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String dateStr = <span class="string">"2020-01-01 15:00:11"</span>; <span class="comment">// String类型</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(); <span class="comment">// Date类型</span></span><br><span class="line"><span class="keyword">long</span> time = date.getTime(); <span class="comment">// long类型</span></span><br></pre></td></tr></table></figure><p>　　这三种类型的不同在于，String类型不带时区信息，Date和long类型会带时区信息。开发项目时，接口参数的时间字段最好用long类型表示，这样发送方和接收方收到的时间会一致。用String类型也能一致，但双方可能都要做格式转换。用Date类型做接口参数时，接收方和收到的值可能与发送方的不一致，不适合验签。</p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><h3 id="Date转String"><a href="#Date转String" class="headerlink" title="Date转String"></a>Date转String</h3><p>看一下电脑上的时间，得知当前时间是8时区的2020-02-25 15:41:21（系统时区是8时区）。<br>按照<code>yyyy-MM-dd HH:mm:ss</code>的格式打印当前时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date(); <span class="comment">// 当前时间</span></span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>; <span class="comment">// 注意，月份M大写，分钟m小写</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">System.out.println(sdf.format(d)); <span class="comment">// 2020-02-25 15:41:21</span></span><br></pre></td></tr></table></figure><p>打印结果和电脑上显示的一致。</p><h4 id="转换时考虑时区"><a href="#转换时考虑时区" class="headerlink" title="转换时考虑时区"></a>转换时考虑时区</h4><p>若想知道当前时间对应的GMT0时间是多少，就要在转换时加上时区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date(); <span class="comment">// 当前时间</span></span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">String timezone = <span class="string">"GMT+0"</span>; <span class="comment">// 时区</span></span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">System.out.println(sdf.format(d)); <span class="comment">// 2020-02-25 07:41:21</span></span><br></pre></td></tr></table></figure><p>打印结果<strong>2020-02-25 07:41:21(GMT0)</strong>和当前时间<strong>2020-02-25 15:41:21(GMT8)</strong>可以对应。</p><h3 id="Date转long"><a href="#Date转long" class="headerlink" title="Date转long"></a>Date转long</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="keyword">long</span> time = date.getTime();</span><br></pre></td></tr></table></figure><h2 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h2><h3 id="long转Date"><a href="#long转Date" class="headerlink" title="long转Date"></a>long转Date</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">Date d = <span class="keyword">new</span> Date(currentTimeMillis);</span><br></pre></td></tr></table></figure><h3 id="long转String"><a href="#long转String" class="headerlink" title="long转String"></a>long转String</h3><p>先long转Date，再Date转String。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String转Date"><a href="#String转Date" class="headerlink" title="String转Date"></a>String转Date</h3><p>若已知时间字符串”2020-02-25 10:44:05”是8时区，系统也是8时区，那么转换时可以简单的写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"2020-02-25 10:44:05"</span>;</span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>; <span class="comment">// 时间字符串的格式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Tue Feb 25 10:44:05 CST 2020</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>10:44:05</strong>和时间字符串<strong>2020-02-25 10:44:05(GMT8)</strong>一致。</p><blockquote><p>CST时间：China Standard Time，中国标准时间，等于GMT8</p></blockquote><h4 id="转换时考虑时区-1"><a href="#转换时考虑时区-1" class="headerlink" title="转换时考虑时区"></a>转换时考虑时区</h4><p>但如果已知”2020-02-25 10:44:05”这个字符串是0时区，那么就要指定时区转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"2020-02-25 10:44:05"</span>;</span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>; <span class="comment">// 时间字符串的格式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">String timezone = <span class="string">"GMT+0"</span>; <span class="comment">// 时间字符串的时区</span></span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Tue Feb 25 18:44:05 CST 2020</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>18:44:05</strong>和时间字符串<strong>2020-02-25 10:44:05(GMT0)</strong>一致。</p><h4 id="复杂格式的时间字符串转换"><a href="#复杂格式的时间字符串转换" class="headerlink" title="复杂格式的时间字符串转换"></a>复杂格式的时间字符串转换</h4><p>处理复杂的时间字符串，如<strong>PDT时间</strong>：</p><blockquote><p>PDT时间：Pacific Daylight Time，太平洋夏季时间，等于UTC-7，UTC=GMT0，因此PDT=GMT8-15<br>PST时间：Pacific Standard Timee，太平洋标准时间，等于PDT-1，因此PST=GMT8-16</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"03:00:14 Jun 13, 2019 PDT"</span>; <span class="comment">// pdt时间2019-06-13 03:00:14</span></span><br><span class="line">String format = <span class="string">"HH:mm:ss MMM dd, yyyy z"</span>; <span class="comment">// z表示时区</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format, Locale.ENGLISH); <span class="comment">// 当字符串中有英文单词时要加上Locale参数</span></span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Thu Jun 13 18:00:14 CST 2019</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>18:00:14</strong>和时间字符串<strong>2019-06-13 03:00:14(PDT)</strong>一致。</p><p>处理<strong>UTC时间</strong>（UTC=GMT0）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"2019-04-24T02:30:00"</span>;</span><br><span class="line">String format = <span class="string">"yyyy-MM-dd'T'HH:mm:ss"</span>; <span class="comment">// 时间格式，注意T带引号</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">String timezone = <span class="string">"GMT+0"</span>; <span class="comment">// 时间字符串的时区</span></span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Wed Apr 24 10:30:00 CST 2019</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>10:30:00</strong>和时间字符串<strong>2019-04-24 02:30:00(UTC)</strong>一致。</p><h3 id="String转long"><a href="#String转long" class="headerlink" title="String转long"></a>String转long</h3><p>先String转Date，再Date转long。</p>]]></content>
      
      
      <categories>
          
          <category> 后台 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法图解》笔记</title>
      <link href="/2020/02/23/grokking-algorithms-note/"/>
      <url>/2020/02/23/grokking-algorithms-note/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　《算法图解》这本书真的非常好懂，它结合图画，对算法基础知识讲得很透，把“每一步要怎么做”和“为什么这样做”都交代了。这些知识以前在学校也学习过，但那时候只记住算法每一步怎么做，时间复杂度也是硬背的，根本没去理解背后的原因。这样的后果就是学完就忘。这本书就很适合我这种对算法稍微懂点但又不是很懂的人，它帮我把以前的疑惑都解开了。但它有个局限性就是，只讲基础，对稍微难点的内容都是一笔带过，只能靠个人去学，真正的入门书。<br>　　因为作者就像聊天似的教算法，图画也多，所以这本书的知识点比较散，这篇博客就是将我从这本书学到的知识点记录下来。</p><h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2><ul><li>大O表示法体现的是随着元素数量n的增多，操作次数的增长趋势。如O(logn)（二分查找）的增长趋势明显比0(n)（简单查找）要慢得多，因此可以说二分查找比简单查找更好</li><li>大O表示法一般是该算法在最糟情况下的速度，但算法也有平均情况（也是最优情况）下的速度。如快速排序最糟O(n^2)，平均O(nlogn)</li><li>大O表示法不含常量的原因：当元素数量很多时，常量对速度的影响可忽略不计</li><li>O(1)表示常量时间，含义是无论元素数量多少，所需时间都一样</li></ul><p><strong>注：</strong></p><ol><li>这本书里只讨论时间复杂度，没讲空间复杂度</li><li>logn就是log2n，即2的幂</li></ol><h2 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h2><ul><li>在内存方面：数组元素的内存地址是相邻的，链表元素的内存地址不用相邻，链表的每个元素中都会存放下一个元素的内存地址</li><li>在查找方面：链表只能顺序查找，而数组可以随机访问到任一元素，因此说数组的查找效率更好</li><li>在插入和删除方面：链表的插入和删除只是改变某个元素存储的下一个元素的地址，数组的插入要重新分配内存，删除时要把后面的元素往前移</li><li>链表的插入和删除都是O(1)，这不包括“查找插入/删除位置”的时间</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li>递归没有什么性能优势，只是让代码更清晰。可以用递归实现的也能用循环实现</li><li>每个递归都包含两个条件：递归条件–让函数调用自己的条件，基线条件–函数return的条件（即不再递归的条件）</li><li>每次递归调用都会加入到调用栈，占用内存，执行完就会从调用栈弹出</li></ul><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>　　在调用栈过高的情况下，可以写成尾递归的形式。尾递归就是手动把本次调用的计算结果作为递归函数的参数，这样在return时就直接return递归，而不是还要先处理递归结果再return。<br>　　下面以阶乘函数为例，展示递归和尾递归的不同写法：</p><p><strong>普通递归：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> n * fac(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尾递归：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fac2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">//第一次调用时t=1</span></span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> fac2(n - <span class="number">1</span>, n * t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　写成尾递归后，若编译器会自动帮你把尾递归代码优化就会很好用（jvm不会），否则需要你手动把尾递归代码优化了才会有节省栈内存的效果。尾递归可以优化的原因：每次递归都计算出了一个结果，上一次递归的结果就没必要保留，可以释放内存。</p><h2 id="分而治之（D-amp-C）"><a href="#分而治之（D-amp-C）" class="headerlink" title="分而治之（D&amp;C）"></a>分而治之（D&amp;C）</h2><ul><li><p>分而治之是一种递归式的问题解决方法。思路是缩小问题范围，思考解决小问题的方法，能解决小问题的方法也适用于大问题。欧几里得算法就是这个思路</p><blockquote><p>两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数</p></blockquote></li><li><p>工作过程：a.找出基线条件，这个条件必须尽可能简单；b.缩小问题的规模，使其符合基线条件</p></li><li><p>要处理的对象是数组时，基线条件一般是数组为空或只含一个元素</p></li></ul><p><strong>举例：</strong>求数组[1,2,3,4,5]的总和，基线条件为：当数组只有一个元素时数组总和就等于这个元素。做法就是：不断挑出一个元素，使数组规模变小，求(挑出的元素+数组剩余元素总和)的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span>[] aArr = <span class="keyword">new</span> <span class="keyword">int</span>[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">aArr[i - <span class="number">1</span>] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">0</span>] + sum(aArr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码只是为了说明“分而治之”的思想，一般情况下求数组总和还用不到递归。</p><p><strong>注：</strong>这本书说的“分而治之”的概念是其他一些教材说的“减而治之”。一些人把“减而治之”看作是“分而治之”的一种特殊情况，作者这样写也没错。</p><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><ul><li>由数组和散列函数组成，通过散列函数将要存储的值计算成数组索引，值就放在索引处</li><li>良好的散列函数会尽量覆盖数组的每个位置，即每个值都放在不同位置</li></ul><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul><li>只适用于有序数列</li><li>运行时间为O(logn)，就是把一串数字对半分，直到只剩一个数字的次数</li><li>操作过程也运用了递归思想。基线条件：数组中间元素与目标相同；递归条件：当中间的元素不对，对一半数组继续二分查找</li></ul><p><strong>循环式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> high = n.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> i = n[mid];</span><br><span class="line"><span class="keyword">if</span> (i == target)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &lt; target) &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[] n, <span class="keyword">int</span> target, <span class="keyword">int</span> high, <span class="keyword">int</span> low)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> num = n[mid];</span><br><span class="line"><span class="keyword">if</span> (num == target)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num &lt; target) &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> binarySearch2(n, target, high, low);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li>重复从数组中挑出最大或最小的元素放入新数组，直到原数组没有元素了</li><li>运行时间为0(n^2)，从n个元素中挑最大或最小（相当于把每个元素检查一遍），要挑n次，所以是n*n</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li>过程：选出一个基准值pivot，比基准值小的数作为一个子数组a1，比基准值大的数作为子数组a2，qsort(a1) + pivot + qsort(a2)就是结果</li><li>平均情况下运行时间是O(nlogn)，即<strong>随机选取基准值</strong>，子数组a1和a2的元素个数基本是原数组的一半，调用栈高为logn，每一层栈要处理的元素数是n，所以是n*logn</li><li>最糟情况下运行时间是O(n^2)，即<strong>选取的基准值是最大或最小数</strong>，子数组a1和a2中总有一个为空，此时调用栈高为n，每一层栈要处理的元素数是n，所以是n*n</li></ul><p><strong>附：</strong>合并排序（Merge Sort）<br>　　合并排序就是把数组对半分，再递归把子数组对半分直到只有一个元素（栈高度logn），每一次对半分好后通过比较两个子数组的元素合并为一个有序数组（操作元素数n），合并排序的平均和最糟情况都是0(nlogn)</p><h2 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h2><ul><li><p>图的结构包含：节点(V)和边(E)</p></li><li><p>树是一种特殊的图：不存在子节点往父节点指的边</p></li><li><p>节点之间有严格的先后顺序的图，叫拓扑排序</p></li><li><p>非加权图找最短路径：广度优先搜索<br>广度优先搜索就是，从起点开始，判断走一步能到达的顶点中有没有终点，若没有，就判断走两步能到达的顶点中有没有终点。。。找到终点后，走的步数就是最短路径。广度优先搜索首先能判断是否能到达终点，其次求出到达终点的最短路径。运行时间O(V+E)。</p></li><li><p>加权图（不含负权边）找最短路径（即权重之和最小）：狄克斯特拉算法<br>狄克斯特拉算法的思路：</p><ol><li>从所在节点的相邻节点中，找出“最便宜”的节点，即到达此相邻节点的权重最小</li><li>到达上一步所述的“最便宜”的节点后，更新从起点到达该“最便宜”节点的相邻节点的权重和</li><li>重复这个过程，直到对图中的每个节点都这样做了</li><li>计算最终路径的权重之和</li></ol></li><li><p>加权图（含负权边）找最短路径（即权重之和最小）：贝尔曼-福德算法</p></li><li><p>狄克斯特拉算法不适合用在带环的图</p></li></ul><h2 id="NP完全问题（NPC）"><a href="#NP完全问题（NPC）" class="headerlink" title="NP完全问题（NPC）"></a>NP完全问题（NPC）</h2><ul><li><p>无法快速找到最优解的就是NP完全问题</p></li><li><p><em>集合覆盖问题</em> 和 <em>旅行商问题</em> 就是典型的NP完全问题。背包问题属于集合覆盖问题。</p></li><li><p>解决NP完全问题，最好使用近似算法。贪婪算法就是近似算法的一种，无法得到最优解，但也接近最优解<br>贪婪算法，就是在限制的条件内，每一步都采取最优的做法。如背包问题中，每次都放入价值最高的物品，直到放不下为止</p></li><li><p>动态规划可以帮助找到NP完全问题的最优解</p><ul><li><p>可以使用动态规划的条件有：</p><ul><li>问题可以分解为互相独立的子问题。如背包问题中，放手机和放电脑彼此是独立的，谁先放都不会影响到另一个的价值</li><li>使用动态规划，问题的对象只有两种状态，有和没有，不能考虑“有一部分”这样的情况。如背包问题中，放一袋大米，只能考虑放整袋，不能考虑把米袋拆了只拿一部分</li></ul></li><li><p>动态规划的步骤</p><ol><li>绘制网格</li><li>决定网格的坐标轴代表什么。因为每个网格都代表一个子问题，所以要考虑怎么划分子问题。如对比两个字符串中相同字母的个数（求最长公共子序列问题），子问题就是一个字母一个字母的比较，所以坐标轴就是两个字符串</li><li>决定网格内的值代表什么。一般就是要优化的值。如求最长公共子序列问题，网格内的值就是相同字母的个数</li><li>决定网格内的值的计算公式。这个要通过经验和尝试来决定</li></ol></li></ul></li></ul><ul><li>NP完全问题的特征：<ol><li>元素数越多，算出最优解的时间越长</li><li>不能使用“分而治之”，必须考虑所有情况的问题</li><li>可以转化为集合覆盖问题或旅行商问题</li></ol></li></ul><p><strong>附：</strong>数学建模中其实有四类问题：P问题、NP问题、NP完全问题（NPC）、NP难问题（NPH），概念涉及到多项式，很复杂，这里不讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建vue开发环境</title>
      <link href="/2020/02/19/vue-env-build/"/>
      <url>/2020/02/19/vue-env-build/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为自己工作是搞后台的，偶尔要写下前端的时候，发现连前端项目怎么启动都忘记了= =||甚至不知道开发环境是怎么稀里糊涂地就搭好了。这种“学过的东西又还给网上教程”的感觉十分不愉快，但如果是还给自己写的教程，那…应该会庆幸还好写下来了吧╭(′▽`)╯。<br>这篇博客先简单地介绍“搭建vue开发环境”的4个步骤：</p><ol><li>安装Node.js</li><li>配置npm命令</li><li>初始化一个vue项目看看效果</li><li>编辑器VSCode的安装和配置</li></ol><p>说完“搭建环境”后，再顺便说说vue项目是怎么添加依赖模块和怎么打包部署的。</p><ul><li>给vue项目安装模块</li><li>打包vue项目</li></ul><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>进入官网下载：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 。安装好之后，在任一目录打开cmd输入命令测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>有打印版本号，类似于v13.5.0，就算安装成功。</p><h2 id="配置npm命令"><a href="#配置npm命令" class="headerlink" title="配置npm命令"></a>配置npm命令</h2><h3 id="设置依赖模块下载地址"><a href="#设置依赖模块下载地址" class="headerlink" title="设置依赖模块下载地址"></a>设置依赖模块下载地址</h3><p>开发vue项目时经常要安装项目所需模块（和后台项目下载jar包差不多），默认的下载地址 <a href="https://registry.npmjs.org/" target="_blank" rel="noopener">https://registry.npmjs.org/</a> 很慢，一般使用国内镜像地址 <a href="https://registry.npm.taobao.org/" target="_blank" rel="noopener">https://registry.npm.taobao.org/</a> 。<br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>执行成功后没有任何打印。</p><h3 id="设置全局模块和缓存目录"><a href="#设置全局模块和缓存目录" class="headerlink" title="设置全局模块和缓存目录"></a>设置全局模块和缓存目录</h3><p>在node.js的安装目录下，如<code>D:\Program Files\nodejs</code>，新建文件夹<code>node_cache</code>（名字可以任意起），这个文件夹是缓存目录。<br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> cache <span class="string">"D:\Program Files\nodejs\node_cache"</span></span><br></pre></td></tr></table></figure><p>全局模块目录就和本地maven仓库差不多。在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">"D:\Program Files\nodejs"</span></span><br></pre></td></tr></table></figure><p>这两个命令执行成功后没有任何打印。</p><h3 id="检查已设置内容"><a href="#检查已设置内容" class="headerlink" title="检查已设置内容"></a>检查已设置内容</h3><p>目前要自定义设置的就是这三个配置。要查看是否设置成功有两种方法：<br><strong>第一种：</strong><br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config ls</span><br></pre></td></tr></table></figure><p>结果会展示已自定义设置的内容：</p><img src="/2020/02/19/vue-env-build/npm_config_ls_result.png" class="" title="已设置内容"><p><strong>第二种：</strong><br>进入<code>C:\Users\个人目录</code>下，查看<code>.npmrc</code>文件，内容就是自定义配置项。</p><h3 id="其他有用的npm-config命令"><a href="#其他有用的npm-config命令" class="headerlink" title="其他有用的npm config命令"></a>其他有用的npm config命令</h3><ul><li><p>查看npm所有配置项（包括默认配置项）： npm config ls -l</p></li><li><p>修改某一个配置项： npm config set &lt;配置项名&gt; &lt;配置项值&gt;</p></li><li><p>查看某一个配置项值：npm config get &lt;配置项名&gt;</p></li><li><p>查看npm config命令的使用帮助： npm config -h</p></li></ul><h2 id="初始化一个vue项目"><a href="#初始化一个vue项目" class="headerlink" title="初始化一个vue项目"></a>初始化一个vue项目</h2><blockquote><p><strong>如果不打算自己创建项目，而是直接用已有的项目框架来开发，这一步可以跳过</strong></p></blockquote><h3 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h3><p>vue-cli叫做vue脚手架，它可以自动生成vue+webpack的项目模板。<br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure><p>这个命令还可以简写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g vue-cli</span><br></pre></td></tr></table></figure><p>这个命令表示<strong>全局</strong>安装vue-cli。执行过程中会打印一堆模块的名字，没看到<strong>ERROR</strong>之类的字眼就安装成功了。<br>若想验证是否安装成功，可以在cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue</span><br></pre></td></tr></table></figure><p>看到有vue命令的使用帮助就代表安装成功了。<br>另外，这个vue-cli模块安装到了刚刚执行这个命令<code>npm config set prefix &quot;...&quot;</code>时设置的目录下的<code>node_modules</code>文件夹中。<br>npm install命令的更多介绍可以看“扩展内容”-“给vue项目安装模块”部分。</p><h3 id="创建vue项目"><a href="#创建vue项目" class="headerlink" title="创建vue项目"></a>创建vue项目</h3><p>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack hello-demo</span><br></pre></td></tr></table></figure><p>这个命令表示在当前目录下创建hello-demo项目。</p><p>创建过程中，会问你一些问题，在看到<code>Install vue-router?</code>问题前都按<code>回车</code>，<code>Install vue-router?</code>这个问题输入<code>Y</code>，剩下的目前用不到就输入<code>N</code>。示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">? Project name hello-demo</span><br><span class="line">? Project description A Vue.js project</span><br><span class="line">? Author abc &lt;123456@qq.com&gt;</span><br><span class="line">? Vue build standalone</span><br><span class="line">? Install vue-router? Yes</span><br><span class="line">? Use ESLint to lint your code? No</span><br><span class="line">? Set up unit tests No</span><br><span class="line">? Setup e2e tests with Nightwatch? No</span><br><span class="line">? Should we run `npm install` <span class="keyword">for</span> you after the project has been created? (recommended) npm</span><br></pre></td></tr></table></figure><p>创建完成后有如下提示，说明创建成功。</p><img src="/2020/02/19/vue-env-build/vue_init_result.png" class="" title="创建成功"><h3 id="运行vue项目"><a href="#运行vue项目" class="headerlink" title="运行vue项目"></a>运行vue项目</h3><p>按照创建完成后给出的提示命令，在cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hello-demo</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><code>npm run dev</code>命令简单地说就是用hello-demo项目中的<code>node_modules\webpack-dev-server</code>模块启动项目，用的是开发环境的配置<code>build\webpack.dev.conf.js</code>，详细一点的解释可以在网上找得到，这里就不展开了。<br>启动成功后，访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 可以看到如下页面：</p><img src="/2020/02/19/vue-env-build/run_result.png" class="" title="项目主页"><h2 id="编辑器VSCode的安装和配置"><a href="#编辑器VSCode的安装和配置" class="headerlink" title="编辑器VSCode的安装和配置"></a>编辑器VSCode的安装和配置</h2><p>可以用来做vue开发的编辑器有vscode、webstorm等等，这里介绍的vscode，优点是免费而且轻量，缺点是使用一些必要的功能还要额外装插件。<br>在官网下载：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a> ，安装过程很普通所以不讲了。</p><h3 id="下载vetur插件实现vue代码高亮"><a href="#下载vetur插件实现vue代码高亮" class="headerlink" title="下载vetur插件实现vue代码高亮"></a>下载vetur插件实现vue代码高亮</h3><p>vscode打开vue项目时没有任何语法高亮。要下载vetur插件来实现。</p><ul><li><p>常规安装<br>在vscode界面最左侧的工具栏，如下图点击图标出现<code>Extensions</code>页面。</p><img src="/2020/02/19/vue-env-build/vscode_extensions.png" class="" title="Extensions"><p>在输入框输入vetur，点击安装，安装好后重新打开vscode即可看到vue代码已高亮。</p></li><li><p>离线安装<br>因为开发环境很有可能是不联网的，所以有时候要采取特殊手段来安装插件。<br>先在有网的环境，进入官网下载插件包：<a href="https://marketplace.visualstudio.com/vscode" target="_blank" rel="noopener">https://marketplace.visualstudio.com/vscode</a> ，搜索vetur，点击图中的下载按钮下载。</p><img src="/2020/02/19/vue-env-build/vetur_download.png" class="" title="vetur"><p>下载后的插件包是<code>.vsix</code>后缀的。<br>然后把这个<code>.vsix</code>文件放到vscode的安装目录的bin目录下。<br>接着在bin目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code --install-extension octref.vetur-0.23.0.vsix</span><br></pre></td></tr></table></figure><p>离线安装其他插件也是用这样的方法。</p></li></ul><h3 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h3><p>点击File -&gt; Preference -&gt; Keyboard Shortcuts，可以查看和修改快捷键。</p><h2 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h2><p>以上步骤已经把vue开发环境搭建好了。下面扩展地讲一下vue项目依赖模块的安装和打包。</p><h3 id="给vue项目安装模块"><a href="#给vue项目安装模块" class="headerlink" title="给vue项目安装模块"></a>给vue项目安装模块</h3><h4 id="安装axios模块"><a href="#安装axios模块" class="headerlink" title="安装axios模块"></a>安装axios模块</h4><p>假设现在在开发hello-demo项目，发现需要一个axios插件，用来实现HTTP请求。<br>在项目根目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save axios</span><br></pre></td></tr></table></figure><p>这个命令执行完，你会发现，此项目的<code>node_modules</code>文件夹中多了一个<code>axios</code>模块，且在项目的<code>package.json</code>文件中的<code>dependencies</code>括号内，多了<code>&quot;axios&quot;: &quot;^0.19.2&quot;</code>这一行。现在就可以在项目中使用axios了。</p><p><code>package.json</code>文件中的<code>dependencies</code>和<code>devDependencies</code>这两部分都表示项目依赖的模块，不同的是，<code>dependencies</code>代表<strong>生产环境</strong>需要依赖的模块，<code>devDependencies</code>代表<strong>开发</strong>时需要依赖的模块。</p><p>把模块添加到<code>devDependencies</code>下的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev &lt;模块名&gt;</span><br></pre></td></tr></table></figure><h4 id="常用的npm-install命令"><a href="#常用的npm-install命令" class="headerlink" title="常用的npm install命令"></a>常用的npm install命令</h4><ul><li><p>查看npm install命令的使用帮助：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -h</span><br></pre></td></tr></table></figure></li><li><p>全局安装模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g &lt;模块名&gt;</span><br></pre></td></tr></table></figure><p>安装到这个命令<code>npm config set prefix &quot;...&quot;</code>设置的目录下的<code>node_modules</code>文件夹中。</p></li><li><p>局部安装模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;模块名&gt;</span><br><span class="line">npm install --save &lt;模块名&gt;</span><br></pre></td></tr></table></figure><p>这两个命令效果一样，都是安装到当前项目下的<code>node_modules</code>文件夹中，同时添加到<code>package.json</code>文件中的<code>dependencies</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev &lt;模块名&gt;</span><br></pre></td></tr></table></figure><p>这个命令是安装到当前项目下的<code>node_modules</code>文件夹中，同时添加到<code>package.json</code>文件中的<code>devDependencies</code>。</p></li><li><p>下载项目依赖模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>这个命令会下载<code>package.json</code>文件中的<code>dependencies</code>和<code>devDependencies</code>中的所有依赖模块。<br>这个使用场景一般是git clone了项目，项目文件中通常不会包含依赖模块，依赖模块都写在<code>package.json</code>文件里，需要自己手动npm install下载一下。【和后台项目初次启动前先maven update一样</p></li><li><p>指定版本号下载模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install [-g|--save|--save-dev] &lt;模块名&gt;@&lt;版本号&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="打包vue项目"><a href="#打包vue项目" class="headerlink" title="打包vue项目"></a>打包vue项目</h3><p>进入要打包的项目目录，cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>打包完成后会打印<code>Build complete</code>。可以发现，项目目录下多出一个dist文件夹。</p><img src="/2020/02/19/vue-env-build/dist.png" class="" title="dist"><p>这个dist文件夹中就是项目的所有静态文件（做过混淆的），可以用nginx部署，nginx的配置文件基本是这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8080;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    root &#x2F;hellodemo&#x2F;dist; # dist文件所在目录</span><br><span class="line">    index index.html;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">      # 此处的 @router 实际上是引用下面的转发，否则在 Vue 路由刷新时可能会抛出 404</span><br><span class="line">      try_files $uri $uri&#x2F; @router;</span><br><span class="line">      # 请求指向的首页</span><br><span class="line">      index index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 由于路由的资源不一定是真实的路径，无法找到具体文件</span><br><span class="line">    # 所以需要将请求重写到 index.html 中，然后交给真正的 Vue 路由处理请求资源</span><br><span class="line">    location @router &#123;</span><br><span class="line">      rewrite ^.*$ &#x2F;index.html last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 这里配置后台接口地址转发，假设后台服务的IP端口是10.1.75.23:18081</span><br><span class="line">    # 比方说，前端“添加用户”的请求地址是http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;user&#x2F;add，就会被转发到 http:&#x2F;&#x2F;10.1.75.23:18081&#x2F;user&#x2F;add</span><br><span class="line">    location &#x2F;api&#x2F; &#123;</span><br><span class="line">          # 后端的真实接口</span><br><span class="line">          proxy_pass http:&#x2F;&#x2F;10.1.75.23:18081&#x2F;;</span><br><span class="line">          proxy_redirect off;</span><br><span class="line">          proxy_set_header Host $host;</span><br><span class="line">          proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">          proxy_set_header   Cookie $http_cookie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署完后浏览器输入localhost:8080就能跳到项目主页了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天依激励法</title>
      <link href="/2020/02/18/tianyi-fight/"/>
      <url>/2020/02/18/tianyi-fight/</url>
      
        <content type="html"><![CDATA[<p>爱天依就更要好好学习！<br>【顺便用以前做的表情包来测试一下图片效果和置顶~</p><img src="/2020/02/18/tianyi-fight/tianyi_fight.jpg" class="" title="天依激励法">]]></content>
      
      
      
        <tags>
            
            <tag> 洛天依 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/12/hello-world/"/>
      <url>/2020/02/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
