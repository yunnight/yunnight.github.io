<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于Maven打包</title>
      <link href="/2023/06/03/mvn-package-note/"/>
      <url>/2023/06/03/mvn-package-note/</url>
      
        <content type="html"><![CDATA[<h1 id="无启动类的工程打成jar包"><a href="#无启动类的工程打成jar包" class="headerlink" title="无启动类的工程打成jar包"></a>无启动类的工程打成jar包</h1><p>有一个无启动类的工程，要打成jar包直接给别的工程使用。</p><p>该工程的 pom.xml 打包配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span> <span class="comment">&lt;!-- 源代码使用的JDK版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span> <span class="comment">&lt;!-- 需要生成的目标class文件的编译版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span><span class="comment">&lt;!-- 字符集编码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span><span class="comment">&lt;!-- 跳过测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只能用<code>maven-compiler-plugin</code>，它适用于所有 maven 项目，无论其是不是 SpringBoot 项目；不能用<code>spring-boot-maven-plugin</code>，因为后者要求该工程必须有main方法。</p><blockquote><p>关于跳过测试的配置<code>&lt;skip&gt;true&lt;/skip&gt;</code>:</p></blockquote><p>maven 打包时一般会选择不执行测试类，省时间。加上<code>&lt;skip&gt;true&lt;/skip&gt;</code>的区别在于，mvn package 执行到<code>maven-surefire-plugin</code>会不会执行测试类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; 加上skip</span><br><span class="line">[INFO] --- maven-surefire-plugin:2.22.2:test (default-test) @ spring-boot-web-jar-test ---</span><br><span class="line">[INFO] No tests to run.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; 不加skip</span><br><span class="line">[INFO] --- maven-surefire-plugin:2.22.2:test (default-test) @ spring-boot-web-jar-test ---</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] -------------------------------------------------------</span><br><span class="line">[INFO]  T E S T S</span><br><span class="line">[INFO] -------------------------------------------------------</span><br><span class="line">......这里是测试类执行时打印的日志</span><br></pre></td></tr></table></figure><p>因为该工程无启动类，所以测试类执行时一定会报错：<code>java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration</code>，所以该工程若有测试类，则打包时必须跳过测试类才能打包成功。</p><h1 id="有启动类的工程打成jar包"><a href="#有启动类的工程打成jar包" class="headerlink" title="有启动类的工程打成jar包"></a>有启动类的工程打成jar包</h1><p>一般的 SpringBoot Web 项目都有启动类，把这个项目工程打成 jar 包放到服务器上运行。</p><p>该工程的 pom.xml 打包配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个工程打包插件只需要使用<code>spring-boot-maven-plugin</code>，该插件的配置中的<code>&lt;goal&gt;repackage&lt;/goal&gt;</code>的含义是：将当前工程打成可执行的，即有main方法的jar包。这里其实可以不加这个标签，因为<code>&lt;goal&gt;repackage&lt;/goal&gt;</code>是该插件的默认选项，这就是“无启动类的工程”不能使用该插件打包的原因。</p><p>使用了<code>spring-boot-maven-plugin</code>插件打包，不会跳过测试类，要跳过测试类，可以再加入以下两个插件其中一个：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span><span class="comment">&lt;!-- 跳过测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span><span class="comment">&lt;!-- 跳过测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>关于 repackage：</p></blockquote><p>使用普通的 mvn package 打包时生成的 jar 包中，只包含工程中的 java 文件编译后的 class 文件和 resources 下的配置文件，没有<code>BOOT-INF</code>目录；而 SpringBoot 插件 repackage 后的 jar 包中，将该工程的 maven 依赖包都加入了<code>BOOT-INF/lib</code>目录下，同时 class 文件和配置文件也放在了<code>BOOT-INF</code>目录下，并在<code>META-INF/MANIFEST.MF</code>文件中指定了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring-Boot-Classes: BOOT-INF&#x2F;classes&#x2F;</span><br><span class="line">Spring-Boot-Lib: BOOT-INF&#x2F;lib&#x2F;</span><br></pre></td></tr></table></figure><p>所以，只有用 SpringBoot 插件 repackage 打包后的 jar 才是可执行的 jar，这个插件帮助我们设置启动 main 方法，并将所有 maven 依赖都添加到了 jar 包中，使得它可以独立运行。</p><h1 id="依赖本地jar包的工程打成可执行jar包"><a href="#依赖本地jar包的工程打成可执行jar包" class="headerlink" title="依赖本地jar包的工程打成可执行jar包"></a>依赖本地jar包的工程打成可执行jar包</h1><p>有一个工程，在 resources 目录下有个 lib 目录，在这个目录下添加了多个该工程依赖的 jar 包。在 maven 打包时，要将这些 jar 包也打入到可执行 jar 包中，才能运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;$&#123;project.basedir&#125;&#x2F;src&#x2F;main&#x2F;resources&#x2F;lib&lt;&#x2F;directory&gt;&lt;!--lib路径--&gt;</span><br><span class="line">&lt;targetPath&gt;BOOT-INF&#x2F;lib&#x2F;&lt;&#x2F;targetPath&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**&#x2F;*.jar&lt;&#x2F;include&gt;</span><br><span class="line">&lt;&#x2F;includes&gt;</span><br><span class="line">&lt;&#x2F;resource&gt;</span><br><span class="line">&lt;&#x2F;resources&gt;</span><br><span class="line"></span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br><span class="line"></span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.3.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">&lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">&lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;</span><br><span class="line">&lt;skip&gt;true&lt;&#x2F;skip&gt;</span><br><span class="line">&lt;compilerArguments&gt;</span><br><span class="line">&lt;extdirs&gt;$&#123;project.basedir&#125;&#x2F;src&#x2F;main&#x2F;resources&#x2F;lib&lt;&#x2F;extdirs&gt;</span><br><span class="line">&lt;&#x2F;compilerArguments&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p><code>resource</code>标签的作用：将该工程 resources/lib 目录下所有 .jar 文件复制到<code>spring-boot-maven-plugin</code>插件打包后生成的 jar 中的<code>BOOT-INF/lib/</code>目录下，使得 jar 在运行时可以使用到这些依赖。</p><p>但只有 resource 标签还不够，因为 maven 打包前先编译，编译时会报找不到这些 jar 中的类，所以还需要添加<code>maven-compiler-plugin</code>，并指定其参数<code>extdirs</code>，使得 maven 编译时可以找到这些依赖，编译不会出错。</p><blockquote><p>resource 标签：<a href="https://blog.csdn.net/qq_44651775/article/details/106545959" target="_blank" rel="noopener">https://blog.csdn.net/qq_44651775/article/details/106545959</a></p></blockquote><p>还有另一种方式也可以实现这个效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--本地依赖添加到 dependencies 中 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.example&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-web-jar-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;scope&gt;system&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;systemPath&gt;$&#123;project.basedir&#125;&#x2F;src&#x2F;main&#x2F;resources&#x2F;lib&#x2F;spring-boot-web-jar-test-0.0.1-SNAPSHOT.jar&lt;&#x2F;systemPath&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;!-- 将 scope&#x3D;system 的依赖也添加到 BOOT-INF&#x2F;lib 目录下 --&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;includeSystemScope&gt;true&lt;&#x2F;includeSystemScope&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br><span class="line"></span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;3.5.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">&lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">&lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;</span><br><span class="line">&lt;skip&gt;true&lt;&#x2F;skip&gt;</span><br><span class="line">&lt;compilerArguments&gt;</span><br><span class="line">&lt;extdirs&gt;$&#123;project.basedir&#125;&#x2F;src&#x2F;main&#x2F;resources&#x2F;lib&lt;&#x2F;extdirs&gt;</span><br><span class="line">&lt;&#x2F;compilerArguments&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日常笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL时区问题</title>
      <link href="/2023/03/19/mysql-time-zone/"/>
      <url>/2023/03/19/mysql-time-zone/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL时区问题"><a href="#MySQL时区问题" class="headerlink" title="MySQL时区问题"></a>MySQL时区问题</h1><p>MySQL 有两个时区参数，一个是“MySQL 服务所在服务器的时区——system_time_zone”，另一个是“MySQL 使用的时区——time_zone”。</p><p>使用下面命令可以查询这两个参数值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global variables like &#39;%time_zone%&#39;;</span><br><span class="line">+------------------+--------+</span><br><span class="line">| Variable_name    | Value  |</span><br><span class="line">+------------------+--------+</span><br><span class="line">| system_time_zone |        |</span><br><span class="line">| time_zone        | SYSTEM |</span><br><span class="line">+------------------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>system_time_zone 的值取的是 MySQL 服务启动时的所在服务器的时区，若服务器的时区发生变化，重启 MySQL 后 system_time_zone 值也会变化。该值有时为空，但为空时也与启动时的所在服务器的时区一致。</p><p>time_zone 代表“MySQL 使用的时区”，它的值为 SYSTEM 说明它和 system_time_zone 保持一致，即它也取的是 MySQL 服务启动时的所在服务器的时区。若在<code>mysql.ini</code>文件中设置<code>default-time-zone</code>参数，则它就使用这个参数指定的时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">default-time-zone&#x3D;&#39;+08:00&#39;</span><br></pre></td></tr></table></figure><p>MySQL 服务运行时，可以设置<code>global time_zone</code>（全局时区）和<code>session time_zone</code>（当前session时区）来修改 MySQL 使用的时区。其中，修改<code>global time_zone</code>（全局时区）即修改了<code>time_zone</code>的值，会影响所有新创建的 session 的时区，直到 MySQL 重启后才会变成 MySQL 启动时的时区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--修改全局时区</span><br><span class="line">set global time_zone&#x3D;&#39;+00:00&#39;;</span><br><span class="line"></span><br><span class="line">--修改当前session的时区</span><br><span class="line">set session time_zone&#x3D;&#39;+00:00&#39;;</span><br><span class="line"></span><br><span class="line">--查看</span><br><span class="line">select @@global.time_zone,@@session.time_zone;</span><br></pre></td></tr></table></figure><p><code>session time_zone</code>（当前session时区）就是当前连接 MySQL 会话使用的时区，默认就是 time_zone 的时区。连接 MySQL 会话的例子如在 Navicat 中打开一个查询框，一个查询框就是一个连接 session。还有，JDBC 连接也是一个 session，JDBC 连接配置中的<code>serverTimezone</code>参数就是设置 Java 应用连接 MySQL 的 session 使用的时区，它的优先级比 time_zone 高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;UTC</span><br></pre></td></tr></table></figure><p>JDBC 这样配置后，把 Date 数据插入 MySQL 前，Java 应用依赖的 MySQL 驱动会先将它转为 UTC 时间再插入到 MySQL 的数据类型 datetime or timestamp 中。这两种数据类型的区别只有：timestamp 的显示会按照 MySQL 时区（time_zone），datetime 就显示插入的值。</p><p>举例：<br>若 MySQL 时区 time_zone 与系统时区（GMT8）一致，Java 应用中向 MySQL 插入<code>new Date()</code>对象值为“Sun Mar 19 16:24:59 CST 2023”，步骤为：</p><ol><li>由于serverTimeZone配置的是 UTC 时间，MySQL 驱动会将这个Date对象转为<strong>字符串值“2023-03-19 08:25:00”</strong>放到 sql 中，再将sql发送给 MySQL，因为Date对象本身是无法走网络的。</li><li>MySQL 数据库接收到这个时间字符串“2023-03-19 08:25:00”后，由于数据库时区配置 time_zone = GMT8，它会认为这个时间所在的时区是 GMT8 的，保存到数据库中的时间就是 GMT8 的“2023-03-19 08:25:00”，而这跟我们实际的时间“Sun Mar 19 16:24:59 CST 2023”不一致。</li></ol><p>当 Java 程序中查询这个时间时看到的是：“datetime=Sun Mar 19 16:25:00 CST 2023, timestamp=Sun Mar 19 16:25:00 CST 2023”，和插入的字符串值“2023-03-19 08:25:00”不一致，原因是 Java 程序在从 MySQL 中取到字符串值“2023-03-19 08:25:00”后将它理解为 UTC 时间（serverTimezone 指定的），而 Java 程序所在系统时间是 GMT8 ，所以展示时将这个 UTC 时间转化成了 GMT8 时间展示。这样恰好没出错，但实际上 MySQL 中存储的是 GMT8 的“2023-03-19 08:25:00”，而 Java 应用却认为 MySQL 存储的是 UTC 的“2023-03-19 08:25:00”，一旦将 JDBC 的 serverTimezone 修改，这种侥幸就被打破了。</p><blockquote><p>所以，JDBC 的 serverTimezone 应和 MySQL 的 time_zone 保持同步。</p></blockquote><h1 id="Spring序列化的时区问题"><a href="#Spring序列化的时区问题" class="headerlink" title="Spring序列化的时区问题"></a>Spring序列化的时区问题</h1><p>用程序查询出的时间与系统时区（GMT8）一致，但前端收到的响应却是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot;:14, &quot;dateTime&quot;:&quot;2020-11-08T10:01:25.000+00:00&quot;, &quot;timeStamp&quot;:&quot;2020-11-08T10:01:25.000+00:00&quot;&#125;</span><br></pre></td></tr></table></figure><p>两个时间都是 UTC，为什么？</p><p>答：Spring 将响应实体类转为 JSON 格式时，默认用 Jackson 框架，在处理 Date 类型的字段时，Jackson 框架默认的时区是 GMT0</p>]]></content>
      
      
      <categories>
          
          <category> 问题排查 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows下创建指定大小的文件</title>
      <link href="/2023/03/05/fsutil/"/>
      <url>/2023/03/05/fsutil/</url>
      
        <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/jiyibufangjia/article/details/124748257" target="_blank" rel="noopener">https://blog.csdn.net/jiyibufangjia/article/details/124748257</a></p><p>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsutil file createnew test.docx 10240</span><br></pre></td></tr></table></figure><p>后面两个参数，一个是文件名，一个是文件大小，以 Byte 为单位。</p><p>文件单位换算关系：<br>Byte -&gt; KB -&gt; MB -&gt; GB -&gt; TB</p><p>1 KB = 1024 Byte<br>1 MB = 1024 KB<br>1 GB = 1024 MB<br>1 TB = 1024 GB</p>]]></content>
      
      
      <categories>
          
          <category> 日常笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Postman编写自动化测试脚本常用方法</title>
      <link href="/2023/02/26/postman-note/"/>
      <url>/2023/02/26/postman-note/</url>
      
        <content type="html"><![CDATA[<p>Postman 支持在两处地方写脚本，分别是“Pre-request Script”、“Tests”，前者的脚本在调用接口前执行，后者在调用接口获得响应后执行。</p><p>Postman 的脚本语言就是JS（JavaScript），除了支持 JS 的语法和常用方法以外（例如：<code>JSON.stringify()</code>、<code>console.log()</code>），它还提供了自己的方法。</p><p>下面举例用的 Postman 版本是 7.36.5。</p><h1 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h1><p>例如，需要将请求中某个参数值通过一个外部变量设置进去。</p><p>无论参数是在 URL 中，还是在 URL 中的?后面，还是 JSON 格式报文中，要将一个参数值通过变量传递，都是用双花括号来声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;paramA&quot;:&quot;xxxxx&quot;,</span><br><span class="line">    &quot;paramB&quot;:&#123;&#123;paramB&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;&#123;&#123;paramB&#125;&#125;</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;test?paramB&#x3D;&#123;&#123;paramB&#125;&#125;</span><br></pre></td></tr></table></figure><p>设置这个变量的值的方法，通过 Postman 提供的方法直接设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pm.environment.set(<span class="string">"paramB"</span>, 参数值) <span class="comment">// 设置环境变量</span></span><br><span class="line">pm.globals.set(<span class="string">"paramB"</span>, 参数值) <span class="comment">// 设置全局变量</span></span><br></pre></td></tr></table></figure><p>环境变量、全局变量的区别：</p><p>自动化测试，一般是将多个请求在一个 Collection 中排列好，按照顺序执行。在 Postman 中要执行这个 Collection 时，选中 Collection，点击“Run”按钮，会弹出一个“Collection Runner”框，里面允许你选择一个“Environment”，这个选择的“Environment”指的是本次测试中该 Collection 所有请求执行的环境，当然也可以不选，若有选择，那么可以使用已经在这个环境中定义的变量值。环境变量就是该变量值只会添加到这个所选的环境中，且该变量值只能从这个环境中取，不会从其他环境中取。</p><p>全局变量则是不区分环境，在所有环境下执行的 Collection 都可以使用全局变量，也可以添加全局变量。若环境变量中有与全局变量重名的变量，则以环境变量中的为准。</p><p><strong>通过设置环境变量、全局变量，可以实现接口之间参数的传递</strong>，即上一个请求成功后取得的参数设置到变量中，下一个请求直接获取。</p><h1 id="获取响应参数"><a href="#获取响应参数" class="headerlink" title="获取响应参数"></a>获取响应参数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resonseData = pm.resonse.json(); <span class="comment">// 返回JS对象，后续就用处理JS对象的方法它即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="keyword">var</span> resultCode = resonseData.resultCode;</span><br><span class="line"><span class="keyword">var</span> resultMsg = resonseData.resultMsg;</span><br><span class="line"><span class="keyword">var</span> data = resonseData.data; <span class="comment">// 若data本身也是对象，则这里返回的也是JS对象类型</span></span><br></pre></td></tr></table></figure><h1 id="设置下一步请求"><a href="#设置下一步请求" class="headerlink" title="设置下一步请求"></a>设置下一步请求</h1><p>若需要判断在某个条件下，直接执行某个调用请求，而不是继续按照 Collection 中排列好的顺序执行下一个请求，则用 Postman 提供的方法直接设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poatman.setNextRequest(xxxx) <span class="comment">// 括号里填写请求名字，支持中文，请求本身不允许重名</span></span><br></pre></td></tr></table></figure><p>若要设置直接结束，不再继续，则设置<code>poatman.setNextRequest(null)</code>即可。</p><h1 id="断言测试"><a href="#断言测试" class="headerlink" title="断言测试"></a>断言测试</h1><p>Postman 使用下面这种格式进行断言测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"断言名"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="comment">// 判断条件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>判断条件有以下几种：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pm.response.to.have.status(<span class="number">200</span>); <span class="comment">//判断响应状态码=200</span></span><br><span class="line"></span><br><span class="line">pm.response.to.have.header(<span class="string">"Content-Type"</span>); <span class="comment">//判断响应头存在"Content-Type"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonData = pm.response.json();<span class="comment">// 判断响应参数中的响应码为成功</span></span><br><span class="line">pm.expect(jsonData.resultCode).to.eql(<span class="string">"00000000"</span>);  </span><br><span class="line"></span><br><span class="line">pm.expect(pm.response.responseTime).to.be.below(<span class="number">200</span>); <span class="comment">//判断响应时间&lt;200ms</span></span><br></pre></td></tr></table></figure><h1 id="用不同请求参数循环调用接口"><a href="#用不同请求参数循环调用接口" class="headerlink" title="用不同请求参数循环调用接口"></a>用不同请求参数循环调用接口</h1><p>例如，需要用不同的 userId 调用这个 URL 查看每个 userId 的响应： <a href="http://localhost:8080/test?userId=" target="_blank" rel="noopener">http://localhost:8080/test?userId=</a></p><ol><li>将这个接口单独添加到一个 Collection 中</li><li>将用于入参的 userId 值保存为一个 csv 文件，文件内容为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userId</span><br><span class="line">&quot;123&quot;</span><br><span class="line">&quot;456&quot;</span><br></pre></td></tr></table></figure></li><li>选中 Collection，点击“Run”按钮，会弹出一个“Collection Runner”框，框中有一个“Select File”按钮，点击后选择这个csv文件，可以预览将要用于入参的所有 userId 值</li><li>点击“Run”，Postman 就会用每个 userId 值调用 URL，可以在这个URL的“Tests”中写打印响应参数的脚本，查看不同入参下不同的响应参数</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隔离级别与脏读等并发问题</title>
      <link href="/2022/09/04/isolation-level-concurrency-problem/"/>
      <url>/2022/09/04/isolation-level-concurrency-problem/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以下内容是从 <a href="https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html" target="_blank" rel="noopener">https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html</a> 中提取出的关键内容，同时也有自己的补充。</p><h1 id="事务四要素ACID"><a href="#事务四要素ACID" class="headerlink" title="事务四要素ACID"></a>事务四要素ACID</h1><p>事务四要素，也叫“一个可靠的事务必须具备的四个特性”，分别是：</p><ul><li>原子性（Atomicity）：要么全部完成，要么全部不完成</li><li>一致性（Consistency）：一个事务单元需要提交之后才会被其他事务可见</li><li>隔离性（Isolation）：并发事务之间不会互相影响，设立了不同程度的<strong>隔离级别</strong>，通过适度的破坏一致性，得以提高性能</li><li>持久性（Durability）：事务提交后即持久化到磁盘不会丢失</li></ul><blockquote><p>和数据库有关的几个理论缩写：ACID、CAP、BASE。他们的区别可以看这篇博客：<a href="https://www.cnblogs.com/minikobe/p/11137256.html" target="_blank" rel="noopener">https://www.cnblogs.com/minikobe/p/11137256.html</a> 。总的来说，ACID不考虑数据库是否是分布式的，都要求强一致性。CAP和BASE考虑的是分布式数据库在一致性问题上的取舍。</p></blockquote><h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><p>在ACID中的“隔离性”，规定了以下4种“隔离级别”。</p><table><thead><tr><th>隔离级别</th><th align="left">概念</th><th align="left">会出现的并发问题</th><th align="left">不会出现的/解决的并发问题</th></tr></thead><tbody><tr><td>读未提交 Read Uncommitted</td><td align="left">可以读取到未提交的记录</td><td align="left">脏读、幻读、不可重复读（所有问题都可能出现）</td><td align="left">无</td></tr><tr><td>读已提交 Read Committed</td><td align="left">事务中只能看到已提交的修改 <br/>大部分数据库的默认隔离级别</td><td align="left">幻读、不可重复读</td><td align="left">脏读</td></tr><tr><td>可重复读 Repeatable Read</td><td align="left">在同一个事务内的查询结果都是一致的<br/> MySQL InnoDb 默认的隔离级别</td><td align="left">幻读</td><td align="left">脏读、不可重复读</td></tr><tr><td>序列化 Serializable</td><td align="left">所有事务串行执行，是最高隔离级别</td><td align="left">无</td><td align="left">所有问题都解决</td></tr></tbody></table><p>它们可以达到的隔离效果从低到高，所以它们每个都会比上一个隔离级别多解决一个问题。</p><h1 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h1><p>并发是指对相同的一条或多条记录同时操作。在不采取任何措施的情况下，事务会出现的并发问题有4种：</p><ol><li>脏读<br>事务一执行<code>UPDATE</code><strong>未提交</strong>，事务二执行<code>SELECT</code>读到了事务一UPDATE未提交的结果</li><li>不可重复读<br>事务一执行<code>UPDATE</code><strong>并提交</strong>，事务二中依次执行两句相同的<code>SELECT</code>，第一句在事务一UPDATE前读，第二句在事务一UPDATE并提交后读，两句相同的SELECT结果不一致</li><li>幻读<br>事务一执行<code>INSERT/DELETE</code>并提交，事务二中依次执行两句相同的<code>SELECT COUNT(1)</code>，第一句在事务一 INSERT/DELETE 前读，第二句在事务一 INSERT/DELETE 并提交后读，两句相同的SELECT COUNT(1)结果不一致。它与“不可重复读”的区别在于，“不可重复读”关注两次SELECT的记录内容是否一致，“幻读”关注两次SELECT的记录总数是否一致</li><li>丢失更新<br>包括“提交覆盖”和“回滚覆盖”。提交覆盖指，事务一先SELECT后再根据SELECT结果进行UPDATE，事务二在事务一 两次操作的间隙中UPDATE并提交，事务一UPDATE提交后覆盖了事务二的UPDATE。回滚覆盖类似，就是事务一的回滚覆盖了事务二的UPDATE。 </li></ol><p>这四种隔离级别，应该根据具体的业务来取舍，如果某个系统的业务里根本就没有重复读的场景，完全可以将数据库的隔离级别设置为“读已提交(RC)”，这样可以最大程度的提高数据库的并发性。</p><blockquote><p>“回滚覆盖”问题由数据库本身解决，不需要用户考虑。“提交覆盖”问题，在MySQL的“可重复读(RR)”隔离级别下没有解决，原因是：<br>因为 MySQL 的实现和 ANSI-SQL 标准之间的差异，在标准的传统实现中，RR 隔离级别是使用持续的 X 锁（写锁）和持续的 S 锁（读锁）来实现的，由于是持续的 S 锁，所以避免了其他事务有写操作（加了读锁的表会拒绝写请求），也就不存在提交覆盖问题。但是 MySQL 在 RR 隔离级别下，普通的 SELECT 语句没有任何的加锁，和标准的 RR 是不一样的。如果要让 MySQL 在 RR 隔离级别下不发生提交覆盖，可以使用 SELECT … LOCK IN SHARE MODE 或者 SELECT … FOR UPDATE （这样的SQL会加读锁）。</p></blockquote><h1 id="隔离级别的实现方式"><a href="#隔离级别的实现方式" class="headerlink" title="隔离级别的实现方式"></a>隔离级别的实现方式</h1><h2 id="基于锁的并发控制"><a href="#基于锁的并发控制" class="headerlink" title="基于锁的并发控制"></a>基于锁的并发控制</h2><p>传统的隔离级别是基于锁实现的，这种方式叫做 基于锁的并发控制（Lock-Based Concurrent Control，简写 LBCC）。通过对读写操作加不同的锁，以及对释放锁的时机进行不同的控制，就可以实现四种隔离级别。</p><p>锁的种类见博客《MYSQL笔记》（直接到目录-锁机制）：<a href="https://yunnight.github.io/2020/05/16/mysql-note/">https://yunnight.github.io/2020/05/16/mysql-note/</a></p><p>四种隔离级别的加锁策略如下：</p><ul><li>读未提交<br>有很多人认为这个隔离级别不需要加任何锁，这其实是错误的，我们上面讲过，有一种并发问题在任何隔离级别下都不允许存在，那就是“回滚覆盖”，如果不对写操作加<strong>持续 X 锁</strong>，当两个事务同时去写某条记录时，可能会出现回滚覆盖问题。对读操作不加锁。</li><li>读已提交<br>它是为了解决脏读问题，只能读取已提交的记录，要怎么做才可以保证事务中的读操作读到的记录都是已提交的呢？很简单，对读操作加上 S 锁，这样如果其他事务有正在写的操作，必须等待写操作提交之后才能读，因为 S 和 X 互斥，如果在读的过程中其他事务想写，也必须等事务读完之后才可以。这里的 S 锁是一个<strong>临时 S 锁</strong>，表示事务读完之后立即释放该锁，可以让其他事务继续写。对写操作加 “持续X锁”</li><li>可重复读<br>为了让事务可以重复读，“读已提交”时加在读操作的<strong>临时 S 锁</strong>变成了<strong>持续 S 锁</strong>，也就是直到事务结束时才释放该锁，这可以保证整个事务过程中，其他事务无法进行写操作，所以每次读出来的记录是一样的。对写操作加 “持续X锁”</li><li>序列化（Serializable）<br>为了解决幻读问题，行级锁做不到，需使用表级锁。</li></ul><hr><blockquote><p>两段锁协议（2-phase locking，简称 2PL）</p></blockquote><p>没有使用这个协议时，假设一个事务中先是对记录A的读，再是对记录B的写，则先取A的读锁，读完A即释放，再取B的写锁，写完B即释放。</p><p>而这个协议，将事务中的加锁和解锁明确地分成两个阶段：加锁阶段、解锁阶段。<br>加锁阶段：事务在读数据前加S锁，写数据前加X锁，加锁不成功则等待，加锁成功才继续执行,，且加锁后就不能做解锁。即上面的例子中，在这个阶段会先后取A的读锁、B的写锁，在这之间不会释放A的读锁<br>解锁阶段：在该阶段只能进行解锁而不能再进行加锁操作。即上面的例子中，在这个阶段先后释放A的读锁、B的写锁，在这之间不会加任何锁。</p><p>若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是序列化的。 </p><p>两段锁协议不能防止死锁，因为两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。</p><p>一次封锁法，就是 MySQL MyISAM 引擎使用的方式，它也遵循了“两段锁协议”，并且它可以避免死锁，但影响并发性能。</p><p>死锁的产生、MyISAM 引擎不会产生死锁的原因，见博客《MYSQL笔记》<a href="https://yunnight.github.io/2020/05/16/mysql-note">https://yunnight.github.io/2020/05/16/mysql-note</a></p><hr><h2 id="无锁的并发控制（MVCC）"><a href="#无锁的并发控制（MVCC）" class="headerlink" title="无锁的并发控制（MVCC）"></a>无锁的并发控制（MVCC）</h2><p>MySQL 中采用的“无锁的并发控制”技术是：多版本并发控制（Multi-Version Concurrent Control，简写 MVCC）</p><p>虽然数据库的四种隔离级别通过 LBCC 技术都可以实现，但是它最大的问题是它只实现了并发的读读，对于并发的读写还是冲突的，写时不能读，读时不能写（因为读锁写锁互斥），当读写操作都很频繁时，数据库的并发性将大大降低，针对这种场景，MVCC 技术应运而生。</p><p>MySQL 只有支持事务的 InnoDB 引擎支持 MVCC，该引擎实现 MVCC 的原理是：<br>InnoDB 中，事务在写一条记录时会将其拷贝一份生成这条记录的一个原始拷贝（这份拷贝数据也叫<strong>快照数据</strong>），写操作同样还是会对原记录加锁，但是读操作会读取未加锁的拷贝出的新记录，这就保证了读写并行。要注意的是，生成的拷贝数据存放于<code>undo log</code>，该数据通过“回滚指针”与原数据关联，若写操作修改原记录失败，会用 undo log 中的数据恢复原记录，所以 undo log 也是实现事务回滚的关键技术。</p><p>InnoDB 中只有 RC（读已提交）和 RR（可重复读）这两个隔离级别才有 MVCC。它们在 MVCC 机制作用下的表现也不同。原博客中做了个实验发现：</p><ul><li>RR（可重复读）时，事务二总是读取事务一开始时的那个版本，即使事务一已提交（写锁已释放）</li><li>RC（读已提交）时，事务二先是读取目标记录的最新版本，如果该记录被锁住（事务一未提交，写锁未释放），则读取该记录最新的一次快照</li></ul><p>由于事务二读取的都是快照数据，并不会被写操作阻塞，所以这种读操作称为<strong>快照读（Snapshot Read）</strong>，也叫<strong>非阻塞读（Nonlocking Read）</strong>。RR 隔离级别下的叫做<strong>一致性非阻塞读（Consistent Nonlocking Read）</strong>。在InnoDB 中，普通 SELECT 语句不会加任何锁，这种就是快照读。【实验例子中的事务二就是用的普通 SELECT 语句</p><p>除了快照读 ，MySQL 还提供了另一种读取方式：<strong>当前读（Current Read）</strong>，也叫<strong>加锁读（Locking Read）</strong>或者<strong>阻塞读（Blocking Read）</strong>，这种读操作读的不再是数据的快照版本，而是数据的最新版本，并会对数据加锁。在InnoDB 中，可以给 SELECT 语句显式加锁，如<code>SELECT … LOCK IN SHARE MODE</code>（加行读锁）或<code>SELECT … FOR UPDATE</code>（加行写锁），这种就是当前读。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TiDB笔记</title>
      <link href="/2022/09/03/tidb-note/"/>
      <url>/2022/09/03/tidb-note/</url>
      
        <content type="html"><![CDATA[<h1 id="大致介绍"><a href="#大致介绍" class="headerlink" title="大致介绍"></a>大致介绍</h1><p>TiDB 数据库是由 PingCAP 公司研发的国产数据库，它的关键字有：开源、分布式、支持HTAP、NewSQL数据库、关系型数据库、兼容MySQL语法</p><p>官方文档：<a href="https://docs.pingcap.com/zh/tidb/v6.2/overview" target="_blank" rel="noopener">https://docs.pingcap.com/zh/tidb/v6.2/overview</a></p><p>TiDB 支持HTAP的意思是：<br>企业生产的数据越来越多，其规模可能达到数百 TB 甚至 PB 级别，传统的解决方案是通过 OLTP 型数据库处理在线联机交易业务，通过 ETL 工具将数据同步到 OLAP 型数据库进行数据分析，这种处理方案存在存储成本高、实时性差等多方面的问题。TiDB 在 4.0 版本中引入<strong>列存储</strong>引擎 TiFlash 结合<strong>行存储</strong>引擎 TiKV 构建真正的 HTAP 数据库，在增加少量存储成本的情况下，可以在同一个系统中做联机交易处理、实时数据分析，极大地节省企业的成本。（来自官方文档）</p><blockquote><p>1.什么是HTAP？</p></blockquote><p>HTAP = OLTP(联机事务处理) + OLAP(联机分析处理)。当今的数据处理大致可以分成两大类：OLTP和OLAP。<br>OLTP 是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，不用于决策，一次性查询或修改的数据量没有OLAP大，因为用户数多，所以对响应时间要求高。普通的Java Web应用对数据库进行增删改查就是OLTP；<br>OLAP 是数据仓库系统的主要应用，一次性操作的是大量数据，支持多维分析操作（钻取、切片和切块、旋转），得到直观的查询结果，用于分析决策。</p><blockquote><p>2.什么是NewSQL数据库？</p></blockquote><p>NewSQL 是对各种新的可扩展/高性能数据库的简称，这类数据库不仅具有 NoSQL 对海量数据的存储管理能力，还保持了传统数据库支持ACID等特性。</p><blockquote><p>3.什么是行存储、列存储？</p></blockquote><p>简单地说，行存储就是数据在“页”中是按原本数据表的一行一行数据存储的，例如 MySQL、Oracle。列存储中数据是按原本数据表的一列一列存储的。行存储适用于OLTP场景，列存储适用于OLAP场景。<br>行存储：<a href="https://blog.csdn.net/li1325169021/article/details/121044179" target="_blank" rel="noopener">https://blog.csdn.net/li1325169021/article/details/121044179</a><br>列存储：<a href="https://www.jianshu.com/p/d1114dd4f77a" target="_blank" rel="noopener">https://www.jianshu.com/p/d1114dd4f77a</a></p><hr><p>TiDB 架构：</p><ul><li><p>TiDB Server<br>SQL 层，对外暴露 MySQL 协议的连接 endpoint，负责接受客户端的连接，执行 SQL 解析和优化，最终生成分布式执行计划。它本身不存储数据，只是生成执行计划后将执行计划转发给底层的存储节点 TiKV（或 TiFlash）。所以它可以很方便的扩展成集群，处理的更多客户端连接。</p></li><li><p>TiKV<br>负责存储数据，从外部看 TiKV 是一个分布式的提供事务的 Key-Value 存储引擎。 和 Redis 一样的键值对存储<br>存储数据的基本单位是 Region，每个 Region 负责存储一个 Key Range（从 StartKey 到 EndKey 的左闭右开区间）的数据，每个 TiKV 节点会负责（存储）多个 Region。<br>TiKV 的 API 在 KV 键值对层面提供对分布式事务的原生支持，默认提供了 SI (Snapshot Isolation) 的隔离级别（对应于 MySQL 的“可重复读”隔离级别），这也是 TiDB 在 SQL 层面支持分布式事务的核心。<br>TiDB 的 SQL 层做完 SQL 解析后，会将 SQL 的执行计划转换为对 TiKV API 的实际调用。所以，数据都存储在 TiKV 中。<br>TiKV 中的数据都会自动维护多副本（默认为三副本，即一个 Region 会创建3个副本），天然支持高可用和自动故障转移。</p></li><li><p>TiFlash<br>TiFlash 是一类特殊的存储节点。和普通 TiKV 节点不一样的是，在 TiFlash 内部，数据是以列式的形式进行存储，主要的功能是为分析型的场景加速。</p></li><li><p>PD (Placement Driver) Server<br>整个 TiDB 集群的元信息管理模块，负责存储每个 TiKV 节点实时的数据分布情况和集群的整体拓扑结构，提供 TiDB Dashboard 管控界面，并为分布式事务分配事务 ID。PD 不仅存储元信息，同时还会根据 TiKV 节点实时上报的数据分布状态，下发数据调度命令给具体的 TiKV 节点，可以说是整个集群的“大脑”。此外，PD 本身也是由至少 3 个节点构成，拥有高可用的能力。建议部署奇数个 PD 节点。</p></li></ul><h1 id="TiKV"><a href="#TiKV" class="headerlink" title="TiKV"></a>TiKV</h1><p>TiKV 中重要的关键词：</p><ul><li>RocksDB</li><li>Raft</li><li>MVCC</li><li>两段锁协议</li></ul><p>下面的介绍会说明这些关键词的含义和实现细节。</p><h2 id="RocksDB"><a href="#RocksDB" class="headerlink" title="RocksDB"></a>RocksDB</h2><p>TiKV 底层的存储引擎是 RocksDB，每个 TiKV 实例中有两个 RocksDB 实例，一个用于存储 Raft 日志(raft log)，通常被称为“raftdb”；另一个用于存储数据以及 MVCC 信息，通常被称为“kvdb”。RocksDB 是 Facebook 基于 LevelDB 开发的一款提供键值存储与读写功能的 LSM-tree 架构引擎。</p><p>什么是 LevelDB 和 LSM-tree？</p><p>LevelDB 是谷歌开发的键值对数据库，数据的存储结构就是 LSM-tree（日志结构合并树）。</p><p>MySQL 使用<strong>B+树</strong>作为存储结构，B+树最大的性能问题是会产生大量的<strong>随机读写</strong>，逻辑上连续的两个叶子节点在物理上往往不连续，做范围查询时，可能要读多个叶子节点，就是随机读；如果新插入的数据存储在磁盘上也不连续，就是随机写。</p><p>LSM-tree 其实不是一个树，而是一种存储数据的机制。在这个机制下，内存中有一个数据结构，可以是红黑树、B+树或跳表（增加了向前指针的链表叫作跳表），磁盘中有多个数据文件，叫<strong>SST (Sorted String Table)文件</strong>。SST 文件是 LSM 树在磁盘中持久化存储的数据结构，它存储了有序的<strong>键值对</strong>。</p><p>LSM 树的优势在于有效地规避了磁盘随机写入问题，但读取时可能需要访问较多的磁盘文件。</p><blockquote><p>PS: 什么是随机读写、顺序读写？<br>随机和顺序读写，是存储器的两种输入输出方式。存储的数据在磁盘中占据空间，对于一个新磁盘，操作系统会将数据文件依次写入磁盘，当有些数据被删除时，就会空出该数据原来占有的存储空间，时间长了，不断的写入、删除数据，就会产生很多零零散散的存储空间，就会造成一个较大的数据文件放在许多不连续的存贮空间上，读写这部分数据时，就是随机读写，磁头要不断的调整磁道的位置，以在不同位置上的读写数据，相对于连续空间上的顺序读写，要耗时很多。</p></blockquote><p>LSM-tree 写数据时，数据先写入内存中的树（树中的数据有序），同时也会写入磁盘中一个日志文件“WAL”(Write Ahead Log)（append only 方式写入），这个文件用途是内存数据丢失时可以用它恢复数据。内存中的树被写满后，后台进程会将这个树写入磁盘形成一个 SST 文件，内存数据被多次写满，磁盘中就有多个 SST 文件。一般情况下，一条数据会被重复写入，那么这条数据在多个 SST 中都会存在，即 SST 文件之间是有交集的。所以，读数据时需要从新到旧遍历所有 SST 文件（因为不知道所查的数据在哪个文件里），这就是读性能下降的原因。若一个 key 在多个文件中都存在，那么只查询出它的第一个版本。</p><p>LevelDB 有一个后台线程负责整理磁盘中的多个 SST 文件，以提高读的效率（这个操作也叫“压缩-Compact”）。LSM-tree 中有两种压缩策略<code>Size-Tiered Compaction Strategy</code>和<code>Leveled Compaction Strategy</code>，RocksDB 和 LevelDB 采用后者。整理后，SST 文件会按照如下图所示的层级排列：</p><img src="/2022/09/03/tidb-note/SST_level.PNG" class="" title="SST_level"><p>图中的<code>memtable</code>和<code>immutable memtable</code>都在内存中，都是有序的数据结构，写数据时先写入 memtable，当 memtable 的容量达到阈值时，便会转换成一个不可修改的 immutable memtable。它同 memtable 的结构定义一样。两者的区别只是 immutable memtable 是只读的。后台线程会将 immutable memtable 写入到磁盘中形成一个新的 SST 文件，随后便销毁 immutable memtable，这个操作就是图中标出的<code>minor compaction</code>。</p><p>图中的 Level-0 层级的 SST 文件，是多次 minor compaction 操作的产物，它们之间的数据可能是有交集的（因为同个 key 的数据可能被多次修改）。</p><p>当 Level-0 的文件数目超过一个设定的数值，会将这个层级所有的 SST 文件中的所有数据进行合并和切分，重新形成多个 SST 文件，这些新文件中的数据不会有交集（相同 key 的数据做了合并），这些新的 SST 文件被移到了下个层级 Level-1。如果 Level-1 本来已经存在 SST 文件了，那么 Level-0 的所有文件会和 Level-1 中的所有文件一起做合并和切分，产生的新文件在 Level-1 中。</p><p>在 Level-0 之后的层级，触发合并到下一层的条件是这个层级的 SST 文件的总大小超过一个设定的数值，就从这个层级中选择一个文件与下一个层级的部分文件合并。当前层级选择文件的方式就是“轮询”，这样每个文件都有机会被合并。</p><p>假设现在是 Level-1 向 Level-2 合并，Level-2 选出的参与合并的文件，是和 Level-1 指定的那个文件中的数据的“key range”有重叠的那些文件。合并的原理是：？？？？？？？？</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>未完整，这部分文字不理解，什么是多路归并</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>对多个文件采用<strong>多路归并</strong>排序的方式，依次找出其中最小的 key 记录，也就是对多个文件中的所有记录重新进行排序。遍历每条键值对数据，判断这个 key 是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入 Level-2 层中新生成的一个 SST 文件中，最后删除这两个层级中参与合并的文件。</p><p>判断 key 是否还需要保存的逻辑是，如果这个 key 在更低级别的level中出现过，那说明他有更新的value存储，我们需要进行抛弃。？？？？</p><p>RocksDB 的原理是，用户写入的键值对会先写入磁盘上的<strong>WAL</strong>，然后再写入内存中的<strong>跳表</strong>（SkipList，这部分结构又被称作 MemTable）。【这里的“跳表”就是上面提到的 LSM 在内存中的树</p><p>内存中的数据达到一定阈值后，会刷到磁盘上生成<strong>SST</strong>文件 (Sorted String Table)，SST 又分为多层（默认至多 6 层），每一层的数据达到一定阈值后会挑选一部分 SST 合并到下一层，每一层的数据是上一层的 10 倍（因此 90% 的数据存储在最后一层）。</p><p>RocksDB 允许用户创建多个 ColumnFamily ，这些 ColumnFamily 各自拥有独立的内存跳表以及 SST 文件，但是共享同一个 WAL 文件，这样的好处是可以根据应用特点为不同的 ColumnFamily 选择不同的配置，但是又没有增加对 WAL 的写次数。</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h2 id="TiKV中的Region"><a href="#TiKV中的Region" class="headerlink" title="TiKV中的Region"></a>TiKV中的Region</h2><p>TiDB 底层是键值对存储，外面系统读取和写入时看到的一行一行的关系型数据，是 TiDB 按照它的机制转换的，每一行数据对应一个 key-value 对，key 中包含了“表ID”和“记录的主键ID”，于是可以做到这条数据的 key 在整个 TiDB 中唯一。一张表有多行数据也即有多条 key-value 对，这些数据会被划分成多个<strong>Region</strong>，即一张表的数据会跨多个 Region，Region 中的数据是有序的（按 key 排序），每个 Region 都可以用 [startKey, endKey) 这样的左开右闭区间表示它的数据范围。</p><p>随着 Region 中数据更新，如 insert 增加数据、update 使数据的 value 变大变小、delete 删除数据，Region 中的数据总量如果变得太小，会和其他 Region 合并；如果变得太大（超过144M），会被分裂成多个 Region。</p><p>同时，TiDB 使用了名叫“Raft”的分布式一致性协议，每个 Region 一共存在3个副本（默认是3个），每个副本一般要设置分布在不同的 TiKV 实例上（有参数配置，为了高可用）。其中一个副本的角色是 leader，其余副本角色是 follower。默认配置下，读写都只发生在 leader，follower 只负责在写操作中复制 leader 的数据。</p><p>leader 和它的 follower 们组成一个“raft group”，多个“raft group”叫作“multi-raft”。</p><p>？？？？？？？？？？？leader和follower之间怎么互相知道？？？？？？？？？？？</p><p>TiDB 如何使用 Raft 的原理在下一节详解。</p><h2 id="TiKV中的raftdb"><a href="#TiKV中的raftdb" class="headerlink" title="TiKV中的raftdb"></a>TiKV中的raftdb</h2><p>TiKV 实例中有两个 RocksDB 实例，其中一个用于存储 Raft 日志(raft log)，通常被称为“raftdb”。另一个用于存储数据，通常被称为“kvdb”。</p><p>Raft 是一个一致性协议，它提供了几个重要的功能：</p><ol><li>Leader（主副本）选举</li><li>成员变更（如添加副本、删除副本、转移 Leader 等操作）</li><li>日志复制</li></ol><p>TiKV 利用 Raft 来做数据复制，每个数据变更都会落地为一条 Raft 日志，通过 Raft 的日志复制功能，将数据安全可靠地同步到“raft group”的每一个节点中。不过在实际写入中，根据 Raft 的协议，只需要同步复制到多数节点，即可安全地认为数据写入成功。</p><p>因为只有写数据涉及到数据同步，所以下面要讲的“Raft 日志复制”只发生在写数据时。</p><p>我们的 DML SQL 会先被 TiDB Server 转化为“执行计划”</p><p>Raft 日志复制总共需要五个阶段：</p><ul><li><p>Propose<br>  要写入的数据（这里不用考虑它是个什么格式）给到 leader region，leader 将它转成“raft log”的格式。raft log 格式类似于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4_1, log&#123;PUT key&#x3D;1, name&#x3D;TOM&#125; -- &#39;4_1&#39;中的&#39;4&#39;是 region 的编号，&#39;1&#39;是该条日志的序号，后面是操作，表示将 key&#x3D;1 的数据中的 name 字段改为&#39;TOM&#39;（也可能是新增一条 key&#x3D;1 的数据）</span><br><span class="line">4_2, log&#123;PUT key&#x3D;2, name&#x3D;CANDY&#125;</span><br><span class="line">4_3, log&#123;DEL key&#x3D;3&#125; -- 这个是 DELETE SQL 的日志格式</span><br></pre></td></tr></table></figure></li><li><p>Append<br>  leader 将转换好的 raft log 保存到自己所在 TiKV 节点的 raftdb 中，这个操作也叫“将 Raft 日志持久化”</p></li><li><p>Replicate<br>  leader 将 raft log 发给 follower（一条条发还是批量发？？？）这个是 Raft 的功能之一。follower 收到后也经过 Propose+Append 两个阶段，将 raft log 保存到自己所在节点的 raftdb 中，保存成功后会给 leader 回消息表示自己这边的 raft log 持久化成功了</p></li><li><p>Committed<br>  leader 收到多数 follower 的成功回信，认为该 raft log 已经真正持久化成功，给每条 raft log 标记 Committed，还是这个raft log标记Commitred？？？？？？？</p></li><li><p>Apply<br>  leader 将 raft log 中的数据保存到 kvdb 中，（一条一条做？？？？？ </p></li></ul><p>若在 Replicate 阶段中，多数 follower 节点不可用，leader 没有收到回信，那么 leader 会将这一条 raft log（还是整个 raft log？）不会标记成 Committed，就不会持久化到 kvdb 中。</p><p>将数据转为 raft log 的线程来自于线程池 raftstore pool，将 raft log 写入 kvdb 的线程池是 apply pool<br>TiKV 线程池：<a href="https://book.tidb.io/session4/chapter8/threadpool-optimize.html" target="_blank" rel="noopener">https://book.tidb.io/session4/chapter8/threadpool-optimize.html</a></p><p>leader 的 raftstore pool 也负责发生给follower</p><h2 id="TiKV中的Raft选举"><a href="#TiKV中的Raft选举" class="headerlink" title="TiKV中的Raft选举"></a>TiKV中的Raft选举</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TiDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ClassLoader笔记</title>
      <link href="/2022/08/15/classloader/"/>
      <url>/2022/08/15/classloader/</url>
      
        <content type="html"><![CDATA[<h1 id="大致介绍"><a href="#大致介绍" class="headerlink" title="大致介绍"></a>大致介绍</h1><p>我们都知道Java代码会被<strong>Java编译器</strong>编译成class文件，在class文件中描述了该类的各种信息，class类最终需要被加载到JVM中才能运行和使用（由<strong>Java解释器</strong>执行）。</p><p>类的生命周期包括：加载、验证、准备、解析、初始化、使用、卸载。</p><p>加载的来源有以下部分：<br>1、本地磁盘<br>2、网络下载的.class文件<br>3、war、jar下加载.class文件<br>4、从专门的数据库中读取.class文件（少见）<br>5、将java源文件动态编译成class文件，典型的就是动态代理，通过运行时生成class文件</p><p><strong>加载的过程就是通过类加载器 ClassLoader 实现的。</strong>ClassLoader 是Java的核心组件，所有的Class都是由 ClassLoader 进行加载的，ClassLoader 负责将class文件中的二进制数据流读入JVM内部，转换为一个与目标类对应的 java.lang.Class 对象实例。然后交给JVM进行后续的生命周期操作。</p><p>我们在代码中使用<code>Class.forName(name)</code>时就是使用了类加载器。</p><h2 id="3个类加载器"><a href="#3个类加载器" class="headerlink" title="3个类加载器"></a>3个类加载器</h2><p><strong>系统定义的类加载器有3个</strong>，按下面顺序前一个是后一个的父加载器：</p><p><strong>一、启动类加载器</strong>（底层使用C++实现）<br>它用来加载Java的核心库（JVM系统参数sun.boot.class.path 路径下的内容），用于提供JVM自身需要的类，只加载包名为java、javax、sun等开头的类<br>用户未自己主动设置该属性时，用代码<code>System.getProperties(&quot;sun.boot.class.path&quot;)</code>可以得到它的默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D:\Development\Java\jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;resources.jar</span><br><span class="line">D:\Development\Java\jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;rt.jar</span><br><span class="line">D:\Development\Java\jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;sunrsasign.jar</span><br><span class="line">D:\Development\Java\jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;jsse.jar</span><br><span class="line">D:\Development\Java\jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;jce.jar</span><br><span class="line">D:\Development\Java\jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;charsets.jar</span><br><span class="line">D:\Development\Java\jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;jfr.jar</span><br><span class="line">D:\Development\Java\jdk1.8.0_131&#x2F;jre&#x2F;classes</span><br><span class="line">-- &quot;D:\Development\Java\jdk1.8.0_131&quot;其实就是我们设置的JAVA_HOME环境变量</span><br></pre></td></tr></table></figure><p><strong>二、扩展类加载器</strong>（底层使用java实现，是ClassLoader的子类，位置sun.misc.Launcher$ExtClassLoader）<br>从 JVM系统参数java.ext.dirs 所指定的目录中加载类库，或从JDK的安装目录的 jre/lib/ext 下加载类库。如果用户创建的JAR放在此目录下，也会自动由该类加载器加载</p><p><strong>三、应用程序类加载器</strong>（底层使用java实现，是ClassLoader的子类，位置sun.misc.Launcher$AppClassLoader）<br>它负责加载 环境变量classpath 或 JVM系统参数java.class.path 指定路径下的类库。该类加载器默认是“系统类加载器”，通过<code>ClassLoader.getSystemClassLoader()</code>方法可以获取到该类加载器。它也是用户自定义类加载器的默认父加载器</p><blockquote><p>参考博客：根据配置 CLASSPATH 彻底弄懂 AppCLassLoader（应用程序类加载器）的加载路径问题: <a href="https://blog.csdn.net/romantic_jie/article/details/107859901" target="_blank" rel="noopener">https://blog.csdn.net/romantic_jie/article/details/107859901</a></p></blockquote><blockquote><p>在 sun.misc.Launcher 类中有初始化扩展类加载器和应用程序类加载器的源码。博客：<a href="https://www.pudn.com/news/6286507cb305d84a4f6e8596.html" target="_blank" rel="noopener">https://www.pudn.com/news/6286507cb305d84a4f6e8596.html</a> 搜索关键字Launcher</p></blockquote><h2 id="类加载器的其他概念"><a href="#类加载器的其他概念" class="headerlink" title="类加载器的其他概念"></a>类加载器的其他概念</h2><p><strong>双亲委派模型</strong>，就是指一个类接收到类加载请求后，会把这个请求依次传递给父类加载器（如果还有的话），如果顶层的父类加载器可以加载，就成功返回，如果无法加载，再依次给子加载器去加载。</p><p><strong>线程上下文的类加载器</strong>，用<code>Thread.currentThread().getContextClassLoader()</code>方法获得，在应用程序类加载器的初始化过程中，将该应用程序类加载器设置为线程上下文的类加载器。</p><p>线程上下文的类加载器的作用：<br>双亲委派模型并不是绝对的，spi机制就可以打破双亲委派模型。</p><p>什么是spi？spi(Service Provider Interface)是一种服务发现机制，Java在核心库中定义了许多接口，并且针对这些接口给出调用逻辑，但是并未给出具体的实现。开发者要做的就是定制一个实现类，在 META-INF/services 中注册实现类信息，以供核心类库使用。</p><p>最典型的例子就是 JDBC 的实现方式。Java 提供了一个 Driver 接口用于驱动各个厂商的数据库连接，Driver 接口位于 JAVA_HOME 中 jre/lib/rt.jar 中，应该由<strong>启动类加载器</strong>进行加载。根据类加载机制，当被加载的类引用了另外一个类的时候，虚拟机就会使用加载该类的类加载器加载被引用的类，因此如果其他数据库厂商定制了 Driver 的实现类之后，按理说也得把这个实现类放到启动类加载器加载的目录下，这显然是很不合理的。</p><p>于是Java提供了spi机制，即使 Driver 由启动类加载器去加载，但是他可以让<strong>线程上下文类加载器</strong>（默认是应用程序类加载器）去请求加载子类的类加载器去完成加载。但是这确实破坏了双亲委派模型。</p><h1 id="classLoader-getResources-方法"><a href="#classLoader-getResources-方法" class="headerlink" title="classLoader.getResources 方法"></a>classLoader.getResources 方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title">getResources</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) <span class="keyword">new</span> Enumeration&lt;?&gt;[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tmp[<span class="number">0</span>] = parent.getResources(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp[<span class="number">0</span>] = getBootstrapResources(name);</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[<span class="number">1</span>] = findResources(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompoundEnumeration&lt;&gt;(tmp);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个方法被用于在 classpath 下查找一个或多个，由方法参数<code>String name</code>指定名字的文件的 URL。该方法返回一个枚举类型 <code>java.util.Enumeration</code> 对象，包含了在 classpath 下所有匹配指定名称的资源的 URL。</p><p>例如下面这段代码，正是 Spring 核心类<code>SpringFactoriesLoader</code>查找“spring.factories”文件路径时调用了 classLoader.getResources 方法来查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); <span class="comment">// FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories"</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这个方法返回的<code>CompoundEnumeration</code>对象中，还看不出文件所在的绝对路径，只能看出 ClassLoader 准备在哪些路径下查找目标文件。</p><p>CompoundEnumeration类的特点：<br><code>CompoundEnumeration</code> 是一个用于处理多个 <code>Enumeration</code> 对象的类。<code>CompoundEnumeration</code> 的构造器接受一个 <code>Enumeration</code> 数组，并且将它们合并成一个新的 <code>Enumeration</code>。在 <code>nextElement()</code> 方法中依次返回每个 <code>Enumeration</code> 对象中的每个枚举元素，直到所有<code>Enumeration</code>对象以及它们中的元素遍历结束。<br>在调用 <code>nextElement()</code> 方法时，如果当前 <code>Enumeration</code> 还有元素，则返回该元素。如果当前 <code>Enumeration</code> 没有元素，则将指针移到下一个 <code>Enumeration</code>，并返回该 <code>Enumeration</code> 的第一个元素。<br>PS: 其实可以用 List<Object> 代替 Enumeration<Object>[] ，因为 List 也能遍历到每个元素。</p><p>那么是哪些路径呢？从这个方法可以看出，tmp[0]是当前加载器的父加载器返回的，tmp[1]才是当前加载器返回的，也就是说这个方法也是按照“双亲委派模型”编写的，返回的路径中既包含父加载器的路径，也包含当前加载器的路径。<br>当前加载器在一般情况下就是<strong>应用程序类加载器</strong>，所以它的这个方法返回的路径，就是 启动类加载器+扩展类加载器+应用程序类加载器 3个类加载器负责的路径的并集，即 “JVM系统参数sun.boot.class.path” + “JVM系统参数java.ext.dirs” + “环境变量classpath” 包含的路径的并集！</p><p>在这个方法中，涉及到几个内部类对象的创建：</p><p>一、<code>ClassLoader.getBootstrapResources</code>方法返回的<code>Enumeration&lt;URL&gt;</code>内部类对象，即<strong>启动类加载器</strong>返回的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Enumeration&lt;URL&gt; <span class="title">getBootstrapResources</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Enumeration&lt;Resource&gt; e =</span><br><span class="line">        getBootstrapClassPath().getResources(name); <span class="comment">// 另一个内部类对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;URL&gt; () &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> URL <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.nextElement().getURL();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.hasMoreElements();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个 static 方法，这个内部类对象不依赖于外部类对象，它还使用到了上面一行代码创建的另一个内部类对象e（见第二点）</p><p>二、<code>URLClassPath.getResources</code>方法返回的<code>Enumeration&lt;Resource&gt;</code>内部类对象</p><p>上面第一点源码中<code>getBootstrapClassPath</code>返回的是<code>URLClassPath</code>对象，所以<code>getBootstrapClassPath().getResources(name)</code>就是调用 URLClassPath.getResources 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;Resource&gt; <span class="title">getResources</span><span class="params">(<span class="keyword">final</span> String var1, <span class="keyword">final</span> <span class="keyword">boolean</span> var2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;Resource&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] cache = URLClassPath.<span class="keyword">this</span>.getLookupCache(var1);</span><br><span class="line">        <span class="keyword">private</span> Resource res = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.res != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    URLClassPath.Loader var1x;</span><br><span class="line">                    <span class="keyword">if</span> ((var1x = URLClassPath.<span class="keyword">this</span>.getNextLoader(<span class="keyword">this</span>.cache, <span class="keyword">this</span>.index++)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.res = var1x.getResource(var1, var2);</span><br><span class="line">                &#125; <span class="keyword">while</span>(<span class="keyword">this</span>.res == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Resource <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.next()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Resource var1x = <span class="keyword">this</span>.res;</span><br><span class="line">                <span class="keyword">this</span>.res = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> var1x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个非 static 方法，所以这个内部类对象的属性之一就是外部类 URLClassPath 对象，在外部类 URLClassPath 对象中的属性 ArrayList<URL> path 就保存了启动类加载器负责加载的所有路径。内部类对象可以访问到这些路径。</p><p>三、<code>URLClassLoader.findResources</code>方法返回的<code>Enumeration&lt;URL&gt;</code>内部类对象</p><p>扩展类加载器 和 应用程序类加载器，它们都继承自<code>URLClassLoader</code>，所以”tmp[1] = findResources(name);”代码就是在调用 URLClassLoader.findResources 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title">findResources</span><span class="params">(<span class="keyword">final</span> String name)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Enumeration&lt;URL&gt; e = ucp.findResources(name, <span class="keyword">true</span>);<span class="comment">// ucp即URLClassPath，是URLClassLoader成员之一</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;URL&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> URL url = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                URL u = AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> PrivilegedAction&lt;URL&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> URL <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">if</span> (!e.hasMoreElements())</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">return</span> e.nextElement();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, acc);</span><br><span class="line">                <span class="keyword">if</span> (u == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                url = ucp.checkURL(u);</span><br><span class="line">            &#125; <span class="keyword">while</span> (url == <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> url != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> URL <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!next()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">            URL u = url;</span><br><span class="line">            url = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个内部类中，使用到了第一行声明的变量”Enumeration<URL> e”，这个变量是调用<code>URLClassPath.findResources</code>方法获取的：<br>（这个方法和上面第二点的方法的区别仅仅在于返回的是 URL 还是 Resource）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title">findResources</span><span class="params">(<span class="keyword">final</span> String var1, <span class="keyword">final</span> <span class="keyword">boolean</span> var2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;URL&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] cache = URLClassPath.<span class="keyword">this</span>.getLookupCache(var1);</span><br><span class="line">        <span class="keyword">private</span> URL url = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.url != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    URLClassPath.Loader var1x;</span><br><span class="line">                    <span class="keyword">if</span> ((var1x = URLClassPath.<span class="keyword">this</span>.getNextLoader(<span class="keyword">this</span>.cache, <span class="keyword">this</span>.index++)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.url = var1x.findResource(var1, var2);</span><br><span class="line">                &#125; <span class="keyword">while</span>(<span class="keyword">this</span>.url == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> URL <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.next()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                URL var1x = <span class="keyword">this</span>.url;</span><br><span class="line">                <span class="keyword">this</span>.url = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> var1x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这个<code>URLClassLoader.findResources</code>方法中其实创建了两个内部类对象，一个是成员 URLClassPath 创建的，一个是 URLClassLoader 自己创建的。在 URLClassPath 自己创建的内部类对象中，使用到了 URLClassPath 创建的内部类对象，所以真正起作用的还是 URLClassPath 创建的内部类对象。</p><p>同时，这两个方法都非 static，所以外部类对象（扩展类加载器/应用程序类加载器）自身实例，和 URLClassPath 实例，都是其内部类对象的属性之一。扩展类加载器/应用程序类加载器 负责加载的路径，就保存在其成员 URLClassPath 中的属性 ArrayList<URL> path。内部类对象可以访问到这些路径。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内部类使用笔记</title>
      <link href="/2022/08/15/inner-class/"/>
      <url>/2022/08/15/inner-class/</url>
      
        <content type="html"><![CDATA[<h1 id="定义在DTO或VO类中，可以在外面访问的内部类"><a href="#定义在DTO或VO类中，可以在外面访问的内部类" class="headerlink" title="定义在DTO或VO类中，可以在外面访问的内部类"></a>定义在DTO或VO类中，可以在外面访问的内部类</h1><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessOutDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;BusinessDetailOutDTO&gt; businessDetailList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务明细类，属于业务的一部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessDetailOutDTO</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String detailName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建+赋值</span></span><br><span class="line">BusinessOutDTO businessOutDTO = <span class="keyword">new</span> BusinessOutDTO();</span><br><span class="line">businessOutDTO.setId(<span class="number">1</span>);</span><br><span class="line">businessOutDTO.setName(<span class="string">"business-A"</span>);</span><br><span class="line"></span><br><span class="line">BusinessOutDTO.BusinessDetailOutDTO businessDetailOutDTO = <span class="keyword">new</span> BusinessOutDTO().<span class="keyword">new</span> BusinessDetailOutDTO();<span class="comment">// 需要先 new 外部类对象，才能创建内部类对象</span></span><br><span class="line">businessDetailOutDTO.setId(<span class="number">1</span>);</span><br><span class="line">businessDetailOutDTO.setDetailName(<span class="string">"businessDetail-a"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;BusinessOutDTO.BusinessDetailOutDTO&gt; businessDetailList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">businessDetailList.add(businessDetailOutDTO);</span><br><span class="line">businessOutDTO.setBusinessDetailList(businessDetailList);</span><br><span class="line">System.out.println(businessOutDTO);</span><br><span class="line"><span class="comment">// 输出：BusinessOutDTO(id=1, name=business-A, businessDetailList=[BusinessOutDTO.BusinessDetailOutDTO(id=1, detailName=businessDetail-a)])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">List&lt;BusinessOutDTO.BusinessDetailOutDTO&gt; businessDetailList1 = businessOutDTO.getBusinessDetailList();</span><br><span class="line">System.out.println(businessDetailList1);</span><br><span class="line"><span class="comment">// 输出：[BusinessOutDTO.BusinessDetailOutDTO(id=1, detailName=businessDetail-a)]</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>声明为 public，非 static，属于成员内部类</li><li>定义成内部类只是觉得它“属于”其外部类，其实把它定义成独立的非内部类也是可以的</li><li>因为外部类和内部类都是 DTO 类，无逻辑，所以只有外部类创建和使用到内部类，内部类不会访问外部类属性</li></ol><h1 id="在外部类中被用来做逻辑处理的内部类"><a href="#在外部类中被用来做逻辑处理的内部类" class="headerlink" title="在外部类中被用来做逻辑处理的内部类"></a>在外部类中被用来做逻辑处理的内部类</h1><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadlineUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DeadlineBO <span class="title">add</span><span class="params">(<span class="keyword">int</span> deadlineVal1, String deadlineUnit1, <span class="keyword">int</span> deadlineVal2, String deadlineUnit2)</span> </span>&#123;</span><br><span class="line">        DeadlineBO deadlineBO1 = <span class="keyword">new</span> DeadlineUtil.DeadlineBO(deadlineVal1, deadlineUnit1); <span class="comment">// 直接创建内部类对象，不需要先 new DeadlineUtil()</span></span><br><span class="line">        DeadlineBO deadlineBO2 = <span class="keyword">new</span> DeadlineUtil.DeadlineBO(deadlineVal2, deadlineUnit2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==============此处是一段期限相加逻辑=============="</span>);</span><br><span class="line">        DeadlineBO deadlineBOResult = <span class="keyword">new</span> DeadlineUtil.DeadlineBO(<span class="number">0</span>, <span class="string">"year"</span>);</span><br><span class="line">        <span class="keyword">return</span> deadlineBOResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadlineBO</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> deadlineVal;</span><br><span class="line">        <span class="keyword">private</span> String deadlineUnit;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DeadlineBO</span><span class="params">(<span class="keyword">int</span> deadlineVal, String deadlineUnit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.deadlineVal = deadlineVal;</span><br><span class="line">            <span class="keyword">this</span>.deadlineUnit = deadlineUnit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类 DeadlineBO 被用来做逻辑处理，并作为方法的返回类型，注意其在外部类方法 add 方法的返回类型声明中，不用加外部类名前缀”DeadlineUtil.”。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeadlineUtil.DeadlineBO addResult = DeadlineUtil.add(<span class="number">1</span>, <span class="string">"year"</span>, <span class="number">3</span>, <span class="string">"month"</span>);</span><br></pre></td></tr></table></figure><p>在外面使用时，还是会加外部类名前缀”DeadlineUtil.”。</p><p>另外，这个内部类被声明为<strong>“静态内部类”</strong>，静态内部类的特点是不需要 new 外部类对象就能使用，但也不能访问外部类的非静态成员。对于工具类而言，因为不希望创建工具类的对象，所以用静态内部类更合适。</p><p>如果没有声明为静态内部类（即没有static的内部类），那么上面的 add 方法会是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DeadlineBO <span class="title">add</span><span class="params">(<span class="keyword">int</span> deadlineVal1, String deadlineUnit1, <span class="keyword">int</span> deadlineVal2, String deadlineUnit2)</span> </span>&#123;</span><br><span class="line">DeadlineBO deadlineBO1 = <span class="keyword">new</span> DeadlineUtil().<span class="keyword">new</span> DeadlineBO(deadlineVal1, deadlineUnit1); <span class="comment">// 需要先 new DeadlineUtil() 才能创建内部类对象</span></span><br><span class="line">DeadlineBO deadlineBO2 = <span class="keyword">new</span> DeadlineUtil().<span class="keyword">new</span> DeadlineBO(deadlineVal2, deadlineUnit2);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"==============此处是一段期限相加逻辑=============="</span>);</span><br><span class="line">DeadlineBO deadlineBOResult = <span class="keyword">new</span> DeadlineUtil().<span class="keyword">new</span> DeadlineBO(<span class="number">0</span>, <span class="string">"year"</span>);</span><br><span class="line"><span class="keyword">return</span> deadlineBOResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>声明为 public static，属于静态内部类</li><li>外部类会使用内部类作逻辑处理，所以外部类内部会创建和使用内部类对象，但内部类不会访问外部类属性</li></ol><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>创建匿名内部类之前，这个匿名内部类必须是继承自一个接口或抽象类。</p><p>常见的例子如创建线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = newRunnable();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title">newRunnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()); <span class="comment">// Thread-0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable 就是一个接口，Debug看<code>newRunnable()</code>方法返回的类型，会看到类似于”MainTest$1@555”字样，而上一个例子 DeadlineUtil.add() 方法返回的会是”DeadlineUtil$DeadlineBO”字样，区别就是”$”符号后面有没有具体的类名。而这个叫”MainTest$1@555”的对象就是外部类 MainTest 创建的“实现 Runnable 接口的匿名内部类”的对象。</p><p>如果不用这个匿名内部类，那么常规方法是：1）声明一个类实现 Runnable 接口及其 run 方法；2）在 MainTest 中创建1中声明的类的对象，使用这个对象</p><h2 id="静态、非静态方法返回的匿名内部类"><a href="#静态、非静态方法返回的匿名内部类" class="headerlink" title="静态、非静态方法返回的匿名内部类"></a>静态、非静态方法返回的匿名内部类</h2><p>匿名内部类 作为 return 参数时，它所在的方法是 static 和非 static 的性质是不同的。</p><p>例如以下代码中两个方法都返回 Runnable 接口的匿名内部类对象，但一个是 static 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Runnable <span class="title">noStaticRunnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title">staticRunnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别调用这两个方法返回不同的 Runnable 对象，Debug看时，发现非 static 方法返回的对象中有一个属性<code>this$0</code>指向其外部类对象<code>RunnableLoader</code>，而 static 方法返回的就没有这个对象。原因就是外部类的 static 方法不会创建外部类对象，也不能访问外部类对象实例。</p><p>Debug代码与截图如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RunnableLoader runnableLoader = <span class="keyword">new</span> RunnableLoader();</span><br><span class="line">Runnable runnable = runnableLoader.noStaticRunnable();</span><br><span class="line"></span><br><span class="line">Runnable staticRunnable = RunnableLoader.staticRunnable();</span><br></pre></td></tr></table></figure><img src="/2022/08/15/inner-class/debug%E6%88%AA%E5%9B%BE1.PNG" class="" title="debug截图1"><h2 id="使用到匿名内部类以外的变量"><a href="#使用到匿名内部类以外的变量" class="headerlink" title="使用到匿名内部类以外的变量"></a>使用到匿名内部类以外的变量</h2><p>这里说的“匿名内部类以外的变量”是说，这个变量既不是匿名内部类中声明的，也不是外部类声明的，例如下面这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enumeration&lt;String&gt; e = <span class="keyword">this</span>.get(); <span class="comment">// 变量e是在这个方法体内声明的，既不是匿名内部类中声明的，也不是外部类声明的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> e.hasMoreElements(); <span class="comment">// 但内部类中用到了这个变量</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> e.nextElement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Debug这个方法返回的匿名内部类对象，截图：</p><img src="/2022/08/15/inner-class/debug%E6%88%AA%E5%9B%BE2.PNG" class="" title="debug截图2"><p>可以看到，这个变量<code>Enumeration&lt;String&gt; e</code>和外部类对象<code>this$0</code>一样，也被认为是匿名内部类的属性之一。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringFactoriesLoader</title>
      <link href="/2022/08/15/spring-factories-loader/"/>
      <url>/2022/08/15/spring-factories-loader/</url>
      
        <content type="html"><![CDATA[<h1 id="大致介绍"><a href="#大致介绍" class="headerlink" title="大致介绍"></a>大致介绍</h1><p><code>SpringFactoriesLoader</code>是 spring 的一个核心类，在 spring-core.jar 包中。它的作用是，用<code>ClassLoader</code>找出项目依赖jar包中的所有“META-INF/spring.factories”文件，将里面的内容加载成 <code>Properties</code>对象（key value对，一个文件加载出一个 Properties），再由 Properties 对象转为 Map&lt;String, List<String>&gt; 格式。</p><p>以下面这个文件为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring-boot-autoconfigure-2.3.0.RELEASE.jar META-INF&#x2F;spring.factories</span><br><span class="line"></span><br><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line">。。。。。</span><br></pre></td></tr></table></figure><p>这个文件加载出的 Properties 对象内容有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key1 &#x3D; &quot;org.springframework.context.ApplicationContextInitializer&quot;</span><br><span class="line">value1 &#x3D; &quot;org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener&quot;</span><br><span class="line"></span><br><span class="line">key2 &#x3D; &quot;org.springframework.context.ApplicationListener&quot;</span><br><span class="line">value2 &#x3D; &quot;org.springframework.boot.autoconfigure.BackgroundPreinitializer&quot;</span><br><span class="line"></span><br><span class="line">等等</span><br></pre></td></tr></table></figure><p>最后转成的 Map&lt;String, List<String>&gt; 格式内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key1 &#x3D; &quot;org.springframework.context.ApplicationContextInitializer&quot;</span><br><span class="line">value1List &#x3D; [&quot;org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer&quot;,&quot;org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener&quot;]</span><br><span class="line">-- 这个 value1List 其实就是把 Properties 对象的 value 保存的字符串按逗号分隔变成的数组</span><br><span class="line"></span><br><span class="line">key2 &#x3D; &quot;org.springframework.context.ApplicationListener&quot;</span><br><span class="line">value2List &#x3D; [&quot;org.springframework.boot.autoconfigure.BackgroundPreinitializer&quot;]</span><br><span class="line"></span><br><span class="line">等等</span><br></pre></td></tr></table></figure><blockquote><p>扫描这个“META-INF/spring.factories”文件的目的是什么？<br>SpringBoot 默认会扫描并管理在启动类包路径下的 Bean。如果有想要被扫描但不想改变默认扫描的路径，比如自己写的 jar 包中有 Bean，但不要求使用这个 jar 的应用必须修改默认扫描路径，就在自己 jar 中添加这个“META-INF/spring.factories”文件，将 jar 中的 Bean 的接口与实现类写上，SpringBoot 启动时会在某个阶段？将这些Bean扫描并管理。</p></blockquote><h1 id="在哪些路径下寻找spring-factories文件"><a href="#在哪些路径下寻找spring-factories文件" class="headerlink" title="在哪些路径下寻找spring.factories文件"></a>在哪些路径下寻找spring.factories文件</h1><p><code>SpringFactoriesLoader.loadSpringFactories</code>方法中的下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br></pre></td></tr></table></figure><p>其中 classLoader，即类加载器，是这个方法的入参，可以为null，为null时使用“系统类加载器”，即“应用程序类加载器”，常量 FACTORIES_RESOURCE_LOCATION = “META-INF/spring.factories”。</p><p>这段代码通过调用<code>classLoader.getResources</code>方法返回一个<code>CompoundEnumeration&lt;URL&gt;</code>对象，元素<code>URL</code>中保存的就是某一个“spring.factories”文件所在的绝对路径，如“file:/D:/Development/maven-repo/org/springframework/boot/spring-boot/2.3.0.RELEASE/spring-boot-2.3.0.RELEASE.jar!/META-INF/spring.factories”。但是，在这行代码中还不会得到“spring.factories”文件所在的绝对路径，可以认为这时返回的<code>CompoundEnumeration&lt;URL&gt;</code>对象中的<code>URL</code>元素是空的，它只是获取出会在哪些路径下寻找 URL。</p><p>会在哪些路径下寻找 URL 呢？研究<code>ClassLoader.getResources</code>源码就会知道，这些路径就是 启动类加载器+扩展类加载器+应用程序类加载器 3个类加载器负责的路径的并集，即”JVM系统参数sun.boot.class.path” + “JVM系统参数java.ext.dirs” + “环境变量classpath” 包含的路径的并集！也就是说，SpringFactoriesLoader 将会去启动类加载器、扩展类加载器、应用程序类加载器它们3个负责加载的全部路径中，寻找“META-INF/spring.factories”文件，只不过，这个文件一般只存在于应用程序类加载器负责的路径，即“环境变量classpath”指定的路径下。</p><p>上面说到，从<code>classLoader.getResources</code>方法返回的变量中还没有找到“spring.factories”文件所在的绝对路径，每个文件的绝对路径是在后面的代码中获取的（代码解释见注释）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line"><span class="comment">// 。。。</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123; <span class="comment">// 在这一步查找具体的路径，遍历所有路径，从一个路径下找到了就返回true，下一次循环就从已找到路径的下一个开始遍历，找到就返回，最后遍历完所有路径返回false</span></span><br><span class="line">URL url = urls.nextElement(); <span class="comment">// 取出这一次循环找到的路径</span></span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource); <span class="comment">// 文件内容转为Properties对象</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; <span class="comment">// Properties对象中key-value转为Map&lt;String, List&lt;String&gt;&gt; result格式</span></span><br><span class="line">String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line"><span class="keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="loadFactoryNames-方法"><a href="#loadFactoryNames-方法" class="headerlink" title="loadFactoryNames 方法"></a>loadFactoryNames 方法</h1><p>已知<code>loadSpringFactories</code>方法返回的 Map&lt;String, List<String>&gt; result 中，key为接口全限定名，value为“spring.factories”文件中配置的该接口的实现类全限定名。</p><p><code>loadFactoryNames</code>方法是根据入参<code>Class&lt;?&gt; factoryType</code>指定的 className（接口名），从 loadSpringFactories 方法返回的 Map 中取该接口名对应的实现类名 List。</p><p>代码最后的 getOrDefault 意思是如果返回的 Map 中没有指定 key 对应的 value，那么就返回 value=空List，如果有就返回真正的 value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">String factoryTypeName = factoryType.getName();</span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="loadFactories-方法"><a href="#loadFactories-方法" class="headerlink" title="loadFactories 方法"></a>loadFactories 方法</h1><p>这个方法首先通过<code>loadFactoryNames</code>方法获取指定接口的实现类名 List（变量 factoryImplementationNames），再用<code>instantiateFactory</code>方法根据这些实现类名<strong>反射创建</strong>这些实现类的实例对象，如果这些实现类有使用<code>PriorityOrdered</code>或<code>Ordered</code>，还会根据其标注的顺序排序，最后返回排序后的实现类实例对象 List。</p><blockquote><p>排序方法 AnnotationAwareOrderComparator :</p></blockquote><ol><li>用于比较的两个对象都实现了 <code>PriorityOrdered</code> 接口，对比它们的 getOrder() 的值，值小的在前</li><li>两个对象中只有一个实现了 <code>PriorityOrdered</code> 接口，则实现了这个接口的排在前</li><li>两个对象中分别查找它们是否实现了<code>Ordered</code> 接口，是则获取 getOrder() 值；若未实现<code>Ordered</code> 接口，就查看它们是否标注了 Order 注解，是则获取注解中的排序值；若也没有 Order 注解，再看是否有 Priority 注解，有则获取注解中的排序值；都没有则返回一个大值，则这个类会被排在后面。排序值小的排在前</li><li>当两个对象排序值相同，会按对象名称排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadFactories</span><span class="params">(Class&lt;T&gt; factoryType, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">Assert.notNull(factoryType, <span class="string">"'factoryType' must not be null"</span>);</span><br><span class="line">ClassLoader classLoaderToUse = classLoader;</span><br><span class="line"><span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">classLoaderToUse = SpringFactoriesLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; factoryImplementationNames = loadFactoryNames(factoryType, classLoaderToUse);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Loaded ["</span> + factoryType.getName() + <span class="string">"] names: "</span> + factoryImplementationNames);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(factoryImplementationNames.size());</span><br><span class="line"><span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">result.add(instantiateFactory(factoryImplementationName, factoryType, classLoaderToUse));</span><br><span class="line">&#125;</span><br><span class="line">AnnotationAwareOrderComparator.sort(result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instantiateFactory</span><span class="params">(String factoryImplementationName, Class&lt;T&gt; factoryType, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; factoryImplementationClass = ClassUtils.forName(factoryImplementationName, classLoader);</span><br><span class="line"><span class="keyword">if</span> (!factoryType.isAssignableFrom(factoryImplementationClass)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line"><span class="string">"Class ["</span> + factoryImplementationName + <span class="string">"] is not assignable to factory type ["</span> + factoryType.getName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) ReflectionUtils.accessibleConstructor(factoryImplementationClass).newInstance();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line"><span class="string">"Unable to instantiate factory class ["</span> + factoryImplementationName + <span class="string">"] for factory type ["</span> + factoryType.getName() + <span class="string">"]"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一种对某个操作前置后置一系列处理的优化经验</title>
      <link href="/2022/06/01/youhua-processor/"/>
      <url>/2022/06/01/youhua-processor/</url>
      
        <content type="html"><![CDATA[<h1 id="背景与优化思路"><a href="#背景与优化思路" class="headerlink" title="背景与优化思路"></a>背景与优化思路</h1><p>在项目的某几个接口，例如流程提交接口，在“调用工作流引擎，改变工作流状态”这个操作的前后，都会有一系列的处理，而且改动频繁，基本上新增一块业务功能就需要在流程提交接口中做些校验或者更新的操作。原本的流程提交代码类似于这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 提交前1：当XX时，校验XX内容</span><br><span class="line">&#x2F;&#x2F; 提交前2：当XX时，校验XX内容</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 流程提交主体逻辑：组装工作流引擎参数，调用工作流引擎，改变工作流状态</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提交后1：当XX时，更新业务状态</span><br><span class="line">&#x2F;&#x2F; 提交后2：当XX时，更新XX内容</span><br><span class="line">&#x2F;&#x2F; 提交后3：当XX时，保存历史数据</span><br><span class="line">&#x2F;&#x2F; 提交后4、5、6等</span><br></pre></td></tr></table></figure><p>所以，只要新增一块业务需求，都要改动这段代码，非常地麻烦。我要把它优化成，这段代码只保留主体逻辑，即“调用工作流引擎”那部分，在这部分前、后的涉及业务处理的代码，都封装成一个接口。加需求时，我只是添加一个接口实现类，不需要改动这块主体逻辑。</p><p>于是，我想到了 Spring 提供的接口<code>BeanPostProcessor</code>，它的特点就是，用户只要添加一个它的实现类，实现它的两个方法：<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>，在 Bean 被初始化的前后，就会调用到用户添加的实现类，而用户并不需要改动 Bean 初始化的主体逻辑，就像切面一样。</p><p>但是，BeanPostProcessor 有个不灵活的地方，就是它的切入点只能是“Bean 初始化”前后。想要增加切入点，就得再写一个接口继承它，就像<code>InstantiationAwareBeanPostProcessoror</code>做的那样，它扩展的切入点是“Bean 实例化”。几个切入点就要几个接口。</p><p>于是，我又想到了 Spring Cloud 中的 Zuul 网关，它将自己的过滤器分成几种类型：pre、route、post、error，这个类型决定了这个过滤器在哪个时间点被执行，并且可以指定过滤器的执行顺序。用户想要在多个时间点添加自己的过滤器，都只实现一个抽象类<code>ZuulFilter</code>，指定过滤器类型<code>filterType</code>和执行顺序<code>filterOrder</code>，Zuul 就会按照它原本的主体逻辑，在合适的时候调用到用户添加的过滤器，用户也不需要改动 Zuul 的逻辑。</p><h1 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h1><p>结合 BeanPostProcessor 和 ZuulFilter 的特点和它们的源码，我定义了如下<strong>抽象类</strong>。类中方法的入参 WorkflowInBO 、WorkflowOutBO 是我封装的在调用工作流引擎前后都能获取到的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkflowPostProcessor</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">WorkflowPostProcessor</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_ORDER = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义processor的类型，可选值在 ProcesssorTypeEnum 枚举类定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ProcesssorTypeEnum <span class="title">processsorType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回值决定processor的执行顺序，值小的先执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">processsorOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MAX_ORDER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法返回TRUE时，才会执行这个processor的前置、后置方法；否则都不执行。可由子类覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldProcess</span><span class="params">(WorkflowInBO inBO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在调用工作流引擎前，执行此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokePostProcessorBeforeAction</span><span class="params">(WorkflowInBO inBO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldProcess(inBO)) &#123;</span><br><span class="line">            postProcessorBeforeAction(inBO);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在调用工作流引擎后，执行此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokePostProcessorAfterAction</span><span class="params">(WorkflowInBO inBO, WorkflowOutBO outBO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldProcess(inBO)) &#123;</span><br><span class="line">            postProcessorAfterAction(inBO, outBO);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">postProcessorBeforeAction</span><span class="params">(WorkflowInBO inBO)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">postProcessorAfterAction</span><span class="params">(WorkflowInBO inBO, WorkflowOutBO outBO)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(WorkflowPostProcessor o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.processsorOrder(), o.processsorOrder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我还定义一个“统一入口”，用来访问<code>WorkflowPostProcessor</code>的所有实现类的前置后置方法。这个主要是参考 Zuul 的<code>FilterProcessor</code>的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessorsManager</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    List&lt;WorkflowPostProcessor&gt; allProcessors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, List&lt;WorkflowPostProcessor&gt;&gt; hashProcessorsByType = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 allProcessors 中过滤出指定 processsorType 的处理器，并排序，返回List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;WorkflowPostProcessor&gt; <span class="title">getProcessorsByType</span><span class="params">(ProcesssorTypeEnum processsorType)</span> </span>&#123;</span><br><span class="line">        List&lt;WorkflowPostProcessor&gt; list = hashProcessorsByType.get(processsorType.name());</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (WorkflowPostProcessor processor : allProcessors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processor.processsorType() == processsorType) &#123;</span><br><span class="line">                list.add(processor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        hashProcessorsByType.putIfAbsent(processsorType.name(), list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历执行指定 processsorType 的processor的前置方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runPostProcessorBeforeActionByType</span><span class="params">(ProcesssorTypeEnum processsorType, WorkflowInBO inBO)</span> </span>&#123;</span><br><span class="line">        List&lt;WorkflowPostProcessor&gt; processors = getProcessorsByType(processsorType);</span><br><span class="line">        <span class="keyword">if</span> (!processors.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (WorkflowPostProcessor processor : processors) &#123;</span><br><span class="line">                processor.invokePostProcessorBeforeAction(inBO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历执行指定 processsorType 的processor的后置方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runPostProcessorAfterActionByType</span><span class="params">(ProcesssorTypeEnum processsorType, WorkflowInBO inBO, WorkflowOutBO outBO)</span> </span>&#123;</span><br><span class="line">        List&lt;WorkflowPostProcessor&gt; processors = getProcessorsByType(processsorType);</span><br><span class="line">        <span class="keyword">if</span> (!processors.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (WorkflowPostProcessor processor : processors) &#123;</span><br><span class="line">                processor.invokePostProcessorAfterAction(inBO, outBO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，流程提交接口的代码就变成了如下这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 提交前</span><br><span class="line">processorsManager.runPostProcessorBeforeActionByType(ProcesssorTypeEnum.SUBMIT, workflowInBO);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 流程提交主体逻辑：组装工作流引擎参数，调用工作流引擎，改变工作流状态</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提交后</span><br><span class="line">processorsManager.runPostProcessorAfterActionByType(ProcesssorTypeEnum.SUBMIT, workflowInBO, workflowOutBO);</span><br></pre></td></tr></table></figure><p>从此以后，负责设计开发新需求的同事就不用来找我说流程接口要加这个加那个了（我还要和他对清楚哪个情况加，怎么加，出BUG了还首先问我是不是我调用参数写错了）直接把这个接口定义扔给他，让他自己加，出BUG都是他的事！莫挨老子！</p>]]></content>
      
      
      <categories>
          
          <category> 优化经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一种方案完整性校验方法</title>
      <link href="/2022/04/03/complete-valid/"/>
      <url>/2022/04/03/complete-valid/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>一个完整的业务方案，包括几个模块，如下图所示：</p><img src="/2022/04/03/complete-valid/%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%A1%88%E4%B8%BE%E4%BE%8B.PNG" class="" title="业务方案举例"><p>用户填写完每个模块的内容后，点击“提交申请”按钮，后台需要对这些内容做“完整性校验”，每个模块都有自己的校验规则，如在“业务基本信息”中，当且仅当业务类型=XXX时，业务币种必填。模块之间还有联动校验规则，如“业务低风险标志为是时，业务明细数量不能少于2条”。如果这些业务规则数量太多，放到一个“提交申请”接口里遍历校验，无论是对于用户体验，还是这个接口的开发/维护人员的体验，都非常不友好。</p><p>很容易想到，每个模块都有自己的保存接口，如“保存业务基本信息”“保存业务明细”等，我们应该把每个模块的规则分散在这些接口中，保证用户填写的每个模块的数据都是经过验证的，那么“提交申请”接口就不需要校验数据了。</p><p>要实现上面这点，首先要求UI设计成：每个模块按固定顺序填写，上一个模块未保存，不能进入下一个模块；若回到上一个模块修改，下一个模块的数据应该重新保存；所有模块填写完成才能点击“提交申请”。如果业务方案内容较少，比如就三个模块且每个模块字段少，那么这个设计没什么问题。如果业务方案内容多，那么这个设计第一是用户体验不好，第二是对前端要求高，一般不会采用的。</p><p>所以如果你的业务方案的页面和我的一样，左侧导航栏列出用户要填写的模块内容的标题，右侧展示模块页面，用户可以随意在每个模块之间切换页面，可以在未保存模块内容时点击“提交申请”按钮，那么“提交申请”接口就避不开“完整性校验”了。</p><h1 id="想到的方法"><a href="#想到的方法" class="headerlink" title="想到的方法"></a>想到的方法</h1><p>我们想到过下面两种完整性校验的实现方法。</p><p><strong>方法一：</strong>每个模块的保存接口执行保存成功后，记录下日志，这样“提交申请”接口只校验每个模块的保存接口是否都执行过，执行过则可以认为数据已经通过了校验。</p><p>这个方法我觉得是可行的，但最后没采用，没采用的原因有：<br>1、我们有些模块的保存是其他系统负责的，这块内容的校验需要另外开发<br>2、有些模块并不是所有情况下都必填，如“当业务类型=XXX时，业务标签模块不展示”，这会导致这个方法的实现代码需要根据特殊规则特殊处理，不是一套通用的代码（但是若建立一张配置表，配置内容是在XX情况下哪些模块必填，校验前先读这张配置表，只检查必填模块的保存接口的日志，最后的代码应该可以做到通用）<br>3、有些业务方案，是从别的系统的方案（这类方案的结构和内容与业务方案有很多重叠，但不是业务方案）初始化过来，这时候即使方案内容完整，用户也必须在每个模块点击保存，才能提交成功</p><p><strong>方法二：</strong>只校验每个模块中的某几个字段是否为空，这些字段不为空则认为这个字段所在的模块执行过保存接口。</p><p>这是个偷懒的方法。这个方法首先要找出哪些字段不为空可以代表它所在的模块执行过保存接口，第一这些字段在业务方案初始化时一定为空（无论是不是从别的方案复制），第二这些字段在任何情况下都必填。</p><p>这个方法我们使用了一段时间，后来发现我们的业务方案中，并不是每个模块都存在符合这两点要求的字段，大部分字段只满足其中一个要求，导致经常漏校验。。</p><p>最后我根据方法二的使用经验，稍加改造，做出了方法三。</p><h1 id="最后使用的方法"><a href="#最后使用的方法" class="headerlink" title="最后使用的方法"></a>最后使用的方法</h1><p>我从方法二的经验教训中发现，既然不存在符合要求的字段，那么只能校验每个模块的所有字段必填，才能保证每个模块的保存接口执行过。但每个模块都存在条件必填的字段，我必须先识别出哪些字段在当前条件下必填，再依次校验这些字段不为空。</p><p>因为业务方案的字段和规则很容易变更，所以应该用配置表，灵活配置每个模块下需要校验的字段，以及它们必填的条件，还能配置这些字段内容的正确性校验规则，如“业务币种”字段有个正确性规则：业务类型=A时，业务币种必须为人民币。</p><p>我设计的配置表结构如下：（为了方便理解，模块名称和字段名称都写了中文，实际上是代码里的字段名）</p><img src="/2022/04/03/complete-valid/%E9%85%8D%E7%BD%AE%E8%A1%A8%E6%A0%B7%E4%BE%8B.PNG" class="" title="配置表样例"><p>这张配置表，通过表达式计算（我使用的表达式引擎是 Aviator），可以判断出各个场景下必填的模块和字段，还能顺便判断值的正确性。必填判断表达式的计算结果为 TRUE 说明模块/字段必填，正确性判断表达式的计算结果为 TRUE 说明值正确。</p><p>根据这张配置表写出的校验代码逻辑也非常简单，先筛选出当前业务方案中哪些模块必填，再依次校验这些模块的数据：先筛选出哪些字段必填，校验这些字段不为空，若有配置正确性判断表达式，则校验这些必填字段值的正确性。</p><p>使用这个方法后，校验工作都由配置表完成，因为配置表结构固定，所以校验代码不太需要修改，这块内容无代码工作量。需要开发代码的部分，只有查询当前方案每个模块的数据（用于被校验），和查询用于表达式计算的字段数据（如配置表中的bizType）。</p><p>查询用于表达式计算的字段数据，我是在调用完整性校验方法前查询好的。查询每个模块的数据，我是在判断出这个模块必填时才去查询。每个模块有不同的查询方法，需要定义一个抽象的查询方法由每个模块自行实现，校验到哪个模块就调用哪个模块的查询方法即可。</p><p>这个方法也有一定的<strong>局限性</strong>：</p><ol><li>只有那些校验规则简单的字段可以写入配置表。但是我们本身只是想通过校验一个模块下部分字段不为空来确认这个模块的保存接口执行过，所以少校验几个复杂的字段不影响结果</li><li>查询用于表达式计算的字段数据，这个没有做成配置，若以后新增的规则中多了一个用于判断的字段（如除了业务类型以外，多了一个业务风险类型），则需要修改代码。现在我是未雨绸缪，把一些目前没用于规则判断的数据也查询出来了</li></ol>]]></content>
      
      
      <categories>
          
          <category> 优化经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shiro 认证与授权流程</title>
      <link href="/2021/10/24/shiro-auth/"/>
      <url>/2021/10/24/shiro-auth/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>只要是权限校验框架，就离不开两个步骤：认证（Authentication）和授权（Authorization）。认证即“用户登录”，授权即“允许用户访问目标URI”。这篇博客介绍了Shiro  1.3.2版本认证与授权这两个过程的执行链条，未涉及到更高级的功能（如单点登录、RememberMe）。</p><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>Shiro 认证的入口很简单，就是下面三行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line">subject.login(token);</span><br></pre></td></tr></table></figure><p>这三行代码写在哪里由我们自己定。</p><p>第一行，是将用户输入的 username、password 封装成<code>UsernamePasswordToken</code>对象，这个类的顶级父类接口是<code>AuthenticationToken</code>，后面进入<code>Realm</code>中被认证的就是它。</p><p>第二行调用<code>SecurityUtils.getSubject()</code>取一个<code>Subject</code>对象，这个方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Subject <span class="title">getSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Subject subject = ThreadContext.getSubject();</span><br><span class="line"><span class="keyword">if</span> (subject == <span class="keyword">null</span>) &#123;</span><br><span class="line">subject = (<span class="keyword">new</span> Subject.Builder()).buildSubject();</span><br><span class="line">ThreadContext.bind(subject);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在认证代码这里，从 ThreadContext 是可以取到 subject 对象的，在这里 subject 对象使用的实现类是<code>WebDelegatingSubject</code>。ThreadContext 是用<code>ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources</code>保存 subject 对象。</p><blockquote><p>问题：ThreadContext 中的 subject 对象怎么来的？简单地说，是用户请求经过 SpringShiroFilter 时，SpringShiroFilter 根据请求创建 subject 并设置到 ThreadContext 中的，详细见博客《SpringShiroFilter原理》的“工作原理-创建 Subject 对象”一节。</p></blockquote><p>第三行<code>subject.login(token)</code>这个方法便是完整的用户认证的过程。步骤简述如下：</p><ol><li>包含 username 和 password 的<code>UsernamePasswordToken</code>对象进入<code>Subject.login()</code>方法</li><li>在 Subject.login() 中，调用<code>SecurityManager.login()</code>方法，使用的 SecurityManager 实现类是在“Shiro配置文件”指定的，一般是<code>DefaultWebSecurityManager</code></li><li>在 SecurityManager.login() 中，调用<code>Authenticator.authenticate()</code>方法。默认调用到 Authenticator 的实现类<code>ModularRealmAuthenticator</code></li><li>在 ModularRealmAuthenticator.authenticate() 中，当其成员<code>Collection&lt;Realm&gt; realms</code>只有一个元素时（有多个元素的情况此处不提），就调用这一个<code>Realm</code>的<code>getAuthenticationInfo()</code>方法。”realms”的元素数量取决于在“Shiro配置文件”中给 SecurityManager 设置了几个 Realm 实现类</li><li>Realm 接口的 getAuthenticationInfo 方法由子类<code>AuthenticatingRealm</code>实现，这个类定义了钩子方法<code>doGetAuthenticationInfo</code>，交给我们自定义 Realm 实现。这个方法就是根据入参<code>AuthenticationToken</code>对象（UsernamePasswordToken 的接口类型），查询用户原信息，校验用户密码等，即进行所谓的<strong>认证</strong>。认证成功会返回<code>AuthenticationInfo</code>对象，一般使用实现类<code>SimpleAuthenticationInfo</code></li><li>若认证失败，可抛出<code>AuthenticationException</code>及其子类的异常，包括：DisabledAccountException（禁用的帐号）、UnknownAccountException（错误的帐号）、IncorrectCredentialsException （错误的凭证）等。这些异常可在调用<code>subject.login(token)</code>的地方捕获并处理</li><li>认证成功后，Realm 接口的 getAuthenticationInfo 方法返回的 AuthenticationInfo 对象一直向上传递到 SecurityManager.login() 方法</li><li>在 SecurityManager.login() 中，获得 AuthenticationInfo 后，会创建一个<strong>新 Subject 对象</strong>。这个<strong>新 Subject 对象</strong>中保存了代表用户身份的<code>PrincipalCollection principals</code>，这个 principals 的来源就是 AuthenticationInfo</li><li>SecurityManager.login() 将创建的“新subject”向上传递到 subject.login() 方法，“新subject”中包含的<code>principals</code>和<code>authenticated</code>（已认证标志，认证成功后设置为TRUE） 会更新到“旧subject”（即 login 方法的调用方）中</li></ol><p>至此，认证完成。</p><blockquote><p>如果配置启用“Session”（默认启用），在 SecurityManager.login() 获得 AuthenticationInfo 后创建新 subject 时，会同时创建一个 Session 接口类型的对象（这个 Session 接口是 Shiro 定义的，不是 Tomcat 定义的）。这个 session 对象中也会保存 principals，并且这个 session 对象会被保存到内存中，sessionId 写入响应头，下次用户请求会带着 sessionId 过来，取出内存中保存的 session 对象。<br>这部分内容详见博客《SpringShiroFilter原理》的“工作原理-创建 Subject 对象”一节。</p></blockquote><p>认证成功流程：</p><img src="/2021/10/24/shiro-auth/authentication_success.PNG" class="" title="认证成功"><p>认证失败流程：</p><img src="/2021/10/24/shiro-auth/authentication_fail.PNG" class="" title="认证失败"><h2 id="AuthenticationInfo和getAuthenticationInfo方法"><a href="#AuthenticationInfo和getAuthenticationInfo方法" class="headerlink" title="AuthenticationInfo和getAuthenticationInfo方法"></a>AuthenticationInfo和getAuthenticationInfo方法</h2><p>Shiro 的<code>Realm</code>接口有两个重要的实现类：<code>AuthorizingRealm</code>(授权)和<code>AuthenticatingRealm</code>(认证)，并且“认证”是“授权”的父类。<code>AuthenticatingRealm.getAuthenticationInfo()</code>是执行用户认证逻辑的方法，返回<code>AuthenticationInfo</code>对象，一般使用实现类<code>SimpleAuthenticationInfo</code>。</p><p><code>AuthenticationInfo</code>接口只定义了2个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationInfo</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function">PrincipalCollection <span class="title">getPrincipals</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，”getPrincipals”返回的代表了用户身份，是个集合对象，说明支持一个用户多个“身份”。这个“身份”可以是字符串，也可以是一个 Object 对象。”getCredentials”返回的代表了用户身份的密码，一般保存的是用户账号的密码字符串。</p><p>在<code>AuthenticatingRealm.getAuthenticationInfo()</code>方法中，先尝试从“缓存”中取 AuthenticationInfo，若取出的 info 为 null，则调用本类的<code>doGetAuthenticationInfo</code>方法，这个方法由子类实现。从 doGetAuthenticationInfo 方法返回 info 后，会把它保存到“缓存”中。最后，会判断这个 info 与 AuthenticationToken 中的 credentials 是否一致，不一致则认证失败，一致则返回 info 对象。</p><p>AuthenticatingRealm 中的“缓存”，是用下面这两个方法取的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Cache&lt;Object, AuthenticationInfo&gt; <span class="title">getAvailableAuthenticationCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Cache&lt;Object, AuthenticationInfo&gt; cache = getAuthenticationCache(); <span class="comment">// 取属性authenticationCache，默认为null</span></span><br><span class="line"><span class="keyword">boolean</span> authcCachingEnabled = isAuthenticationCachingEnabled(); <span class="comment">// 返回值默认false</span></span><br><span class="line"><span class="keyword">if</span> (cache == <span class="keyword">null</span> &amp;&amp; authcCachingEnabled) &#123;</span><br><span class="line">cache = getAuthenticationCacheLazy(); <span class="comment">// 懒加载缓存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Cache&lt;Object, AuthenticationInfo&gt; <span class="title">getAuthenticationCacheLazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.authenticationCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">log.trace(<span class="string">"No authenticationCache instance set.  Checking for a cacheManager..."</span>);</span><br><span class="line"></span><br><span class="line">CacheManager cacheManager = getCacheManager(); <span class="comment">// 取属性cacheManager，默认为null</span></span><br><span class="line"><span class="keyword">if</span> (cacheManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">String cacheName = getAuthenticationCacheName(); <span class="comment">// cacheName有默认值</span></span><br><span class="line">log.debug(<span class="string">"CacheManager [&#123;&#125;] configured.  Building authentication cache '&#123;&#125;'"</span>, cacheManager, cacheName);</span><br><span class="line"><span class="keyword">this</span>.authenticationCache = cacheManager.getCache(cacheName); <span class="comment">// 调用cacheManager.getCache()方法获取缓存工具对象</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.authenticationCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在默认配置下，AuthenticatingRealm 不会使用缓存，所以用户认证时一定会进入 doGetAuthenticationInfo 方法。【默认不使用缓存的原因应该是，用户一般不会多次重复登录。</p><h2 id="与Spring-Security的区别"><a href="#与Spring-Security的区别" class="headerlink" title="与Spring Security的区别"></a>与Spring Security的区别</h2><ol><li>Shiro 的认证入口在<code>subject.login(token)</code>方法。Spring Security 的认证入口是<code>UsernamePasswordAuthenticationFilter.doFilter()</code>方法</li><li>Shrio 的调用链条简单，需要实现的就是<code>AuthenticatingRealm.doGetAuthenticationInfo()</code>方法，在这里实现查询原用户信息、校验用户名密码这2个必要步骤的逻辑。Spring Security 把这两个步骤分开在了<code>UserDetailsService</code>和<code>AuthenticationProvider</code>上，要分别实现（不用Spring默认配置的话）</li><li>Shiro 没有做默认实现类和自动装配。Spring Security 提供了几乎所有接口的默认实现类和自动装配，所以只要引入jar包就能用</li></ol><h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><p>Shiro 实现授权校验的方式有多种：</p><ol><li>在“Shiro配置文件”为需要授权的 URI 配置授权类的过滤器，即<code>AuthorizationFilter</code>的子类，如<code>PermissionsAuthorizationFilter</code></li><li>在需要授权的接口 Controller 方法上使用<code>@RequiresPermissions</code>、<code>@RequiresRoles</code>注解</li></ol><p>无论使用哪种方式，授权校验时调用的都是<code>Subject</code>类中的这些方法：</p><p>权限校验方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(String permission)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(Permission permission)</span></span>;</span><br><span class="line"><span class="keyword">boolean</span>[] isPermitted(String... permissions);</span><br><span class="line"><span class="keyword">boolean</span>[] isPermitted(List&lt;Permission&gt; permissions);</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPermittedAll</span><span class="params">(String... permissions)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPermittedAll</span><span class="params">(Collection&lt;Permission&gt; permissions)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(String permission)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(Permission permission)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkPermissions</span><span class="params">(String... permissions)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkPermissions</span><span class="params">(Collection&lt;Permission&gt; permissions)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br></pre></td></tr></table></figure><p>角色校验方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasRole</span><span class="params">(String roleIdentifier)</span></span>;</span><br><span class="line"><span class="keyword">boolean</span>[] hasRoles(List&lt;String&gt; roleIdentifiers);</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasAllRoles</span><span class="params">(Collection&lt;String&gt; roleIdentifiers)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkRole</span><span class="params">(String roleIdentifier)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkRoles</span><span class="params">(Collection&lt;String&gt; roleIdentifiers)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkRoles</span><span class="params">(String... roleIdentifiers)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br></pre></td></tr></table></figure><p>这些方法由<code>DelegatingSubject</code>实现，每个方法的实现方式就是调用成员<code>SecurityManager</code>的同名同返回类型方法，以下面这个方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(String permission)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasPrincipals() &amp;&amp; securityManager.isPermitted(getPrincipals(), permission);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法参数上，SecurityManager 的同名方法要多传一个<code>PrincipalCollection principals</code>，DelegatingSubject 会取出自己的 principals 传给 SecurityManager。如果配置启用“Session”，已登录用户的请求经过 SpringShiroFilter 时，SpringShiroFilter 会根据用户请求取出 session，再从 session 中取出 principals，设置到这里的 subject 对象。</p><hr><p><strong>如果禁用“Session”</strong>，那么在调用这些方法前，需要自己往 subject 对象中设置 principals 再调用这些方法。</p><p>往 subject 中设置 principals，并替换原有的由 SpringShiroFilter 创建的 subject 对象的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧subject</span></span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的UsernamePasswordToken、SimpleAuthenticationInfo中设置的 principal=userId，后面会设置到新创建的subject对象中</span></span><br><span class="line">UsernamePasswordToken usernamePasswordToken = <span class="keyword">new</span> UsernamePasswordToken(userId, (String) <span class="keyword">null</span>);</span><br><span class="line">SimpleAuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(userId, <span class="keyword">null</span>, getName());</span><br><span class="line">SecurityManager securityManager = SecurityUtils.getSecurityManager();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把UsernamePasswordToken、SimpleAuthenticationInfo设置到SubjectContext中</span></span><br><span class="line">SubjectContext context = <span class="keyword">new</span> DefaultSubjectContext();</span><br><span class="line">context.setAuthenticated(<span class="keyword">true</span>);</span><br><span class="line">context.setAuthenticationToken(usernamePasswordToken);</span><br><span class="line">context.setAuthenticationInfo(info);</span><br><span class="line">context.setSubject(subject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用securityManager方法，根据SubjectContext创建新subject</span></span><br><span class="line">subject = securityManager.createSubject(context);</span><br><span class="line"><span class="comment">// ThreadContext中保存的是旧subject，换成新的</span></span><br><span class="line">ThreadContext.bind(subject);</span><br></pre></td></tr></table></figure><p>这段代码要写在调用那些权限校验方法、角色校验方法前。</p><hr><p>回到 Subject 的授权校验方法。上面说到，Subject 的这些方法都是调用 SecurityManager 的同名同返回类型方法。而 SecurityManager 的这些方法又是调用它的成员<code>ModularRealmAuthorizer</code>的相同方法（同名同参同返回）。然后，ModularRealmAuthorizer 中又是调用<code>AuthorizingRealm</code>的相同方法（同名同参同返回）。所以，要研究 Shiro 的授权逻辑，只要研究 AuthorizingRealm 就行。【上面提到过，它的父类是“认证”Realm，AuthenticatingRealm</p><p>上面提到的 SecurityManager、ModularRealmAuthorizer、AuthorizingRealm 这3个类，它们的校验方法全部相同，都是因为它们继承了同一个接口<code>Authorizer</code>。即，SecurityManager、ModularRealmAuthorizer 依赖着与自己相同接口的成员，只有 AuthorizingRealm 真正实现了校验逻辑。</p><p>Authorizer 接口定义的校验方法和前面我们列出的 Subject 定义的几乎一模一样，唯一不同的就是 Authorizer 的这些方法的参数多了一个<code>PrincipalCollection principals</code>。下面根据 AuthorizingRealm 的实现，列出这些方法的作用。</p><h2 id="授权校验方法"><a href="#授权校验方法" class="headerlink" title="授权校验方法"></a>授权校验方法</h2><p><strong>一、权限校验</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(PrincipalCollection principals, String permission)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(PrincipalCollection principals, Permission permission)</span></span>;</span><br></pre></td></tr></table></figure><p>判断用户是否具有某个权限。String 类型的会先转成<code>Permission</code>类型的再判断，这点同下面的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] isPermitted(PrincipalCollection principals, String... permissions);</span><br><span class="line"><span class="keyword">boolean</span>[] isPermitted(PrincipalCollection principals, List&lt;Permission&gt; permissions);</span><br></pre></td></tr></table></figure><p>判断用户是否具有参数列出的权限，返回每个权限的校验结果数组。<br>PS: 实际上是对每个权限遍历调用<code>isPermitted(PrincipalCollection principals, Permission permission)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPermittedAll</span><span class="params">(PrincipalCollection principals, String... permissions)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPermittedAll</span><span class="params">(PrincipalCollection principals, Collection&lt;Permission&gt; permissions)</span></span>;</span><br></pre></td></tr></table></figure><p>判断用户是否具有参数列出的权限，与上一个不同点是，只有每个权限校验都返回 true，这个方法才返回 true。<br>PS: 实际上是对每个权限遍历调用<code>isPermitted(PrincipalCollection principals, Permission permission)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(PrincipalCollection principals, String permission)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(PrincipalCollection principals, Permission permission)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br></pre></td></tr></table></figure><p>作用同<code>isPermitted</code>方法，不同点是，若用户无权限，会抛出<code>UnauthorizedException</code>。<br>PS: 实际上也是调用<code>isPermitted(PrincipalCollection principals, Permission permission)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkPermissions</span><span class="params">(PrincipalCollection principals, String... permissions)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkPermissions</span><span class="params">(PrincipalCollection principals, Collection&lt;Permission&gt; permissions)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br></pre></td></tr></table></figure><p>对参数列出的所有权限，遍历调用上一个<code>checkPermission</code>方法，只要校验出一个无权限，就抛出<code>UnauthorizedException</code>。</p><p><strong>二、角色校验</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasRole</span><span class="params">(PrincipalCollection principals, String roleIdentifier)</span></span>;</span><br></pre></td></tr></table></figure><p>判断用户是否具有某个角色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] hasRoles(PrincipalCollection principals, List&lt;String&gt; roleIdentifiers);</span><br></pre></td></tr></table></figure><p>判断用户是否具有参数列出的角色，返回每个角色的校验结果数组。<br>PS: 实际上是对每个角色遍历调用上一个<code>hasRole</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasAllRoles</span><span class="params">(PrincipalCollection principals, Collection&lt;String&gt; roleIdentifiers)</span></span>;</span><br></pre></td></tr></table></figure><p>判断用户是否具有参数列出的角色，与上一个不同点是，只有每个角色校验都返回 true，这个方法才返回 true。<br>PS: 实际上是对每个角色遍历调用<code>hasRole</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkRole</span><span class="params">(PrincipalCollection principals, String roleIdentifier)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br></pre></td></tr></table></figure><p>作用同<code>hasRole</code>方法，不同点是，若用户无角色，会抛出<code>UnauthorizedException</code>。<br>PS: 实际上也是调用<code>hasRole</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkRoles</span><span class="params">(PrincipalCollection principals, Collection&lt;String&gt; roleIdentifiers)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkRoles</span><span class="params">(PrincipalCollection principals, String... roleIdentifiers)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br></pre></td></tr></table></figure><p>对参数列出的所有角色，遍历调用上一个<code>checkRole</code>方法，只要校验出一个无角色，就抛出<code>UnauthorizedException</code>。</p><p><strong>总结：</strong></p><p>通过这些授权校验方法的源码，我们可以看出，权限校验方法的基础是<code>isPermitted(PrincipalCollection principals, Permission permission)</code>，角色校验方法的基础是<code>hasRole</code>。AuthorizingRealm 对这两个方法的实现思路相同，如下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 权限</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(PrincipalCollection principals, Permission permission)</span> </span>&#123;</span><br><span class="line">AuthorizationInfo info = getAuthorizationInfo(principals);</span><br><span class="line"><span class="keyword">return</span> isPermitted(permission, info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isPermitted</span><span class="params">(Permission permission, AuthorizationInfo info)</span> </span>&#123;</span><br><span class="line">Collection&lt;Permission&gt; perms = getPermissions(info);</span><br><span class="line"><span class="keyword">if</span> (perms != <span class="keyword">null</span> &amp;&amp; !perms.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">for</span> (Permission perm : perms) &#123;</span><br><span class="line"><span class="keyword">if</span> (perm.implies(permission)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 角色</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasRole</span><span class="params">(PrincipalCollection principal, String roleIdentifier)</span> </span>&#123;</span><br><span class="line">AuthorizationInfo info = getAuthorizationInfo(principal);</span><br><span class="line"><span class="keyword">return</span> hasRole(roleIdentifier, info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasRole</span><span class="params">(String roleIdentifier, AuthorizationInfo info)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> info != <span class="keyword">null</span> &amp;&amp; info.getRoles() != <span class="keyword">null</span> &amp;&amp; info.getRoles().contains(roleIdentifier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即校验权限/角色前，都要先调用<code>getAuthorizationInfo</code>方法获取<code>AuthorizationInfo</code>对象，再用这个<code>AuthorizationInfo</code>对象进行校验。</p><h2 id="AuthorizationInfo和getAuthorizationInfo方法"><a href="#AuthorizationInfo和getAuthorizationInfo方法" class="headerlink" title="AuthorizationInfo和getAuthorizationInfo方法"></a>AuthorizationInfo和getAuthorizationInfo方法</h2><p>上面讲到认证逻辑时，<code>AuthenticatingRealm.getAuthenticationInfo()</code>返回的对象是<code>AuthenticationInfo</code>。这里，<code>AuthorizingRealm.getAuthorizationInfo()</code>返回的对象是<code>AuthorizationInfo</code>，一般使用实现类<code>SimpleAuthorizationInfo</code>。</p><p><code>AuthorizationInfo</code>接口只定义了3个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthorizationInfo</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function">Collection&lt;String&gt; <span class="title">getRoles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Collection&lt;String&gt; <span class="title">getStringPermissions</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Collection&lt;Permission&gt; <span class="title">getObjectPermissions</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，这个对象就是用来保存用户的“角色(字符串)”、“权限(字符串)”、“权限(Permission类型)”。</p><p>在<code>AuthorizingRealm.getAuthorizationInfo()</code>方法中，先尝试从“缓存”中取 AuthorizationInfo，若取出的 info 为 null，则调用本类的<code>doGetAuthorizationInfo</code>方法，这个方法由子类实现。从 doGetAuthorizationInfo 方法返回 info 后，会把它保存到“缓存”中。最后返回 info 对象。</p><p>AuthorizingRealm 取“缓存”的方法与 AuthenticatingRealm 完全一致（源码如下），不同的是，AuthorizingRealm 是默认会使用缓存的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Cache&lt;Object, AuthorizationInfo&gt; <span class="title">getAvailableAuthorizationCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Cache&lt;Object, AuthorizationInfo&gt; cache = getAuthorizationCache(); <span class="comment">// 取属性authorizationCache，默认为null</span></span><br><span class="line"><span class="keyword">if</span> (cache == <span class="keyword">null</span> &amp;&amp; isAuthorizationCachingEnabled()) &#123; <span class="comment">// isAuthorizationCachingEnabled()默认返回true，这点与AuthorizingRealm不同</span></span><br><span class="line">cache = getAuthorizationCacheLazy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Cache&lt;Object, AuthorizationInfo&gt; <span class="title">getAuthorizationCacheLazy</span><span class="params">()</span> </span>&#123; <span class="comment">// 这个方法省略了日志打印部分</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.authorizationCache == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">CacheManager cacheManager = getCacheManager();</span><br><span class="line"><span class="keyword">if</span> (cacheManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">String cacheName = getAuthorizationCacheName();</span><br><span class="line"><span class="keyword">this</span>.authorizationCache = cacheManager.getCache(cacheName);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.authorizationCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 AuthorizingRealm 默认会使用缓存，所以如果有给 AuthorizingRealm 配置缓存，每次权限校验就不都会进入到 doGetAuthorizationInfo 方法了。</p><h2 id="权限字符串的转换"><a href="#权限字符串的转换" class="headerlink" title="权限字符串的转换"></a>权限字符串的转换</h2><p>在我们自定义实现的<code>doGetAuthorizationInfo</code>方法中，一般是从数据库中取出用户的<strong>权限字符串</strong>保存到<code>AuthorizationInfo</code>中。但是我们知道，进行权限校验时，权限字符串都会被转成<code>Permission</code>类型的<strong>权限对象</strong>再进行判断。负责这个转换的是 AuthorizingRealm 的成员<code>PermissionResolver</code>，默认使用实现类<code>WildcardPermissionResolver</code>。</p><p>因为这个原因，Shiro 的权限字符串要遵循<code>WildcardPermissionResolver</code>要求的格式：<code>资源标识符:操作:对象实例ID</code>。如”system:user:update”中，”system:user”是资源标识符，”update”是操作，对象实例ID为空。对象实例ID一般用不到，因为太具体了。</p><p>权限字符串支持符号：”:”表示资源/操作/实例的分割；”,”表示操作的分割；”*”表示任意资源/操作/实例。</p><p>举例：</p><ol><li>用 system:user:update,delete 验证 system:user:update,system:user:delete 可以，反之不行</li><li>用 system:user:* 验证 system:user:update,delete,add 可以，反之不行</li><li>*:delete 等同于 system:user:delete，也等同于 user:delete（区别是资源标识符是一级还是两级）</li></ol><blockquote><p>如果自定义了 PermissionResolver 实现，那么可以自定义将权限字符串转换为 Permission 对象的方法，字符串格式也就可以自己定。</p></blockquote><h2 id="使用权限注解时的配置"><a href="#使用权限注解时的配置" class="headerlink" title="使用权限注解时的配置"></a>使用权限注解时的配置</h2><p>前面说到，Shiro 实现授权校验的方式有：</p><ol><li>在“Shiro配置文件”为需要授权的 URI 配置授权类的过滤器，即<code>AuthorizationFilter</code>的子类，如<code>PermissionsAuthorizationFilter</code></li><li>在需要授权的接口 Controller 方法上使用<code>@RequiresPermissions</code>、<code>@RequiresRoles</code>注解</li></ol><p>如果使用第二种的注解方式，在“Shiro配置文件中”除了常规的配置，还需要加上以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(org.apache.shiro.mgt.SecurityManager securityManager)</span></span>&#123;</span><br><span class="line">AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line"><span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">defaultAdvisorAutoProxyCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">defaultAdvisorAutoProxyCreator.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span> defaultAdvisorAutoProxyCreator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个 Bean 是<code>AuthorizationAttributeSourceAdvisor</code>是 Shiro 提供的，它间接实现了接口<code>Advisor</code>。</p><p>第二个 Bean 是<code>DefaultAdvisorAutoProxyCreator</code>，它是 Spring 提供的，只要配置了这个 Bean，在项目启动时，它会扫描所有 Advisor 类型的 Bean，注入到 IoC 容器，再用这些 Advisor Bean 给每个符合条件的 Bean 创建代理类。它利用了接口<code>InstantiationAwareBeanPostProcessor</code>的特性，在每个被代理的 Bean <strong>实例化</strong>前创建它们的代理类并返回，所以这些被代理的 Bean 保存在 IoC 容器中的是它们的代理类对象。当这些 Bean 的方法满足切点匹配时，会调用代理它们的 Advisor 对象的成员<code>Advice advice</code>的<code>invoke</code>方法。</p><p>举个例子，若访问带<code>@RequiresRoles</code>的 Controller 接口，角色判断的过程是： CglibAopProxy.intercept() -&gt; ReflectiveMethodInvocation.proceed() -&gt; AopAllianceAnnotationsAuthorizingMethodInterceptor.invoke() -&gt; AnnotationsAuthorizingMethodInterceptor.assertAuthorized() -&gt; RoleAnnotationMethodInterceptor.assertAuthorized() -&gt; RoleAnnotationHandler.assertAuthorized()</p><p>其中，<code>AopAllianceAnnotationsAuthorizingMethodInterceptor</code>就是第一个 Bean<code>AuthorizationAttributeSourceAdvisor</code>的成员，它自己的成员又包含如下；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;AuthorizingAnnotationMethodInterceptor&gt; methodInterceptors = = <span class="keyword">new</span> ArrayList&lt;AuthorizingAnnotationMethodInterceptor&gt;(<span class="number">5</span>);</span><br><span class="line">methodInterceptors.add(<span class="keyword">new</span> RoleAnnotationMethodInterceptor()); <span class="comment">// 处理@RequiresRoles</span></span><br><span class="line">methodInterceptors.add(<span class="keyword">new</span> PermissionAnnotationMethodInterceptor()); <span class="comment">// 处理@RequiresPermissions</span></span><br><span class="line">methodInterceptors.add(<span class="keyword">new</span> AuthenticatedAnnotationMethodInterceptor());</span><br><span class="line">methodInterceptors.add(<span class="keyword">new</span> UserAnnotationMethodInterceptor());</span><br><span class="line">methodInterceptors.add(<span class="keyword">new</span> GuestAnnotationMethodInterceptor());</span><br></pre></td></tr></table></figure><p>PS: AopAllianceAnnotationsAuthorizingMethodInterceptor 给这个成员赋值时，在它的父类构造方法中按上面的代码赋值了一遍，在它自己的构造方法中又按这样赋值一遍。</p><p><code>AnnotationsAuthorizingMethodInterceptor</code>是<code>AopAllianceAnnotationsAuthorizingMethodInterceptor</code>的直接父类。</p><h2 id="处理UnauthorizedException"><a href="#处理UnauthorizedException" class="headerlink" title="处理UnauthorizedException"></a>处理UnauthorizedException</h2><p>如果是使用权限注解，若用户无权限，会抛出<code>UnauthorizedException</code>异常，这个异常默认情况下不会被处理，直接打印堆栈。若要处理，有两种方法。</p><p>一是如果要自动跳转无权访问页面，则在配置了无权访问页面的 viewName 后，再这样配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMappingExceptionResolver <span class="title">simpleMappingExceptionResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SimpleMappingExceptionResolver simpleMappingExceptionResolver = <span class="keyword">new</span> SimpleMappingExceptionResolver();</span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.setProperty(<span class="string">"org.apache.shiro.authz.UnauthorizedException"</span>, <span class="string">"unauth"</span>); <span class="comment">// unauth是无权访问页面的viewName</span></span><br><span class="line">simpleMappingExceptionResolver.setExceptionMappings(properties);</span><br><span class="line"><span class="keyword">return</span> simpleMappingExceptionResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二是如果不跳转页面，只返回 JSON 响应时，加一个如下所示的 ControllerAdvice：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span> <span class="comment">// 响应体是json格式就必须加这个注解</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = UnauthorizedException<span class="class">.<span class="keyword">class</span>) // 指定抛出的异常类型</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">JSONObject</span> <span class="title">handleException</span>(<span class="title">UnauthorizedException</span> <span class="title">ex</span>) </span>&#123; <span class="comment">// 在这个方法中写抛出异常后的处理</span></span><br><span class="line">        System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">        JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        json.put(<span class="string">"code"</span>, <span class="string">"1111"</span>);</span><br><span class="line">        json.put(<span class="string">"msg"</span>, <span class="string">"当前用户无权限"</span>);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便一提，在配置 Shiro 时，可能你会配置一个<code>ShiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unauth&quot;);</code>，这个也是配置403自动跳转页面，但只有你在 Shiro 过滤器链中使用了<code>AuthorizationFilter</code>子类，且这个子类用于权限校验时，才生效。</p><h1 id="Shiro-配置"><a href="#Shiro-配置" class="headerlink" title="Shiro 配置"></a>Shiro 配置</h1><p>读完上面的认证与授权逻辑，可以得出，要实现一般的认证、授权需求，一般需要自己实现以下两个模块：</p><ol><li>自定义 Realm，继承自<code>AuthorizingRealm</code>，实现<code>doGetAuthorizationInfo</code>(授权)和<code>doGetAuthenticationInfo</code>(认证)方法。这个必须要实现</li><li>自定义 Filter，根据实际需要继承 Shiro 已有的 Filter 再自定义。这个可以不实现</li></ol><p>配置 Shiro 时，一般配置以下内容，可以满足大部分认证授权需求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">// 配置自定义Realm</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CustomRealm <span class="title">customRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CustomRealm();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shiro默认启用session，对session的配置，不是必须配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultWebSessionManager <span class="title">defaultWebSessionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DefaultWebSessionManager defaultWebSessionManager = <span class="keyword">new</span> DefaultWebSessionManager();</span><br><span class="line">defaultWebSessionManager.setGlobalSessionTimeout(<span class="number">3600</span> * <span class="number">1000</span>);<span class="comment">// 会话过期时间，单位：毫秒(在无操作时开始计时)</span></span><br><span class="line">defaultWebSessionManager.setSessionValidationSchedulerEnabled(<span class="keyword">true</span>); <span class="comment">// 开启定时清理失效会话，如用户直接关闭浏览器</span></span><br><span class="line">defaultWebSessionManager.setSessionIdCookieEnabled(<span class="keyword">true</span>); <span class="comment">// 设为false将不会设置 Session-Id Cookie</span></span><br><span class="line"><span class="keyword">return</span> defaultWebSessionManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置SecurityManager</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultSecurityManager <span class="title">securityManager</span><span class="params">(CustomRealm customRealm, DefaultWebSessionManager defaultWebSessionManager)</span> </span>&#123;</span><br><span class="line">DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager(customRealm);</span><br><span class="line">securityManager.setSessionManager(defaultWebSessionManager);</span><br><span class="line">SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"><span class="keyword">return</span> securityManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要用bean的方式添加自定义filter，会因为bean加载顺序的问题把这个filter放在anonFilter前面</span></span><br><span class="line"><span class="comment">//@Bean</span></span><br><span class="line"><span class="comment">//public PermissionCheckFilter permissionCheckFilter() &#123;</span></span><br><span class="line"><span class="comment">//return new PermissionCheckFilter();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilter</span><span class="params">(DefaultSecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">ShiroFilterFactoryBean factory = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">factory.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">factory.setLoginUrl(<span class="string">"/login"</span>); <span class="comment">// 登录页URI，在重定向到登录页时用到</span></span><br><span class="line">factory.setUnauthorizedUrl(<span class="string">"/unauth"</span>); <span class="comment">// 403页面URI，在重定向到403页时用到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加自定义Filter</span></span><br><span class="line">Map&lt;String, Filter&gt; filtersMap = <span class="keyword">new</span> LinkedHashMap&lt;String, Filter&gt;();</span><br><span class="line">filtersMap.put(<span class="string">"permissionCheckFilter"</span>, <span class="keyword">new</span> PermissionCheckFilter());</span><br><span class="line">factory.setFilters(filtersMap);</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">// 匹配上的URI走对应的Filter</span></span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/logout"</span>, <span class="string">"logout"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/login"</span>, <span class="string">"anon"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/login/submit"</span>, <span class="string">"anon"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/getRSAKey"</span>, <span class="string">"anon"</span>);</span><br><span class="line">    filterChainDefinitionMap.put(<span class="string">"/unauth"</span>, <span class="string">"anon"</span>);</span><br><span class="line">    filterChainDefinitionMap.put(<span class="string">"/*.ico"</span>, <span class="string">"anon"</span>);</span><br><span class="line"><span class="comment">//filterChainDefinitionMap.put("/**", "permissionCheckFilter");</span></span><br><span class="line">System.out.println(filterChainDefinitionMap);</span><br><span class="line">factory.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="禁用Session"><a href="#禁用Session" class="headerlink" title="禁用Session"></a>禁用Session</h2><p>关于是否启用 Session，有两个地方控制，一是<code>DefaultSessionStorageEvaluator</code>的属性<code>sessionStorageEnabled</code>，二是<code>DefaultWebSessionManager</code>的属性<code>sessionIdCookieEnabled</code>。这两个属性默认为 true。</p><p><code>DefaultSessionStorageEvaluator</code>是<code>DefaultSubjectDAO</code>的成员。在用户认证成功后创建新 Subject 后，<code>DefaultSubjectDAO</code>负责把 Subject 中的信息保存到 Subject 中的 Session 对象中，如果没有 Session 对象，就调用<code>DefaultWebSessionManager</code>创建 Session 对象和 sessionId 字符串，将这两者保存到<code>MemorySessionDAO</code>中，并将 sessionId 写到响应头”Set-Cookie”中。</p><p>如果<code>DefaultSessionStorageEvaluator</code>的属性<code>sessionStorageEnabled</code>设置为 false，则在用户认证成功后创建新 Subject 后，DefaultSubjectDAO 什么也不做。如果<code>DefaultWebSessionManager</code>的属性<code>sessionIdCookieEnabled</code>设置为 false，虽然还会创建 Session，但最后不会将 sessionId 写到响应头中。</p><p>如果要禁用 Session，可以只设置<code>DefaultSessionStorageEvaluator</code>的属性<code>sessionStorageEnabled</code>为 false。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置SecurityManager</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">securityManager</span><span class="params">(ShiroRealm myRealm)</span> </span>&#123;</span><br><span class="line">DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">securityManager.setRealm(myRealm);</span><br><span class="line"></span><br><span class="line">DefaultSubjectDAO subjectDAO = <span class="keyword">new</span> DefaultSubjectDAO();</span><br><span class="line">DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = <span class="keyword">new</span> DefaultSessionStorageEvaluator();</span><br><span class="line">defaultSessionStorageEvaluator.setSessionStorageEnabled(<span class="keyword">false</span>);</span><br><span class="line">subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator);</span><br><span class="line"></span><br><span class="line">securityManager.setSubjectDAO(subjectDAO);</span><br><span class="line"><span class="keyword">return</span> securityManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置缓存"><a href="#配置缓存" class="headerlink" title="配置缓存"></a>配置缓存</h2><p>上面说到的 AuthenticatingRealm/AuthorizingRealm 在获取 AuthenticationInfo/AuthorizationInfo 时，都提到它们会先尝试从缓存中取。Shiro 默认情况下没有配置缓存。如果要配置缓存，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置SecurityManager</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">securityManager</span><span class="params">(ShiroRealm myRealm)</span> </span>&#123;</span><br><span class="line">DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">securityManager.setRealm(myRealm);</span><br><span class="line"></span><br><span class="line">DefaultSubjectDAO subjectDAO = <span class="keyword">new</span> DefaultSubjectDAO();</span><br><span class="line">DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = <span class="keyword">new</span> DefaultSessionStorageEvaluator();</span><br><span class="line">defaultSessionStorageEvaluator.setSessionStorageEnabled(<span class="keyword">false</span>);</span><br><span class="line">subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator);</span><br><span class="line"></span><br><span class="line">securityManager.setSubjectDAO(subjectDAO);</span><br><span class="line"><span class="comment">//自定义缓存实现,使用redis</span></span><br><span class="line">securityManager.setCacheManager(redisCacheManager());</span><br><span class="line"><span class="keyword">return</span> securityManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cacheManager 缓存 redis实现</span></span><br><span class="line"><span class="comment"> * 使用的是shiro-redis开源插件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">redisCacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">log.info(<span class="string">"===============(1)创建缓存管理器RedisCacheManager"</span>);</span><br><span class="line">RedisCacheManager redisCacheManager = <span class="keyword">new</span> RedisCacheManager();</span><br><span class="line">redisCacheManager.setRedisManager(redisManager());</span><br><span class="line"><span class="comment">//redis中针对不同用户缓存(此处的id需要对应user实体中的id字段,用于唯一标识)</span></span><br><span class="line">redisCacheManager.setPrincipalIdFieldName(<span class="string">"userId"</span>);</span><br><span class="line"><span class="comment">//用户权限信息缓存时间</span></span><br><span class="line">redisCacheManager.setExpire(<span class="number">200000</span>);</span><br><span class="line"><span class="keyword">return</span> redisCacheManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisManager <span class="title">redisManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">log.info(<span class="string">"===============(2)创建RedisManager,连接Redis..URL= "</span> + host + <span class="string">":"</span> + port);</span><br><span class="line">RedisManager redisManager = <span class="keyword">new</span> RedisManager();</span><br><span class="line">redisManager.setHost(host); <span class="comment">// 配置redis信息</span></span><br><span class="line">redisManager.setPort(Integer.parseInt(port));</span><br><span class="line">redisManager.setDatabase(database);</span><br><span class="line">redisManager.setTimeout(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.isEmpty(redisPassword)) &#123;</span><br><span class="line">redisManager.setPassword(redisPassword);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> redisManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们将<code>RedisCacheManager</code>设置到了<code>DefaultWebSecurityManager</code>中，这个动作会同时将 RedisCacheManager 设置到 DefaultWebSecurityManager 已保存的 Realm 中。所以当 AuthenticatingRealm/AuthorizingRealm 获取 CacheManager 时，是可以直接取到它的。</p><p>这里使用的<code>RedisCacheManager</code>是一个开源项目，不是 Shiro 提供的。它实现了 Shiro 的接口<code>CacheManager</code>的<code>getCache</code>方法（也只有这一个方法）。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;K, V&gt; <span class="function">Cache&lt;K, V&gt; <span class="title">getCache</span><span class="params">(String name)</span> <span class="keyword">throws</span> CacheException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.logger.debug(<span class="string">"get cache, name="</span> + name);</span><br><span class="line">Cache cache = (Cache)<span class="keyword">this</span>.caches.get(name);</span><br><span class="line"><span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">cache = <span class="keyword">new</span> RedisCache(<span class="keyword">this</span>.redisManager, <span class="keyword">this</span>.keySerializer, <span class="keyword">this</span>.valueSerializer, <span class="keyword">this</span>.keyPrefix + name + <span class="string">":"</span>, <span class="keyword">this</span>.expire, <span class="keyword">this</span>.principalIdFieldName);</span><br><span class="line"><span class="keyword">this</span>.caches.put(name, cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (Cache)cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，返回的缓存类是<code>RedisCache</code>，这个类实现了 Shiro 接口<code>Cache&lt;K, V&gt;</code>，是真正直接与 Redis 交互的类。</p><p><strong>使用这个开源项目的注意点：</strong></p><p>AuthenticatingRealm/AuthorizingRealm 默认都是将<code>PrincipalCollection principals</code>直接作为缓存的 key，这个体现在 AuthorizingRealm 的下面这个方法（AuthenticatingRealm 只是方法名不一样）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getAuthorizationCacheKey</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> principals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们就打算这么用，那么上面配置代码中的一句<code>redisCacheManager.setPrincipalIdFieldName(&quot;userId&quot;);</code>非常关键，因为这句话是告诉 RedisCache 要从 principal 对象中取”userId”属性作为 redisKey。所以，我们在用户认证成功后，AuthenticationInfo 中保存的 principal 对象中一定要有”userId”属性。</p><p>如果我们不想用<code>PrincipalCollection</code>类型作为缓存 key，就重写这个方法，例如；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写获取缓存key的方法，原本是用整个PrincipalCollection对象做key，现在改为转为userId字符串做key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getAuthorizationCacheKey</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">String userId = (String) principals.getPrimaryPrincipal();</span><br><span class="line"><span class="keyword">return</span> userId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，就不需要配置<code>redisCacheManager.setPrincipalIdFieldName(&quot;userId&quot;);</code>了，RedisCache 会直接用 userId 作为 redisKey。</p><p>PS: RedisCache 从外部传入的“key”中获取缓存 key 的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getRedisCacheKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 默认keySerializer = StringSerializer</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.keySerializer <span class="keyword">instanceof</span> StringSerializer ? <span class="keyword">this</span>.keyPrefix + <span class="keyword">this</span>.getStringRedisKey(key) : key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getStringRedisKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">String redisKey;</span><br><span class="line"><span class="keyword">if</span> (key <span class="keyword">instanceof</span> PrincipalCollection) &#123;</span><br><span class="line"><span class="comment">// 根据设置的principalIdFieldName，从外部key对象中取对应属性</span></span><br><span class="line">redisKey = <span class="keyword">this</span>.getRedisKeyFromPrincipalIdField((PrincipalCollection)key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 外部key直接作为redisKey</span></span><br><span class="line">redisKey = key.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> redisKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringShiroFilter原理</title>
      <link href="/2021/10/14/shiro-filter-how-work/"/>
      <url>/2021/10/14/shiro-filter-how-work/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring 或 SpringBoot 集成 Shiro 后，无论在 Shiro 配置文件中配置了多少个 Shiro 过滤器（包括 Shiro 已实现的或自定义实现的），这些过滤器在<code>ApplicationFilterChain</code>（tomcat定义的过滤器链）中只以“一个过滤器”的身份存在。这个过滤器的类型是<code>SpringShiroFilter</code>，过滤器的名字取决于我们注入这个 Bean 时设置的 BeanName。</p><p>这篇博客主要介绍 SpringShiroFilter 的创建和工作原理。</p><blockquote><p>以下展示源码的版本是 Shiro 1.3.2。</p></blockquote><h1 id="创建原理"><a href="#创建原理" class="headerlink" title="创建原理"></a>创建原理</h1><p>Shiro 过滤器是由<code>ShiroFilterFactoryBean</code>生成并初始化。在 Shiro 的配置文件中，我们一定会配置这个 ShiroFilterFactoryBean 的 Bean 注入。如下配置示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 配置SecurityManager</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultSecurityManager <span class="title">securityManager</span><span class="params">(CustomRealm customRealm)</span> </span>&#123; <span class="comment">// CustomRealm是自定义Realm类，securityManager所需</span></span><br><span class="line">DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager(customRealm);</span><br><span class="line">SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"><span class="keyword">return</span> securityManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置ShiroFilterFactoryBean</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilter</span><span class="params">(DefaultSecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">ShiroFilterFactoryBean factory = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">factory.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">factory.setLoginUrl(<span class="string">"/login"</span>); <span class="comment">// 登录页URI</span></span><br><span class="line">factory.setUnauthorizedUrl(<span class="string">"/unauth"</span>); <span class="comment">// 403页面URI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加自定义Filter</span></span><br><span class="line">Map&lt;String, Filter&gt; filtersMap = <span class="keyword">new</span> LinkedHashMap&lt;String, Filter&gt;();</span><br><span class="line">filtersMap.put(<span class="string">"permissionCheckFilter"</span>, <span class="keyword">new</span> PermissionCheckFilter());</span><br><span class="line">factory.setFilters(filtersMap);</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">// 匹配上的URI走对应的Filter，从上到下匹配</span></span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/logout"</span>, <span class="string">"logout"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/login"</span>, <span class="string">"anon"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/login/submit"</span>, <span class="string">"anon"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/getRSAKey"</span>, <span class="string">"anon"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/unauth"</span>, <span class="string">"anon"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/*.ico"</span>, <span class="string">"anon"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/**"</span>, <span class="string">"authc"</span>);</span><br><span class="line">System.out.println(filterChainDefinitionMap);</span><br><span class="line">factory.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在配置代码中注入的 Bean 类型是”ShiroFilterFactoryBean”，但其实是”SpringShiroFilter”。这是由于 ShiroFilterFactoryBean 实现了<code>FactoryBean</code>接口，<code>FactoryBean</code>的特点是注册这个 Bean 时，注册的不是自己本类的 Bean，而是<code>getObject</code>方法返回的 Bean，且 Bean 的类型在<code>getObjectType</code>指定。</p><p>ShiroFilterFactoryBean 还实现了<code>BeanPostProcessor</code>接口，<code>BeanPostProcessor</code>的特点是，在“Bean 的生命周期——Bean 初始化”阶段，在调用某个 Bean 的初始化方法（afterPropertiesSet 和 init-method）前后，遍历调用所有 BeanPostProcessor 的实现类的2个方法。</p><p>ShiroFilterFactoryBean 实现这2个接口的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroFilterFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = createInstance(); <span class="comment">// 下面分析</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">getObjectType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SpringShiroFilter<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// 只处理过滤器Bean</span></span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Filter) &#123;</span><br><span class="line">log.debug(<span class="string">"Found filter chain candidate filter '&#123;&#125;'"</span>, beanName);</span><br><span class="line">Filter filter = (Filter) bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据过滤器的类型设置不同的URL</span></span><br><span class="line"><span class="comment">// AccessControlFilter 类型的，设置 loginUrl</span></span><br><span class="line"><span class="comment">// AuthenticationFilter 类型的，设置 successUrl</span></span><br><span class="line"><span class="comment">// AuthorizationFilter 类型的，设置 unauthorizedUrl</span></span><br><span class="line">applyGlobalPropertiesIfNecessary(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到成员Map&lt;String, Filter&gt; filters</span></span><br><span class="line">getFilters().put(beanName, filter);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.trace(<span class="string">"Ignoring non-Filter bean '&#123;&#125;'"</span>, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，ShiroFilterFactoryBean 调用自己的<code>createInstance</code>方法创建 SpringShiroFilter Bean，最终注入到 IoC 容器。在<code>postProcessBeforeInitialization</code>方法中搜集 IoC 容器中所有 Filter Bean（包括不是 Shiro 实现的 Filter），添加到成员<code>filters</code>中，而成员 filters 中也包含我们基于 Shiro 过滤器基类实现的 filter（如配置示例代码中的”PermissionCheckFilter”）。</p><blockquote><p>根据 postProcessBeforeInitialization 方法可以推测，自定义的 Shiro 过滤器既可以在配置代码中手动添加（配置示例就是采用这个方式），也可以直接注入 Bean，两种方式最终都会添加到 ShiroFilterFactoryBean 中。</p></blockquote><p><code>createInstance</code>方法就是负责创建 SpringShiroFilter，一共有3个步骤：</p><ol><li>创建<code>FilterChainManager</code>，实现类是<code>DefaultFilterChainManager</code></li><li>创建<code>PathMatchingFilterChainResolver</code>，并把上一步创建的 FilterChainManager 作为它的成员</li><li>创建 SpringShiroFilter，并把上一步创建的 PathMatchingFilterChainResolver 和 ShiroFilterFactoryBean 的成员 securityManager（等于配置代码中的”DefaultWebSecurityManager”）作为它的成员</li></ol><p>需要重点讲解的是第一步：创建<code>FilterChainManager</code>的过程，原因是 FilterChainManager 是 SpringShiroFilter 的间接成员，是它工作过程中的关键类之一，它保存了 url 与过滤器链的映射关系，即配置代码中的<code>filterChainDefinitionMap</code>中的内容。</p><h2 id="FilterChainManager"><a href="#FilterChainManager" class="headerlink" title="FilterChainManager"></a>FilterChainManager</h2><p>ShiroFilterFactoryBean 中创建 FilterChainManager 的方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> FilterChainManager <span class="title">createFilterChainManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象。刚创建时，这个manager内包含了DefaultFilter类中的所有过滤器</span></span><br><span class="line">DefaultFilterChainManager manager = <span class="keyword">new</span> DefaultFilterChainManager();</span><br><span class="line">Map&lt;String, Filter&gt; defaultFilters = manager.getFilters(); <span class="comment">// key=filterName</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据过滤器的类型设置不同的url，同"postProcessBeforeInitialization"方法</span></span><br><span class="line"><span class="keyword">for</span> (Filter filter : defaultFilters.values()) &#123;</span><br><span class="line">applyGlobalPropertiesIfNecessary(filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取ShiroFilterFactoryBean的成员filters（包括自定义的ShiroFilter和容器中其他非Shiro的Filter）</span></span><br><span class="line">Map&lt;String, Filter&gt; filters = getFilters();</span><br><span class="line"><span class="keyword">if</span> (!CollectionUtils.isEmpty(filters)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Filter&gt; entry : filters.entrySet()) &#123;</span><br><span class="line">String name = entry.getKey();</span><br><span class="line">Filter filter = entry.getValue();</span><br><span class="line">applyGlobalPropertiesIfNecessary(filter);</span><br><span class="line"><span class="keyword">if</span> (filter <span class="keyword">instanceof</span> Nameable) &#123;</span><br><span class="line">((Nameable) filter).setName(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义filter添加到manager中，但没有初始化（即没有调用Filter.init方法）</span></span><br><span class="line"><span class="comment">// 此时manager内包含了defaultFilters和自定义filters</span></span><br><span class="line">manager.addFilter(name, filter, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个chains是在ShiroFilterFactoryBean配置的filterChainDefinitionMap，如&lt;"/role", "authc,roles[admin]"&gt;</span></span><br><span class="line">Map&lt;String, String&gt; chains = getFilterChainDefinitionMap();</span><br><span class="line"><span class="keyword">if</span> (!CollectionUtils.isEmpty(chains)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : chains.entrySet()) &#123;</span><br><span class="line">String url = entry.getKey();</span><br><span class="line">String chainDefinition = entry.getValue();</span><br><span class="line">manager.createChain(url, chainDefinition); <span class="comment">// 下面分析</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法的最后一段，遍历我们配置的<code>filterChainDefinitionMap</code>，调用<code>manager.createChain()</code>处理这个 Map 中每个键值对（key=url，value=url对应的过滤器配置如”roles[admin,user]”）。</p><p><code>DefaultFilterChainManager</code>的部分源码（主要关注 createChain 方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFilterChainManager</span> <span class="keyword">implements</span> <span class="title">FilterChainManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Filter&gt; filters;<span class="comment">// key=filterName, 其中包含DefaultFilter类中所有过滤器和所有自定义filters</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, NamedFilterList&gt; filterChains;<span class="comment">// key=url</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createChain</span><span class="params">(String chainName, String chainDefinition)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 2个方法形参即为filterChainDefinitionMap的key、value</span></span><br><span class="line">        <span class="comment">// 一些校验代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对chainDefinition的一些处理，效果如下面的注释所说</span></span><br><span class="line"><span class="comment">// Input: "authc, roles[admin,user], perms[file:edit]"</span></span><br><span class="line"><span class="comment">// Result: [ "authc", "roles[admin,user]", "perms[file:edit]" ]</span></span><br><span class="line">        String[] filterTokens = splitChainDefinition(chainDefinition);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历filterTokens</span></span><br><span class="line">        <span class="keyword">for</span> (String token : filterTokens) &#123;</span><br><span class="line"><span class="comment">// 对token的一些处理，效果如下面的注释所说</span></span><br><span class="line"><span class="comment">// Input: foo[bar, baz]</span></span><br><span class="line"><span class="comment">// Result: returned[0] == foo returned[1] == bar, baz</span></span><br><span class="line">            String[] nameConfigPair = toNameConfigPair(token);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 见下面</span></span><br><span class="line">            addToChain(chainName, nameConfigPair[<span class="number">0</span>], nameConfigPair[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToChain</span><span class="params">(String chainName, String filterName, String chainSpecificFilterConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(chainName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"chainName cannot be null or empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Filter filter = getFilter(filterName); <span class="comment">// 从成员filters中取</span></span><br><span class="line">        <span class="keyword">if</span> (filter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"....略"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 见下方说明</span></span><br><span class="line">applyChainConfig(chainName, filter, chainSpecificFilterConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从成员filterChains中取（chainName=url），若没有就初始化一个</span></span><br><span class="line"><span class="comment">// 把当前filter添加到URL对于的chain中</span></span><br><span class="line">NamedFilterList chain = ensureChain(chainName);</span><br><span class="line">        chain.add(filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>applyChainConfig(chainName, filter, chainSpecificFilterConfig);</code>这行代码的内容是：当且仅当 filter 是<code>PathMatchingFilter</code>（Shiro 过滤器基类之一）的子类时，将 chainName、chainSpecificFilterConfig 设置到 PathMatchingFilter 的成员<code>Map&lt;String, Object&gt; appliedPaths</code>中。</p><p>整个<code>DefaultFilterChainManager.createChain()</code>方法的作用是，以&lt;”/<strong>“, “authc, roles[admin,user], perms[file:edit]”&gt;这个 filterChainDefinitionMap 中的键值对为例，执行完整个 createChain 方法后，manager 的 filterChains 成员中，key=”/</strong>“ 对应的 chain 中包含”authc”, “roles”, “perms”这3个过滤器（按定义顺序添加），这3个过滤器的配置，即”[admin,user]”, “[file:edit]”，分别被添加到了”roles”, “perms”过滤器的成员 appliedPaths 中。</p><p>DefaultFilterChainManager 的 filterChains 成员中，key 即 url，对应一条过滤器链。因为 filterChainDefinitionMap 类型是 LinkedHashMap，所以过滤器链中的过滤器顺序与配置的顺序一致。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，ShiroFilterFactoryBean 创建了 SpringShiroFilter Bean，并给它设置了成员 DefaultWebSecurityManager 和 PathMatchingFilterChainResolver，PathMatchingFilterChainResolver 中的成员 DefaultFilterChainManager 中保存了 url 与过滤器链的关系，这部分数据来自于配置的 filterChainDefinitionMap。</p><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>前面说过，无论在 Shiro 配置文件中配置了多少个 Shiro 过滤器，这些过滤器在<code>ApplicationFilterChain</code>（tomcat定义的过滤器链）中只以<code>SpringShiroFilter</code>存在。原因就是 SpringShiroFilter 的间接成员 DefaultFilterChainManager 保存了 url 与 Shiro 过滤器链的关系。SpringShiroFilter 会根据不同的 url 取对应的过滤器链来处理请求，主要逻辑在它的 doFilterInternal 方法内（被 doFilter 方法调用）。</p><p>SpringShiroFilter.doFilterInternal() 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, <span class="keyword">final</span> FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">Throwable t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">final</span> ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);</span><br><span class="line"><span class="keyword">final</span> ServletResponse response = prepareServletResponse(request, servletResponse, chain);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Subject对象</span></span><br><span class="line"><span class="keyword">final</span> Subject subject = createSubject(request, response);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用subject.call()方法，里面会调用此处声明的call方法</span></span><br><span class="line">subject.execute(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 在指定条件下，更新session中用户最近一次请求的时间</span></span><br><span class="line">updateSessionLastAccessTime(request, response);</span><br><span class="line"><span class="comment">// 取url对应的过滤器链并执行</span></span><br><span class="line">executeChain(request, response, chain);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException ex) &#123;</span><br><span class="line">t = ex.getCause();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">t = throwable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的步骤如注释所述，下面分别讲解这些步骤内的原理。</p><h2 id="创建Subject对象"><a href="#创建Subject对象" class="headerlink" title="创建Subject对象"></a>创建Subject对象</h2><p>创建 Subject 对象的主要方法是：<code>securityManager.createSubject(subjectContext)</code>。这里的”securityManager”就是我们配置的<code>DefaultWebSecurityManager</code>，”subjectContext”的类型是<code>DefaultWebSubjectContext</code>。从 SpringShiroFilter 过来时，subjextContext 是新创建的对象，里面只保存了 servletRequest、servletResponse 以及 securityManager。</p><blockquote><p>DefaultWebSubjectContext 介绍</p></blockquote><p>DefaultWebSubjectContext 继承自<code>DefaultSubjectContext</code>，保存数据的方式是把它们保存在成员<code>Map&lt;String, Object&gt; backingMap</code>中，每种数据的 KEY 均有定义。</p><p>DefaultSubjectContext 实现<code>SubjectContext</code>接口，继承<code>MapContext</code>类。SubjectContext 接口继承 Map 接口并定义了额外方法，MapContext 类定义了成员<code>Map&lt;String, Object&gt; backingMap</code>并实现了 Map 接口，所以 DefaultSubjectContext 类只需实现 SubjectContext 接口中的方法。</p><hr><p>下面来看<code>securityManager.createSubject(subjectContext)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Subject <span class="title">createSubject</span><span class="params">(SubjectContext subjectContext)</span> </span>&#123;</span><br><span class="line">SubjectContext context = copy(subjectContext); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">context = ensureSecurityManager(context); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">context = resolveSession(context); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">context = resolvePrincipals(context); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">Subject subject = doCreateSubject(context); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">save(subject); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面注释中的序号就是创建 subject 对象的步骤：</p><ol><li>用入参复制出另一个 context 对象，下面都是对这个 context 对象操作</li><li>若 context 中没有设置过 securityManager，就把当前的 securityManager 设置到 context 中</li><li>在 context 中解析 session</li><li>在 context 中解析 principals</li><li>根据 context 创建 subject 对象</li><li>保存新创建的 subject 对象。如果用户已登录，在这步中还会将用户登录后的 sessionId 放入 servletResponse 的请求头中</li></ol><p>下面的小节会详细解释第三至第六步骤的实现原理。</p><h3 id="解析session"><a href="#解析session" class="headerlink" title="解析session"></a>解析session</h3><p>这节讲的是创建 subject 对象的第3步：在 context 中解析 session。</p><blockquote><p>这里解析出的”session”，接口类型就是 Session，但需要注意这个 Session 接口是 Shiro 定义的，不是 Tomcat 定义的。实现类有 SimpleSession、HttpServletSession 等。</p></blockquote><p>这一步的主要逻辑（去掉方法嵌套、异常处理和日志打印）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context 是否已经保存了 session（保存在 backingMap 里），已保存则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (context.resolveSession() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 context 中查询 sessionId（保存在 backingMap 里），构造 sessionKey</span></span><br><span class="line">SessionKey key = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (WebUtils.isWeb(context)) &#123; <span class="comment">// context=DefaultWebSubjectContext返回true</span></span><br><span class="line">Serializable sessionId = context.getSessionId();</span><br><span class="line">ServletRequest request = WebUtils.getRequest(context);</span><br><span class="line">ServletResponse response = WebUtils.getResponse(context);</span><br><span class="line">key = <span class="keyword">new</span> WebSessionKey(sessionId, request, response);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Serializable sessionId = context.getSessionId();</span><br><span class="line"><span class="keyword">if</span> (sessionId != <span class="keyword">null</span>) &#123;</span><br><span class="line">key = <span class="keyword">new</span> DefaultSessionKey(sessionId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 sessionKey 从 sessionManager 中查询 session</span></span><br><span class="line">Session session = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">session = sessionManager.getSession(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 session 保存到 context</span></span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">context.setSession(session);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法最后返回 context</span></span><br><span class="line"><span class="keyword">return</span> context;</span><br></pre></td></tr></table></figure><p>这一步的工作就是，在设置了启用 session 的情况下（默认启用），它会尝试根据请求从服务器内存中取出已保存的当前用户的 session 对象，设置到 context 中，方便后续步骤使用。</p><p>如上，若 context 中还没有保存 session 对象，则先从 context 中取 sessionId 封装成<code>SessionKey</code>，再用 sessionKey 从<strong>sessionManager</strong>中取出 session，设置到 context 中。当请求从 SpringShiroFilter 过来，context 是新创建的，里面只保存了 servletRequest、servletResponse 以及 securityManager，没有保存 session 和 sessionId。所以获取 session 只能通过 <strong>sessionManager</strong>。</p><p><strong>sessionManager</strong>是当前 securityManager 的成员，类型就是<code>SessionManager</code>接口，实现类有<code>ServletContainerSessionManager</code>（默认）、<code>DefaultWebSessionManager</code>（这个类可以设置 session 过期时间）等。这2种实现类获取 session 的实现不同：</p><ol><li><code>ServletContainerSessionManager</code>获取 session 的方法是调用<code>HttpServletRequest.getSession(false)</code>，将<code>javax.servlet.http.HttpSession</code>封装成<code>HttpServletSession</code>返回。</li><li><code>DefaultWebSessionManager</code>获取 session 的方法是通过它的成员<code>SessionDAO sessionDAO</code>，使用的实现类是<code>MemorySessionDAO</code>。MemorySessionDAO 是把 session 保存在 ConcurrentHashMap&lt;Serializable, Session&gt; 中（key=sessionId）。</li></ol><p>补充说明：DefaultWebSessionManager 在通过 sessionDAO 取 session 之前，要先从 sessionKey 中取 sessionId，若取不到，则会调用 HttpServletRequest.getCookies()，取出 name=”JSESSIONID” 的 cookie 值，若还是取不到（如用户禁用了cookie），再从 requestURL 中取。这部分代码见<code>DefaultWebSessionManager.getSessionId()</code>方法。</p><p>综上，只要当前用户请求的 Cookie 或 URI 中带了”JSESSIONID=XXX”，这一步就可以解析出 session 对象并保存到 context 中。</p><blockquote><p>用户的 session 是在何时被创建并被保存的？如何设置启用或禁用 session？见“创建subject对象并保存”一节。</p></blockquote><h3 id="解析principals"><a href="#解析principals" class="headerlink" title="解析principals"></a>解析principals</h3><p>这节讲的是创建 subject 对象的第4步：在 context 中解析 principals。</p><p>解析出的 principals 对象，类型是<code>PrincipalCollection</code>，它是用户身份的象征，这个“身份”可以是一个字符串，也可以是一个对象。又因为是个集合类型，表示可以有多个身份，可用其<code>getPrimaryPrincipal</code>方法取首要身份。</p><p>在从 context 中解析这个对象时，首先从 backingMap 中直接取，没取到则依次从<code>AuthenticationInfo</code>、<code>Subject</code>、<code>Session</code>取（这些对象也保存在 backingMap 中），只要能从其中一个对象中取到，就不再继续了，也有可能一直都没取到。</p><p>首先说明一点，现在介绍的<code>securityManager.createSubject(subjectContext)</code>方法，不只是在用户请求经过 SpringShiroFilter 时被调用，还会在用户的登录请求经过<code>Authenticator.authenticate()</code>方法认证后被调用。也就是说，如果用户请求的接口是登录认证接口，那么请求经过 SpringShiroFilter 时会调用<code>securityManager.createSubject(subjectContext)</code>创建第一个 subject 对象，在用户认证成功后，还会调用这个方法，创建第二个 subject 对象。最后，第二个 subject 对象中的 principals 对象会更新到第一个 subject 对象中。第二个 subject 对象的 principals 的来源就是这个步骤。</p><p><code>AuthenticationInfo</code>就是<code>Authenticator.authenticate()</code>方法的返回对象，之后被保存到了 context 中，它包含了 principals 属性。</p><p>此处出现的 Subject，是指上面说的“第一个 subject 对象”。它在这个步骤的作用不大，因为如果是上面所说的“第一次调用”，那么 context 中也没有这个对象；如果是“第二次调用”，那么 context 中既有 AuthenticationInfo，也有它。此时 context 已经可以从 AuthenticationInfo 中获得 principals，不会经过它。所以在这个步骤，无论什么情况 context 都不会用到它。</p><p>最后关于 Session，它只能依靠上个步骤得来（来源于用户当前请求）。如果上一步可以解析出 session 对象，那么这一步 context 就有保存 session 对象，可以尝试从 session 中取 principals。</p><blockquote><p>在这一步中，如果从 context 中没有解析出 principals ，那么会尝试使用”RememberMe”功能取 principals 再设置到 context 中。因”RememberMe”功能不在这篇博客讨论范围内，所以忽略。</p></blockquote><p>经过这一步之后，若 context 中直接或间接保存了 principals，这个 principals 对象会保存到下一步创建的 subject 对象中，并且会更新到 session 中。详情见下一节。</p><h3 id="创建subject对象并保存"><a href="#创建subject对象并保存" class="headerlink" title="创建subject对象并保存"></a>创建subject对象并保存</h3><p>终于来到最后的两个步骤：根据 context 创建 subject 对象，保存新创建的 subject 对象。</p><p>根据 context 创建 subject 对象依靠 securityManager 成员<code>SubjectFactory</code>，使用的实现类是<code>DefaultWebSubjectFactory</code>，创建的 subject 对象类型是<code>WebDelegatingSubject</code>。创建出的 subject 对象内容如下，都是从 context 中取的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager securityManager = wsc.resolveSecurityManager(); <span class="comment">// wsc就是context</span></span><br><span class="line">Session session = wsc.resolveSession();</span><br><span class="line"><span class="keyword">boolean</span> sessionEnabled = wsc.isSessionCreationEnabled();</span><br><span class="line">PrincipalCollection principals = wsc.resolvePrincipals();</span><br><span class="line"><span class="keyword">boolean</span> authenticated = wsc.resolveAuthenticated(); <span class="comment">// 已认证标志，当context中有AuthenticationInfo为TRUE，或取context中的session中的这个属性值</span></span><br><span class="line">String host = wsc.resolveHost();</span><br><span class="line">ServletRequest request = wsc.resolveServletRequest();</span><br><span class="line">ServletResponse response = wsc.resolveServletResponse();</span><br></pre></td></tr></table></figure><p>保存新创建的 subject 对象依靠 securityManager 成员<code>SubjectDAO</code>，默认使用实现类<code>DefaultSubjectDAO</code>，这也是 Shiro 唯一的实现类。</p><p><code>SubjectDAO</code>接口只定义了2个方法：save 和 delete，方法参数都是 subject 对象。</p><p>DefaultSubjectDAO.save() 方法中，先判断是否需要保存 session，这个判断由它的成员<code>SessionStorageEvaluator</code>负责，默认使用<code>DefaultSessionStorageEvaluator</code>实现类。DefaultSessionStorageEvaluator 的判断方法是：要保存的 subject 中有 session 对象，或属性<code>sessionStorageEnabled</code>=true（默认值）。</p><blockquote><p>如果把 DefaultSessionStorageEvaluator 的属性 sessionStorageEnabled 置为 false，那么在用户登录成功后也不会保存 session（用户登录成功前本来也没有 session），则用户请求中一直不会有 session，相当于禁用 session。</p></blockquote><p>判断“是否需要保存 session”为是时，依次执行<code>mergePrincipals</code>和<code>mergeAuthenticationState</code>方法。 mergePrincipals 方法逻辑如下图，mergeAuthenticationState 方法逻辑相同，只是把”principals”换成”authenticated(已认证标志)”。</p><img src="/2021/10/14/shiro-filter-how-work/mergePrincipals.PNG" class="" title="mergePrincipals"><hr><p>下面讲解 subject 是如何新建 session 对象的（以 WebDelegatingSubject 为例）。</p><p>WebDelegatingSubject 创建 session 是调用<code>securityManager.start(sessionContext)</code>方法，创建出的 session 类型是<code>StoppingAwareProxiedSession</code>。其中”sessionContext”是一个新建的空对象，类型是<code>DefaultWebSessionContext</code>。它和<code>SubjectContext</code>相似，也继承自 MapContext。</p><p>securityManager = DefaultWebSecurityManager，在它的 start 方法中，又调用<code>sessionManager.start(context)</code>来创建 session。如在“解析session”一节中所述，这个 sessionManager 是 securityManager 的成员，实现类是<code>ServletContainerSessionManager</code>或<code>DefaultWebSessionManager</code>。这2种实现类创建 session 的实现不同：</p><ol><li>ServletContainerSessionManager 创建 session 的方法是调用<code>HttpServletRequest.getSession()</code>，将<code>HttpSession</code>(javax.servlet.http)封装成<code>HttpServletSession</code>返回。</li><li>DefaultWebSessionManager 创建 session 的方法是通过它的成员<code>SessionFactory sessionFactory</code>，使用的实现类是<code>SimpleSessionFactory</code>，创建的 session 类型是<code>SimpleSession</code>（内容只有”host”）。创建好 session 后，DefaultWebSessionManager 会把它保存到成员<code>SessionDAO sessionDAO</code>，实现类是<code>MemorySessionDAO</code>。MemorySessionDAO 将创建的 session 保存到 ConcurrentHashMap&lt;Serializable, Session&gt; 中（sessionId自动生成）。保存好 session 后，若属性<code>sessionIdCookieEnabled</code>=true（默认），DefaultWebSessionManager 会将 sessionId 写入 HttpServletResponse 的响应头”Set-Cookie:JSESSIONID=XXX”中。</li></ol><p>subject 创建好 session 后，会把自己的 principals 和 authenticated 设置到 session 中。HttpServletSession 保存数据的方式是保存到<code>HttpSession</code>(javax.servlet.http)的<code>attributes</code>，SimpleSession 是保存到自己的<code>Map&lt;Object, Object&gt; attributes</code>。</p><hr><p>小总结：</p><ol><li>创建 Subject 对象的是<code>SubjectFactory</code>，保存 Subject 的是<code>DefaultSubjectDAO</code>，在保存 Subject 时可能会调用到<code>SessionManager</code>创建 Session。</li><li>DefaultSubjectDAO 保存和删除 subject 对象，并不是把它保存到什么位置，或从什么位置删除。保存时，是把 subject 对象中的 principals、authenticated(已认证标志) 更新到此 subject 的 session 对象中。删除时，就是从 subject 中的 session（如果有的话）中删除这两个元素。</li><li>当且仅当 subject 中存在 principals 或 authenticated=true 时，subject 才会在没有 session 的情况下新建一个 session 对象。</li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>上面的三个小节所描述的步骤，代码上看起来完全没有关联，做到了解耦，但在逻辑上是紧密相连的，形成了一个闭环：<br>第一步“解析session”完全依赖用户请求；第二步“解析principals”既依赖第一步解析的 session，也依赖用户是否认证成功；最后一步“创建subject对象并保存”，创建的 subject 对象中是否包含 principals、是否新建 session 完全依赖第二步，并且这一步新建的 session 又是用户请求中的 session 的来源。</p><p>根据以上结论，可以推理出下面的情况。</p><hr><p>当未登录用户请求非认证接口：</p><ol><li>解析session：因为请求中没有 sessionId，所以没有解析出 session</li><li>解析principals：因为 context 中没有 AuthenticationInfo、subject、session，所以没有解析出 principals</li><li>创建新的subject对象：创建出的 subject 对象只有 context 中原有的 securityManager、httpServletRequest、httpServletResponse，无 session 也无 principals</li><li>保存新的subject对象：因为 subject 对象中无 session 也无 principals，所以这一步什么也没做</li></ol><hr><p>当未登录用户请求认证接口，在用户认证成功后，会再次经过这些步骤创建 subject 对象：</p><ol><li>解析session：因为请求中没有 sessionId，所以没有解析出 session</li><li>解析principals：因为 context 中有 AuthenticationInfo，所以解析出 principals</li><li>创建新的subject对象：创建出的 subject 对象除了 securityManager、httpServletRequest、httpServletResponse 以外，还会有 principals 和 authenticated(已认证标志)，但没有 session</li><li>保存新的subject对象：因为 subject 对象中无 session，但有 principals 和 authenticated(已认证标志)，所以 subject 创建了 session，并把 principals 和 authenticated 保存在 session 中。如果用的是<code>DefaultWebSessionManager</code>，session 对象保存在<code>MemorySessionDAO</code>中，且 sessionId 写入响应头”Set-Cookie:JSESSIONID=XXX”</li></ol><hr><p>当已登录用户请求非认证接口：</p><ol><li>解析session：因为请求头中带有 sessionId，如果用的是<code>DefaultWebSessionManager</code>，会从请求中取 sessionId，从 MemorySessionDAO 中取已保存的 session 对象，这个 session 对象中又包含了 principals 和 authenticated。这个 session 保存在 context 中</li><li>解析principals：因为 context 中有 session，所以从 session 中解析出 principals</li><li>创建新的subject对象：创建出的 subject 对象除了 securityManager、httpServletRequest、httpServletResponse 以外，还会有 principals、authenticated（从 session 中取出的）、session</li><li>保存新的subject对象：因为 subject 对象中既有 session 也有 principals，所以 session 中的 principals 更新为 subject 中的 principals（因为 subject 中的其实也来自于 session，所以这两个 principals 内容一致）。authenticated 也是如此更新</li></ol><hr><p>当已登录用户请求认证接口，在第一次经过这些步骤时，情况如上一个所述。在用户认证成功后，第二次经过这些步骤时：</p><ol><li>解析session：因为 context 中保存了用户“认证成功前”的 subject 对象，而这个(旧)subject 对象有 session，所以相当于 context 中也保存了 session</li><li>解析principals：因为 context 中有 AuthenticationInfo，所以解析出 principals</li><li>创建新的subject对象：创建出的 subject 对象除了 securityManager、httpServletRequest、httpServletResponse 以外，还会有 principals 和 authenticated，还有 session【是从 context 中的(旧)subject 对象取的</li><li>保存新的subject对象：因为 subject 对象中既有 session 也有 principals，所以 session 中的 (旧)principals 更新为 subject 中的 (新)principals。authenticated 也是如此更新【注意：如果用的是<code>DefaultWebSessionManager</code>，被更新的 session 对象依然是在<code>MemorySessionDAO</code>中保存的那个对象。sessionId 会再次写入响应头”Set-Cookie:JSESSIONID=XXX”</li></ol><h2 id="取url对应的过滤器链"><a href="#取url对应的过滤器链" class="headerlink" title="取url对应的过滤器链"></a>取url对应的过滤器链</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>经过上面的步骤，若是已登录用户的请求，创建的 subject 对象会包含 principals、session 等信息。创建后，调用<code>subject.execute()</code>方法。</p><p><code>subject.execute()</code>的方法参数是<code>Callable</code>，在这里可以理解为一个回调方法，这个回调方法的内容就是这两行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在指定条件下，更新session中用户最近一次请求的时间</span></span><br><span class="line">updateSessionLastAccessTime(request, response);</span><br><span class="line"><span class="comment">// 取url对应的过滤器链并执行</span></span><br><span class="line">executeChain(request, response, chain);</span><br></pre></td></tr></table></figure><blockquote><p>实际上，Callable 一般和 FutureTask 配合，用于多线程编程。它和 Runnable 的区别在于，它的 call 方法可以获取线程执行后的返回值，而 Runnable 的 run 方法无返回值。在当前场景下，Callable 作为回调方法使用，是同步执行的。</p></blockquote><p>在<code>subject.execute()</code>方法中，先把<code>Callable</code>封装成<code>SubjectCallable</code>，再调用 SubjectCallable.call() 方法。SubjectCallable 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectCallable</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ThreadState threadState;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubjectCallable</span><span class="params">(Subject subject, Callable&lt;V&gt; delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> SubjectThreadState(subject), delegate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SubjectCallable</span><span class="params">(ThreadState threadState, Callable&lt;V&gt; delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadState == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ThreadState argument cannot be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.threadState = threadState;</span><br><span class="line">        <span class="keyword">if</span> (delegate == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Callable delegate instance cannot be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.callable = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadState.bind();</span><br><span class="line">            <span class="keyword">return</span> doCall(<span class="keyword">this</span>.callable);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadState.restore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> V <span class="title">doCall</span><span class="params">(Callable&lt;V&gt; target)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SubjectCallable 的成员”Callable callable”就是上面声明的回调方法，”ThreadState threadState”在构造方法中被赋值<code>SubjectThreadState</code>。在 call 方法中，先后调用了这两个成员的方法。</p><p>第一个方法<code>threadState.bind()</code>内部调用了<code>ThreadContext.bind(subject)</code>，subject 即为上个步骤创建的 subject 对象，ThreadContext 将这个对象保存在<code>ThreadLocal&lt;Map&lt;Object, Object&gt;&gt;</code>中。在这之后用<code>SecurityUtils.getSubject()</code>来获取 subject 时，就可以从 ThreadContext 中取到 subject。</p><p>第二个方法<code>target.call()</code>，就是执行了上面给出的回调方法的两行内容，一是更新 session 时间（当使用的 sessionManager=ServletContainerSessionManager 时才会更新），二是取 url 对应的过滤器链并执行。</p><p>在这两个方法执行完后，即过滤器链也执行完了，进入 finally 块，清空 ThreadContext 中的 ThreadLocal 内容。</p><h3 id="取过滤器链并执行"><a href="#取过滤器链并执行" class="headerlink" title="取过滤器链并执行"></a>取过滤器链并执行</h3><p>这一节讲 SpringShiroFilter 中的 executeChain 方法，也是上面回调方法中的第二个方法。在这个方法中，首先要取 url 对应的过滤器链，就是下面源码所展示的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> FilterChain <span class="title">getExecutionChain</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain origChain)</span> </span>&#123;</span><br><span class="line">FilterChain chain = origChain;</span><br><span class="line"></span><br><span class="line">FilterChainResolver resolver = getFilterChainResolver();</span><br><span class="line"><span class="keyword">if</span> (resolver == <span class="keyword">null</span>) &#123;</span><br><span class="line">log.debug(<span class="string">"No FilterChainResolver configured.  Returning original FilterChain."</span>);</span><br><span class="line"><span class="keyword">return</span> origChain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FilterChain resolved = resolver.getChain(request, response, origChain);</span><br><span class="line"><span class="keyword">if</span> (resolved != <span class="keyword">null</span>) &#123;</span><br><span class="line">log.trace(<span class="string">"Resolved a configured FilterChain for the current request."</span>);</span><br><span class="line">chain = resolved;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.trace(<span class="string">"No FilterChain configured for the current request.  Using the default."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，负责“取 url 对应的过滤器链”这项工作的是 SpringShiroFilter 的成员<code>PathMatchingFilterChainResolver</code>。如果这个成员为 Null 或没有与 url 匹配的过滤器链，那么这个方法会返回原过滤器链，即<code>ApplicationFilterChain</code>。</p><p>在<code>PathMatchingFilterChainResolver.getChain()</code>方法中（源码如下），遍历其成员<code>DefaultFilterChainManager</code>中的<code>Map&lt;String, NamedFilterList&gt; filterChains</code>的 key，与当前请求 url 进行匹配，若匹配上，则调用<code>DefaultFilterChainManager.proxy()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FilterChain <span class="title">getChain</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain originalChain)</span> </span>&#123;</span><br><span class="line">    FilterChainManager filterChainManager = getFilterChainManager();</span><br><span class="line">    <span class="keyword">if</span> (!filterChainManager.hasChains()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String requestURI = getPathWithinApplication(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String pathPattern : filterChainManager.getChainNames()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pathMatches(pathPattern, requestURI)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(<span class="string">"Matched path pattern ["</span> + pathPattern + <span class="string">"] for requestURI ["</span> + requestURI + <span class="string">"].  "</span> +</span><br><span class="line">                        <span class="string">"Utilizing corresponding filter chain..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> filterChainManager.proxy(originalChain, pathPattern);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultFilterChainManager.proxy()</code>方法的作用是，从<code>Map&lt;String, NamedFilterList&gt; filterChains</code>中取出的过滤器链类型是<code>SimpleNamedFilterList</code>（见 ensureChain 方法），将这个过滤器链再度封装成<code>ProxiedFilterChain</code>类型。</p><p>所以，SpringShiroFilter 通过 PathMatchingFilterChainResolver 取出的过滤器链是<code>ProxiedFilterChain</code>类型，执行过滤器链时，就是调用<code>ProxiedFilterChain.doFilter()</code>方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.filters == <span class="keyword">null</span> || <span class="keyword">this</span>.filters.size() == <span class="keyword">this</span>.index) &#123;</span><br><span class="line">        <span class="comment">//we've reached the end of the wrapped chain, so invoke the original one:</span></span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">"Invoking original filter chain."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.orig.doFilter(request, response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">"Invoking wrapped filter at index ["</span> + <span class="keyword">this</span>.index + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.filters.get(<span class="keyword">this</span>.index++).doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是典型的过滤器链的实现，通过下标 index 自增来遍历 List<Filter> filters 中每个元素，遍历完了就执行原过滤器链，即<code>ApplicationFilterChain</code>。</p><p>至此，SpringShiroFilter的工作原理介绍完了。通过过滤器链，就可以进入 Shiro 的认证与授权流程了。</p>]]></content>
      
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat过滤器链原理</title>
      <link href="/2021/10/05/tomcat-filter-chain/"/>
      <url>/2021/10/05/tomcat-filter-chain/</url>
      
        <content type="html"><![CDATA[<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>Tomcat 采用“责任链模式”设计了过滤器链。该模式的含义是，一个请求进入后会经过一系列处理逻辑，这些处理逻辑可以分别写在不同的地方，每个逻辑处理完后将请求传给下一个处理逻辑。</p><p>这样做的好处是：处理逻辑之间解耦，每个逻辑只管做好自己的事，不需要知道自己的前后的处理逻辑；可以快速在这个逻辑链条中加入新的逻辑，不影响原有的逻辑和执行顺序。</p><h1 id="过滤器链的简单实现"><a href="#过滤器链的简单实现" class="headerlink" title="过滤器链的简单实现"></a>过滤器链的简单实现</h1><p>先定义一个过滤器接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤器接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain filterChain)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 Request、Response 是对HTTP请求、响应的模拟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String requestStr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestStr</span><span class="params">(String requestStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestStr = requestStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String responseStr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResponseStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResponseStr</span><span class="params">(String responseStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseStr = responseStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最重要的 FilterChain 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain filterChain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == list.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//这里是逆序处理响应的关键, 当index为容器大小时, 证明对request的处理已经完成, 下面进入对response的处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        Filter f = list.get(index);<span class="comment">//过滤器链按index的顺序拿到filter</span></span><br><span class="line">        index++;</span><br><span class="line">        f.doFilter(request, response, filterChain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFilter</span><span class="params">(Filter filter)</span> </span>&#123;</span><br><span class="line">        list.add(filter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>index</code>初始化为0，此过滤器链的 doFilter 方法第一次被调用时，取出了过滤器链 list 中第一个过滤器，index 自增1，然后执行第一个过滤器的 doFilter 方法，过滤器链对象自身作为方法参数。此过滤器链的 doFilter 方法第二次被调用时，因为 index 已经自增，所以从 list 中取到的是第二个过滤器，也就顺理成章地执行第二个过滤器的 doFilter 方法。当所有过滤器执行完后，</p><p>其中一个过滤器实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterA</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain filterChain)</span> </span>&#123;</span><br><span class="line">        String requestStr = request.getRequestStr();</span><br><span class="line">        System.out.println(<span class="string">"==============================请求经过FilterA"</span>);</span><br><span class="line">        filterChain.doFilter(request, response, filterChain);<span class="comment">//调用过滤器链的doFilter方法, 让它去执行下一个Filter的doFilter方法, 处理response的代码将被挂起</span></span><br><span class="line">        System.out.println(<span class="string">"==============================响应经过FilterA"</span>);</span><br><span class="line">        <span class="keyword">if</span> (response.getResponseStr() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.setResponseStr(requestStr);</span><br><span class="line">        &#125;</span><br><span class="line">        response.setResponseStr(response.getResponseStr() + <span class="string">"-FA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面结合过滤器 FilterA 的实现和过滤器链 FilterChain 的实现来理解过滤器链工作的原理。</p><p>因为要遍历所有过滤器，所以请求和响应对象首先进入<code>filterChain.doFilter(request, response, filterChain)</code>方法，参数包括 filterChain 对象自身。</p><p>因为<code>index</code>初始化为0，此 filterChain 对象的 doFilter 方法第一次被调用时，取出了过滤器链 list 中第一个过滤器，index 自增1，然后执行第一个过滤器的 doFilter 方法，filterChain 对象自身作为方法参数。</p><p>在过滤器 filterA.doFilter() 方法中，处理完请求后就调用 filterChain.doFilter() 方法，所以 filterChain.doFilter() 方法可以看作是一个递归方法。</p><p>在 filterChain.doFilter() 方法中，每次调用就取 index 下标对应的过滤器，调用过滤器的 doFilter 方法之前先将 index 自增1。下次进入这个方法时，取出的过滤器就是下一个过滤器。当过滤器全部执行完，即 index == list.size() 时就 return。</p><p>因为除了第一次调用，后续调用 filterChain.doFilter() 方法都是在每个过滤器的 doFilter 方法内，所以从 filterChain.doFilter() 方法 return 后就回到过滤器的 doFilter 方法，所以过滤器中的后续处理响应的逻辑会被执行，过滤器的 doFilter 执行完 return 又到了 filterChain.doFilter() 方法。以此类推，每个过滤器处理响应的逻辑都会被执行。</p><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Request request = <span class="keyword">new</span> Request();</span><br><span class="line">        request.setRequestStr(<span class="string">"请求内容"</span>);</span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line"></span><br><span class="line">        FilterChain filterChain = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> FilterA());</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> FilterB());</span><br><span class="line">        filterChain.doFilter(request, response, filterChain);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"最终响应："</span> + response.getResponseStr());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求经过FilterA</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求经过FilterB</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;响应经过FilterB</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;响应经过FilterA</span><br><span class="line">最终响应：请求内容-FB-FA</span><br></pre></td></tr></table></figure><p>以上是对过滤器链的简单实现，与 Tomcat 的过滤器原理大概类似。Toomcat 是分别定义了一个 FilterChain 接口和 Filter 接口，FilterChain 接口 Tomcat自己实现了，我们自定义过滤器是实现 Filter 接口。</p><h1 id="ApplicationFilterChain"><a href="#ApplicationFilterChain" class="headerlink" title="ApplicationFilterChain"></a>ApplicationFilterChain</h1><p><code>ApplicationFilterChain</code>是 Tomcat 实现的 FilterChain，而且 Tomcat 只有这一个实现类。</p><p>ApplicationFilterChain 中保存过滤器使用的是 ApplicationFilterConfig 数组。<code>ApplicationFilterConfig</code>类中的成员就是<code>Filter</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ApplicationFilterConfig[] filters = <span class="keyword">new</span> ApplicationFilterConfig[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationFilterConfig</span> <span class="keyword">implements</span> <span class="title">FilterConfig</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Filter filter = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationFilterChain 的 doFilter 方法调用到自己的 internalDoFilter 方法，在这个方法内，可以看到我们上一节实现的逻辑：把过滤器下标+1，取过滤器，调用过滤器doFilter方法，入参为请求+响应+过滤器链自身。并且，在这一系列操作前先判断过滤器下标，即是否执行完所有过滤器了，如果执行完了，调用 servlet.service() 方法。servlet 方法返回后，整个过程就结束了。</p><p>ApplicationFilterChain 的 internalDoFilter 方法部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalDoFilter</span><span class="params">(ServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">  ServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">ApplicationFilterConfig filterConfig = filters[pos++]; <span class="comment">// 取过滤器，下标+1</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Filter filter = filterConfig.getFilter();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">ExceptionUtils.handleThrowable(e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ServletException(sm.getString(<span class="string">"filterChain.filter"</span>), e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 每个过滤器方法执行完后 return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当执行完所有过滤器 pos == n 时</span></span><br><span class="line">servlet.service(request, response);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 Tomcat 过滤器用的是 web.xml 配置文件，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编码过滤器 --&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 登录过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>LoginFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.imooc.filter.LoginFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>noLoginPaths<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>login.jsp;fail.jsp;Login<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>不会被过滤掉的页面</span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>charset<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>LoginFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些过滤器的执行顺序遵守以下规则：</p><ol><li>以url-pattern方式配置的filter运行时肯定先于以servlet-name方式配置的filter </li><li>以url-partern方式配置的filter中，如果有多个与当前请求匹配，则按web.xml中filter-mapping出现的顺序来运行 </li></ol><h1 id="SpringBoot对Tomcat过滤器的自动配置"><a href="#SpringBoot对Tomcat过滤器的自动配置" class="headerlink" title="SpringBoot对Tomcat过滤器的自动配置"></a>SpringBoot对Tomcat过滤器的自动配置</h1><p>如果项目是 Servlet+JSP 或 SpringMVC，就需要手动在 web.xml 中配置过滤器，但在 SpringBoot 实现起来就简单了，我们只需要实现将过滤器类像下面这样注册为 Bean，SpringBoot 就会帮我们自动配置。</p><blockquote><p>这里的 Tomcat 版本是9.0.35</p></blockquote><p>自定义过滤器示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@WebFilter</span>(urlPatterns = &#123;<span class="string">"/*"</span>&#125;) <span class="comment">// 拦截URI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"==========CustomFilter===============init"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpServletRequest httpReq = (HttpServletRequest) request;</span><br><span class="line">System.out.println(<span class="string">"==========CustomFilter===============doFilter"</span>);</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目启动后，调试一下 FilterChain 对象的中的过滤器，会看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 &#x3D; &#123;ApplicationFilterConfig@5065&#125; &quot;ApplicationFilterConfig[name&#x3D;characterEncodingFilter, filterClass&#x3D;org.springframework.boot.web.servlet.filter.OrderedCharacterEncodingFilter]&quot;</span><br><span class="line">1 &#x3D; &#123;ApplicationFilterConfig@5066&#125; &quot;ApplicationFilterConfig[name&#x3D;formContentFilter, filterClass&#x3D;org.springframework.boot.web.servlet.filter.OrderedFormContentFilter]&quot;</span><br><span class="line">2 &#x3D; &#123;ApplicationFilterConfig@5067&#125; &quot;ApplicationFilterConfig[name&#x3D;requestContextFilter, filterClass&#x3D;org.springframework.boot.web.servlet.filter.OrderedRequestContextFilter]&quot;</span><br><span class="line">3 &#x3D; &#123;ApplicationFilterConfig@5068&#125; &quot;ApplicationFilterConfig[name&#x3D;customFilter, filterClass&#x3D;com.example.demo.config.CustomFilter]&quot;</span><br><span class="line">4 &#x3D; &#123;ApplicationFilterConfig@5069&#125; &quot;ApplicationFilterConfig[name&#x3D;Tomcat WebSocket (JSR356) Filter, filterClass&#x3D;org.apache.tomcat.websocket.server.WsFilter]&quot;</span><br></pre></td></tr></table></figure><p>这里的原理简单说是，容器启动时，会从 beanFactory=DefaultListableBeanFactory 中取出所有实现了<code>javax.servlet.Filter</code>接口的 Bean（除了我们自定义的过滤器，其他是 SpringBoot 提供的），进行一个<strong>升序</strong>排序，序号来自于它们使用的<code>@Order</code>注解或<code>PriorityOrdered</code>接口。如果没有使用，序号就是 Integer.MAX。上面的前3个过滤器的序号都是负数，所以位置靠前。</p><p>这部分逻辑在下面这个方法（在<code>ServletContextInitializerBeans</code>类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; List&lt;Entry&lt;String, T&gt;&gt; getOrderedBeansOfType(ListableBeanFactory beanFactory, Class&lt;T&gt; type,</span><br><span class="line">Set&lt;?&gt; excludes) &#123;</span><br><span class="line">String[] names = beanFactory.getBeanNamesForType(type, <span class="keyword">true</span>, <span class="keyword">false</span>); <span class="comment">// 取Bean,type=javax.servlet.Filter</span></span><br><span class="line">Map&lt;String, T&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line"><span class="keyword">if</span> (!excludes.contains(name) &amp;&amp; !ScopedProxyUtils.isScopedTarget(name)) &#123;</span><br><span class="line">T bean = beanFactory.getBean(name, type); <span class="comment">// 生成Bean</span></span><br><span class="line"><span class="keyword">if</span> (!excludes.contains(bean)) &#123;</span><br><span class="line">map.put(name, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Entry&lt;String, T&gt;&gt; beans = <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</span><br><span class="line">beans.sort((o1, o2) -&gt; AnnotationAwareOrderComparator.INSTANCE.compare(o1.getValue(), o2.getValue())); <span class="comment">// 排序</span></span><br><span class="line"><span class="keyword">return</span> beans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器链 ApplicationFilterChain 是在每次请求来时被创建的，负责创建工作的是 ApplicationFilterFactory.createFilterChain() 方法。在这个方法中，遍历<code>StandardContext</code>的成员<code>Map&lt;String, ApplicationFilterConfig&gt; filterConfigs</code>（其实是遍历 StandardContext 的成员 filterMap，这个 Map 中保存了所有 filterName，再根据每个 filterName 从 filterConfigs 取 ApplicationFilterConfig 对象），把这个成员内的所有 ApplicationFilterConfig 对象添加到 ApplicationFilterChain 中。而 StandardContext 的成员 filterConfigs 的元素也是来自于上面 SpringBoot 容器中的过滤器 Bean。</p><p>创建好 ApplicationFilterChain 之后，就是调用它的 doFilter 方法，这之后就是我们上面说的过滤器链的执行逻辑。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shiro过滤器基类介绍</title>
      <link href="/2021/10/01/shiro-filter-baseclass/"/>
      <url>/2021/10/01/shiro-filter-baseclass/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Shiro 已经实现的过滤器有以下几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DefaultFilter &#123;</span><br><span class="line">    anon(AnonymousFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">    <span class="title">authc</span>(<span class="title">FormAuthenticationFilter</span>.<span class="title">class</span>), // 认证</span></span><br><span class="line"><span class="class">    <span class="title">authcBasic</span>(<span class="title">BasicHttpAuthenticationFilter</span>.<span class="title">class</span>), // 认证</span></span><br><span class="line"><span class="class">    <span class="title">logout</span>(<span class="title">LogoutFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class">    <span class="title">noSessionCreation</span>(<span class="title">NoSessionCreationFilter</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class">    <span class="title">perms</span>(<span class="title">PermissionsAuthorizationFilter</span>.<span class="title">class</span>), // 授权</span></span><br><span class="line"><span class="class">    <span class="title">port</span>(<span class="title">PortFilter</span>.<span class="title">class</span>), // 授权</span></span><br><span class="line"><span class="class">    <span class="title">rest</span>(<span class="title">HttpMethodPermissionFilter</span>.<span class="title">class</span>), // 授权</span></span><br><span class="line"><span class="class">    <span class="title">roles</span>(<span class="title">RolesAuthorizationFilter</span>.<span class="title">class</span>), // 授权</span></span><br><span class="line"><span class="class">    <span class="title">ssl</span>(<span class="title">SslFilter</span>.<span class="title">class</span>), // 授权</span></span><br><span class="line"><span class="class">    <span class="title">user</span>(<span class="title">UserFilter</span>.<span class="title">class</span>)</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的枚举名如”anon”是这个过滤器的名字，配置过滤器链时会用到它。上面标注了“认证”的过滤器继承自<code>AuthenticationFilter</code>，“授权”过滤器继承自<code>AuthorizationFilter</code>。这两个过滤器都继承<code>AccessControlFilter</code>，AccessControlFilter 之上又有一系列继承（从父类到子类）：<br>Filter(javax.servlet接口) -&gt; AbstractFilter -&gt; NameableFilter -&gt; OncePerRequestFilter -&gt; AdviceFilter -&gt; PathMatchingFilter -&gt; AccessControlFilter。</p><blockquote><p>以下展示源码的版本是 Shiro 1.3.2。</p></blockquote><h1 id="AbstractFilter"><a href="#AbstractFilter" class="headerlink" title="AbstractFilter"></a>AbstractFilter</h1><p>抽象类，实现了 Filter 接口的 init 方法。扩展点包括添加<code>FilterConfig</code>为成员（这个类里包含 filterName 等属性）。部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFilter</span> <span class="keyword">extends</span> <span class="title">ServletContextSupport</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> FilterConfig filterConfig;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterConfig <span class="title">getFilterConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filterConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilterConfig</span><span class="params">(FilterConfig filterConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filterConfig = filterConfig;</span><br><span class="line">        setServletContext(filterConfig.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter接口的init方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        setFilterConfig(filterConfig); <span class="comment">// 设置成员</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onFilterConfigSet(); <span class="comment">// 后续设置方法，钩子，可由子类扩展</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ServletException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (ServletException) e;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isErrorEnabled()) &#123;</span><br><span class="line">                    log.error(<span class="string">"Unable to start Filter: ["</span> + e.getMessage() + <span class="string">"]."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFilterConfigSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter接口的destroy方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NameableFilter"><a href="#NameableFilter" class="headerlink" title="NameableFilter"></a>NameableFilter</h1><p>抽象类，未实现 Filter 接口的任何方法，扩展了一个属性<code>name</code>，用于表示过滤器的名字，这个名字可以外部调用 set 方法设置，如果没有设置，则来源是<code>FilterConfig</code>。部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NameableFilter</span> <span class="keyword">extends</span> <span class="title">AbstractFilter</span> <span class="keyword">implements</span> <span class="title">Nameable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            FilterConfig config = getFilterConfig();</span><br><span class="line">            <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.name = config.getFilterName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="OncePerRequestFilter"><a href="#OncePerRequestFilter" class="headerlink" title="OncePerRequestFilter"></a>OncePerRequestFilter</h1><p>抽象类，实现了 Filter 接口的 doFilter 方法，方法内有控制同一个过滤器只执行一次，且提供了过滤器的开关（默认开启）。在这个方法内调用<code>doFilterInternal</code>方法（抽象方法，由子类实现）真正执行过滤器的逻辑。</p><h1 id="AdviceFilter"><a href="#AdviceFilter" class="headerlink" title="AdviceFilter"></a>AdviceFilter</h1><p>抽象类，实现了<code>doFilterInternal</code>方法。实现方式是，在调用<code>filterChain.doFilter()</code>之前调用<code>preHandle</code>方法，之后调用<code>postHandler</code>，执行完整条过滤器后调用<code>afterComplete</code>方法。preHandle、postHandler、afterComplete 是它提供给子类的钩子，可由子类实现。部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"UnusedDeclaration"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"UnusedDeclaration"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(ServletRequest request, ServletResponse response, Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Exception exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> continueChain = preHandle(request, response);</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(<span class="string">"Invoked preHandle method.  Continuing chain?: ["</span> + continueChain + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (continueChain) &#123; <span class="comment">// preHandle返回true才执行后面过滤器, false直接中断</span></span><br><span class="line">                executeChain(request, response, chain); <span class="comment">// 调用chain.doFilter()</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            postHandle(request, response);</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(<span class="string">"Successfully invoked postHandle method"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            exception = e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 执行完所有过滤器（或中断）后调用, 里面有afterComplete方法</span></span><br><span class="line">            cleanup(request, response, exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="PathMatchingFilter"><a href="#PathMatchingFilter" class="headerlink" title="PathMatchingFilter"></a>PathMatchingFilter</h1><p>抽象类，实现了直接父类 AdviceFilter 定义的三个钩子方法中的<code>preHandle</code>方法。在这个方法里先匹配 requestURI，匹配方法是把 requestURI 和成员<code>Map&lt;String, Object&gt; appliedPaths</code>中保存的URI进行 match。如果 match 失败，preHandle 就直接返回 true，表示去执行下一个过滤器，当前这个过滤器除了匹配URI之外什么都没做。如果 match 成功，再调用<code>onPreHandle</code>方法，此时 onPreHandle 的返回值就是 preHandle 的返回值，可以决定是继续执行后续的过滤器还是中断。onPreHandle 也是一个钩子方法，默认实现直接返回 true，可由子类重写。</p><p>很容易想到，在 onPreHandle 内定义的就是当前过滤器对自己匹配的URI的处理工作，如判断用户是否有权访问匹配的URI，有权访问则返回 true，可继续执行后面的过滤器，无权访问则中断。</p><p>下面介绍成员<code>Map&lt;String, Object&gt; appliedPaths</code>的含义。map key 为当前过滤器适用的URI，value 为URI对应的“配置”。比如按下面过滤器链的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/logout"</span>, <span class="string">"logout"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/login"</span>, <span class="string">"anon"</span>); </span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/login/submit"</span>, <span class="string">"anon"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/*.ico"</span>, <span class="string">"anon"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/**"</span>, <span class="string">"authc"</span>);</span><br><span class="line">factory.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br></pre></td></tr></table></figure><p>这将会创建3个 Filter 对象，分别叫 logout、anon、authc（具体的实现类见前言中的<code>DefaultFilter</code>）。每个过滤器的成员 appliedPaths 中的 map key 就是和它们匹配的URI，value 为 null。如”anon”过滤器的 appliedPaths 含3个元素：&lt;”/login”, null&gt;, &lt;”/login/submit”, null&gt;, &lt;”/*.ico”, null&gt;</p><p>如果在过滤器名字之后还加了“配置”，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterChainDefinitionMap.put(<span class="string">"/**"</span>, <span class="string">"roles[admin, user]"</span>);</span><br></pre></td></tr></table></figure><p>那么”roles”过滤器的 appliedPaths 包含：&lt;”/**”, [“admin”,”user”]&gt;</p><blockquote><p>appliedPaths 是如何添加的？见博客《SpringShiroFilter原理》中的“创建原理”一节。</p></blockquote><h1 id="AccessControlFilter"><a href="#AccessControlFilter" class="headerlink" title="AccessControlFilter"></a>AccessControlFilter</h1><p>抽象类，实现了直接父类 PathMatchingFilter 的<code>onPreHandle</code>方法，实现代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AccessControlFilter 新定义了两个方法：<code>isAccessAllowed</code>和<code>onAccessDenied</code>，但未实现。</p><p>onPreHandle 方法的含义是，先执行<code>isAccessAllowed</code>方法判断是否可继续（可访问），若可继续（isAccessAllowed=true），则 onPreHandle=true。若不可继续，则调用<code>onAccessDenied</code>处理不可访问的情况，处理完可返回 true or false。onAccessDenied=true 说明可执行后面的过滤器，onAccessDenied=false 则中断过滤器的执行直接返回响应（如 AdviceFilter 中所述）。</p><p>除此以外，AccessControlFilter 还增加了对 loginUrl 的识别和处理，以及获取<code>Subject</code>对象的方法，定义它的子类时可使用这些方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前请求线程中的 subject</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Subject <span class="title">getSubject</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SecurityUtils.getSubject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是登录请求</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isLoginRequest</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pathsMatch(getLoginUrl(), request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AuthenticationFilter-和-AuthenticatingFilter"><a href="#AuthenticationFilter-和-AuthenticatingFilter" class="headerlink" title="AuthenticationFilter 和 AuthenticatingFilter"></a>AuthenticationFilter 和 AuthenticatingFilter</h1><p>2个都属于认证过滤器，都是抽象类。继承链（从子类到父类）是：AuthenticatingFilter -&gt; AuthenticationFilter -&gt; AccessControlFilter。这两个类都只实现了 isAccessAllowed 方法（如下源码），未实现 onAccessDenied 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AuthenticationFilter</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> </span>&#123;</span><br><span class="line">Subject subject = getSubject(request, response);</span><br><span class="line"><span class="keyword">return</span> subject.isAuthenticated();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AuthenticatingFilter</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.isAccessAllowed(request, response, mappedValue) ||</span><br><span class="line">(!isLoginRequest(request, response) &amp;&amp; isPermissive(mappedValue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到这是一个用于认证的过滤器，就很好理解上面 AuthenticatingFilter.isAccessAllowed() 方法的含义：若用户已登录，或 requestURI 不是 loginUrl 且 requestURI 带有”permissive”配置，则当前过滤器结束，继续执行后续过滤器。否则进入 onAccessDenied 方法内执行认证。</p><p>AuthenticatingFilter 与父类相比，扩展了更多和登录有关的方法。</p><p>自定义的认证过滤器一般继承于它们，需要实现 onAccessDenied 方法，方法内实现用户登录校验等逻辑。</p><h1 id="AuthorizationFilter"><a href="#AuthorizationFilter" class="headerlink" title="AuthorizationFilter"></a>AuthorizationFilter</h1><p>授权过滤器，抽象类，继承自 AccessControlFilter，实现了 onAccessDenied 方法（如下源码），代表不可访问后的处理，未实现 isAccessAllowed 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">     Subject subject = getSubject(request, response);</span><br><span class="line">     <span class="comment">// 若用户未登录，重定向到loginUrl</span></span><br><span class="line">     <span class="keyword">if</span> (subject.getPrincipal() == <span class="keyword">null</span>) &#123;</span><br><span class="line">         saveRequestAndRedirectToLogin(request, response);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 401页面URL</span></span><br><span class="line">         String unauthorizedUrl = getUnauthorizedUrl();</span><br><span class="line"><span class="comment">// 若有401页面就重定向到此页，若无则只返回HTTP状态码401</span></span><br><span class="line">         <span class="keyword">if</span> (StringUtils.hasText(unauthorizedUrl)) &#123;</span><br><span class="line">             WebUtils.issueRedirect(request, response, unauthorizedUrl);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>自定义的授权过滤器一般继承于它，需要实现 isAccessAllowed 方法，方法内判断 requestURI 是否可访问。</p><h1 id="LogoutFilter"><a href="#LogoutFilter" class="headerlink" title="LogoutFilter"></a>LogoutFilter</h1><p>继承自 AdviceFilter，只实现了 preHandle 方法。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Subject subject = getSubject(request, response);</span><br><span class="line">    String redirectUrl = getRedirectUrl(request, response, subject); <span class="comment">// 退出登录后跳转的页面</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        subject.logout(); <span class="comment">// 执行用户退出登录的操作</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SessionException ise) &#123;</span><br><span class="line">        log.debug(<span class="string">"Encountered session exception during logout.  This can generally safely be ignored."</span>, ise);</span><br><span class="line">    &#125;</span><br><span class="line">    issueRedirect(request, response, redirectUrl); <span class="comment">// 跳转页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 返回false说明中断Shiro过滤器链</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给 URL=”/logout” 配置这个 Filter，就能在用户点击“退出登录”时进入这个 Filter，完成退出以及退出后跳转页面的操作，不需要自己写用户退出时的代码。</p><p>另外，退出后跳转页面默认URL=”/“，如果要自定义，则需要这样配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LogoutFilter logoutFilter = <span class="keyword">new</span> LogoutFilter();</span><br><span class="line">logoutFilter.setRedirectUrl(<span class="string">"/login"</span>); <span class="comment">// 自定义跳转页面</span></span><br><span class="line"></span><br><span class="line">Map&lt;String, Filter&gt; filtersMap = <span class="keyword">new</span> LinkedHashMap&lt;String, Filter&gt;();</span><br><span class="line">filtersMap.put(<span class="string">"logout"</span>, logoutFilter); <span class="comment">// 用自己的实例替换默认的LogoutFilter实例</span></span><br><span class="line">factory.setFilters(filtersMap); <span class="comment">// 设置到 ShiroFilterFactoryBean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置过滤器链</span></span><br><span class="line">Map&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/logout"</span>, <span class="string">"logout"</span>);</span><br><span class="line"><span class="comment">// 以下略...</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java8 Stream API 常用方法</title>
      <link href="/2021/08/18/java8-stream-api-note/"/>
      <url>/2021/08/18/java8-stream-api-note/</url>
      
        <content type="html"><![CDATA[<p>以下面的 User 类和 userList 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId, String userName, <span class="keyword">int</span> age, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">userList.add(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"aa"</span>, <span class="number">20</span>, <span class="string">"shenzhen"</span>));</span><br><span class="line">userList.add(<span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"bb"</span>, <span class="number">20</span>, <span class="string">"guangzhou"</span>));</span><br><span class="line">userList.add(<span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"cc"</span>, <span class="number">21</span>, <span class="string">"foshan"</span>));</span><br><span class="line">userList.add(<span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">"dd"</span>, <span class="number">22</span>, <span class="string">"zhongshan"</span>));</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>使用Stream API，要求 List 不为 null，但可以为空</p><p>以下面代码为例，若 userList 为空，则出来的 userIdList 也为空，但不为 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (userList != <span class="keyword">null</span>)&#123;</span><br><span class="line">List&lt;Integer&gt; userIdList = userList.stream().map(User::getUserId).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="取一个属性组成List或Set"><a href="#取一个属性组成List或Set" class="headerlink" title="取一个属性组成List或Set"></a>取一个属性组成List或Set</h1><p>从userList中取userId组成List或Set：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; userIdList = userList.stream().map(User::getUserId).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>若要得到 Set，最后换成<code>Collectors.toSet()</code>。</p><h1 id="取两个属性组成Map"><a href="#取两个属性组成Map" class="headerlink" title="取两个属性组成Map"></a>取两个属性组成Map</h1><p>从userList中取userId和userName组成Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; userIdNameMap = userList.stream().collect(Collectors.toMap(User::getUserId, User::getUserName));</span><br></pre></td></tr></table></figure><h1 id="按一个属性分组，组成-key-属性，value-该属性下的list的Map"><a href="#按一个属性分组，组成-key-属性，value-该属性下的list的Map" class="headerlink" title="按一个属性分组，组成 key=属性，value=该属性下的list的Map"></a>按一个属性分组，组成 key=属性，value=该属性下的list的Map</h1><p>从userList中按address分组，组成 key=address，value=该address下的UserList的Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;User&gt;&gt; addrMap = userList.stream().collect(Collectors.groupingBy(User::getAddress));</span><br></pre></td></tr></table></figure><h1 id="按一个属性分组，组成-key-属性，value-另一个属性list的Map"><a href="#按一个属性分组，组成-key-属性，value-另一个属性list的Map" class="headerlink" title="按一个属性分组，组成 key=属性，value=另一个属性list的Map"></a>按一个属性分组，组成 key=属性，value=另一个属性list的Map</h1><p>从userList中按address分组，组成 key=address，value=userIdList的Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Integer&gt;&gt; addrMap = userList.stream().collect(</span><br><span class="line">Collectors.groupingBy(User::getAddress, Collectors.mapping(User::getUserId, Collectors.toList()))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="按多个属性分组"><a href="#按多个属性分组" class="headerlink" title="按多个属性分组"></a>按多个属性分组</h1><p>从userList中按address和age分组，组成 key=address，value=该address下的UserList的Map，将 address 和 age 属性拼接成一个字符串，以这个字符串做分组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;User&gt;&gt; map = userList.stream().collect(Collectors.groupingBy(user -&gt; user.getAddress() + <span class="string">"_"</span> + user.getAge()));</span><br></pre></td></tr></table></figure><h1 id="按照属性值查找一个元素"><a href="#按照属性值查找一个元素" class="headerlink" title="按照属性值查找一个元素"></a>按照属性值查找一个元素</h1><p>从userList中查找age=20的第一个人/某个人：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个</span></span><br><span class="line">Optional&lt;User&gt; first = userList.stream().filter(user -&gt; user.getAge() == <span class="number">20</span>).findFirst();</span><br><span class="line"><span class="keyword">if</span> (first.isPresent()) &#123;</span><br><span class="line">System.out.println(<span class="string">"first: "</span> + first.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任何一个</span></span><br><span class="line">Optional&lt;User&gt; any = userList.stream().filter(user -&gt; user.getAge() == <span class="number">20</span>).findAny();</span><br><span class="line"><span class="keyword">if</span> (any.isPresent()) &#123;</span><br><span class="line">System.out.println(<span class="string">"any: "</span> + any.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="按照属性值查找所有元素"><a href="#按照属性值查找所有元素" class="headerlink" title="按照属性值查找所有元素"></a>按照属性值查找所有元素</h1><p>从userList中查找age=20的所有user列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList1 = userList.stream().filter(user -&gt; user.getAge() == <span class="number">20</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean的生命周期——Bean定义</title>
      <link href="/2021/08/15/spring-bean-lifecycle-definition/"/>
      <url>/2021/08/15/spring-bean-lifecycle-definition/</url>
      
        <content type="html"><![CDATA[<p>Spring Bean 的生命周期有4个阶段：Bean 定义、Bean 初始化、Bean 生存期、Bean 销毁。因为“Bean 生存期”阶段就是程序启动后我们使用 Bean 的过程，所以不需要介绍。这篇博客介绍的是“Bean 定义”阶段。</p><blockquote><p>源码版本：SpringBoot 2.3.0，Spring 5.2.6</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>“Bean定义”是 Spring Bean 的生命周期的第一个阶段，这个阶段里会根据启动类上的注解 <code>@ComponentScan</code> 指定的包路径（默认是当前包及其子包）扫描，把 Bean 定义信息保存到 IoC 容器中，待“Bean 初始化”阶段使用。</p><p>SpringBoot Web 应用使用的 IoC 容器为<code>AnnotationConfigServletWebServerApplicationContext</code>，这个容器包含一个属性：beanFactory = <code>DefaultListableBeanFactory</code> 。所有 Bean 定义信息就是保存到 DefaultListableBeanFactory 的成员 <code>Map&lt;String, BeanDefinition&gt; beanDefinitionMap</code> 中。<code>BeanDefinidition</code> 是用来记录 Bean 定义信息的接口，子类有 RootBeanDefinition、AnnotatedGenericBeanDefinition、ScannedGenericBeanDefinition 等。</p><p>真正开始注册 Bean 定义信息的时候是容器刷新的时候，即发生在 AbstractApplicationContext.refresh() 中。下面先看看容器刷新前为“Bean 定义”阶段做了哪些工作。</p><h1 id="容器刷新前的准备"><a href="#容器刷新前的准备" class="headerlink" title="容器刷新前的准备"></a>容器刷新前的准备</h1><p><strong>提前总结：</strong><br>SpringApplication 先创建容器对象 context = AnnotationConfigServletWebServerApplicationContext，赋值其中成员 beanFactory = DefaultListableBeanFactory。容器对象创建完成后，成员 beanFactory 内已经有少数几个 BeanDefinidition 信息了，其中包括 ConfigurationClassPostProcessor。然后 SpringApplication 向容器对象成员 beanFactory 中注册了启动类 DemoApplication 的 BeanDefinidition。</p><p>在 SpringAppliction.run(String… args) 方法中，创建 IoC 容器 AnnotationConfigServletWebServerApplicationContext 时，反射调用该类及其父类们的无参构造方法，初始化成员 beanFactory = DefaultListableBeanFactory。</p><p>在容器 AnnotationConfigServletWebServerApplicationContext 自己的无参构造中，初始化成员 reader = <code>AnnotatedBeanDefinitionReader</code> 。在 AnnotatedBeanDefinitionReader 的构造函数中，调用了<code>AnnotationConfigUtils.registerAnnotationConfigProcessors()</code> 方法，这个方法内往容器成员 beanFactory 中注册了几个指定的 Bean 定义（RootBeanDefinition 类型），其中包括 <code>ConfigurationClassPostProcessor</code> ，下面会介绍它。</p><blockquote><p> 从 AnnotatedBeanDefinitionReader 源码可以看出，它的作用是手动注册某个 Bean 的定义信息。这个在容器开始扫描所有 Bean 之前很好用，这是因为有一些 Bean 需要在扫描前就被初始化，例如启动类的 Bean。</p></blockquote><p>回到 SpringAppliction.run(String… args) 方法，创建好容器后，调用本类的<code>prepareContext</code>方法，这个方法内最后调用<code>SpringApplication.load()</code>方法。</p><p>SpringApplication.load() 部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ApplicationContext context, Object[] sources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Loading source "</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class="line">&#125;</span><br><span class="line">BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanNameGenerator != <span class="keyword">null</span>) &#123;</span><br><span class="line">loader.setBeanNameGenerator(<span class="keyword">this</span>.beanNameGenerator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">loader.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">loader.setEnvironment(<span class="keyword">this</span>.environment);</span><br><span class="line">&#125;</span><br><span class="line">loader.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>参数1context</code>为已创建的容器对象，<code>参数2sources</code>只有一个元素，就是启动类 Class 对象，如”DemoApplication.class”（来源是 SpringApplication.run() 方法时的第一个参数）。在这个方法内，创建 BeanDefinitionLoader 对象，再通过 BeanDefinitionLoader 对象内成员<code>AnnotatedBeanDefinitionReader</code>（与容器内的 reader 不是同一个对象，但它的成员 registry 与 容器内的 beanFactory 是同一个对象），向容器中注册了启动类 DemoApplication 的 Bean 定义（AnnotatedGenericBeanDefinition 类型）。主要负责这个注册工作的是<code>AnnotatedBeanDefinitionReader.doRegisterBean()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, @Nullable String name,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, @Nullable Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// beanClass=启动类Class对象</span></span><br><span class="line">AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一步判断这个bean上是否加了@Conditional注解，加了就不继续</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abd.setInstanceSupplier(supplier);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一步设置BeanDefinition中的scope属性，若未使用@Scope注解，则取默认值"singleton"</span></span><br><span class="line"><span class="comment">// 同时设置了scopedProxyMode=NO</span></span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取beanName用于注册，详细说明见下方</span></span><br><span class="line">String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对常用注解的处理，如使用了@Lazy则设置lazyInit=true。qualifiers是调用这个方法时手动设置的注解类Class，与bean本身是否使用注解无关</span></span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line"><span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line"><span class="keyword">if</span> (Primary<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Lazy<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 猜测是给abd任意设置属性的方法</span></span><br><span class="line"><span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">customizer.customize(abd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line"><span class="comment">// 这一步判断scopedProxyMode，如果不是NO，则definitionHolder的BeanDefinidition的beanClass=ScopedProxyFactoryBean.class</span></span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面源码取 beanName 时，用的是<code>AnnotationBeanNameGenerator.generateBeanName()</code>，当 Bean 定义对象是 AnnotatedBeanDefinition 的子类时（AnnotatedGenericBeanDefinition 就是），用的是下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">determineBeanNameFromAnnotation</span><span class="params">(AnnotatedBeanDefinition annotatedDef)</span> </span>&#123;</span><br><span class="line">AnnotationMetadata amd = annotatedDef.getMetadata();</span><br><span class="line"><span class="comment">// types是类上直接标注的注解集合</span></span><br><span class="line">Set&lt;String&gt; types = amd.getAnnotationTypes();</span><br><span class="line">String beanName = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (String type : types) &#123; <span class="comment">// 遍历types</span></span><br><span class="line"><span class="comment">// attributes是注解 type 中的所有属性,k-v格式,key=属性名,value=属性值</span></span><br><span class="line">AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);</span><br><span class="line"><span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当type是个复合注解，metaTypes是这个复合注解中所包含的注解集合</span></span><br><span class="line">Set&lt;String&gt; metaTypes = <span class="keyword">this</span>.metaAnnotationTypesCache.computeIfAbsent(type, key -&gt; &#123;</span><br><span class="line">Set&lt;String&gt; result = amd.getMetaAnnotationTypes(key);</span><br><span class="line"><span class="keyword">return</span> (result.isEmpty() ? Collections.emptySet() : result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断type和metaType中是否包含@Component注解</span></span><br><span class="line"><span class="keyword">if</span> (isStereotypeWithNameValue(type, metaTypes, attributes)) &#123;</span><br><span class="line"><span class="comment">// 取@Component的value属性</span></span><br><span class="line">Object value = attributes.get(<span class="string">"value"</span>);</span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">String strVal = (String) value;</span><br><span class="line"><span class="comment">// 若value属性值有指定，就作为beanName返回</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(strVal)) &#123;</span><br><span class="line"><span class="comment">// 但如果一个类有多个@Component注解指定了value值，会报错（如@Component和@Service同时存在且同时指定了value）</span></span><br><span class="line"><span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; !strVal.equals(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Stereotype annotations suggest inconsistent "</span> +</span><br><span class="line"><span class="string">"component names: '"</span> + beanName + <span class="string">"' versus '"</span> + strVal + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">beanName = strVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释中所说的“复合注解”举例：@SpringBootApplication 下包含 @EnableAutoConfiguration，@EnableAutoConfiguration 下又包含 @Import 等。</p><p>这个方法的含义是，从当前 bean 的所有注解中找 @Component 注解，如果有 @Component 注解且指定了 value 属性，则 beanName=value属性值，否则 beanName=null。当这个方法返回的 beanName=null 时，就会用另一个方法：取类名，第一个字母小写。</p><p>例如我们的启动类一般不会特意用 @Component 指定 bean 名字（@SpringBootApplication 指定不了），所以启动类的 beanName 就是取类名，第一个字母小写。</p><blockquote><p>问题：注册 Bean 定义时，为什么加了 @Conditional注解就不继续？@Conditional只是控制一个bean在特定条件下才注入。 ？？？</p></blockquote><h1 id="容器刷新"><a href="#容器刷新" class="headerlink" title="容器刷新"></a>容器刷新</h1><p>在 AbstractApplicationContext.refresh() 方法中，调用本类中的 invokeBeanFactoryPostProcessors 方法，参数是 beanFactory = DefaultListableBeanFactory。在这个方法中，又调用了<code>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()</code>方法。</p><p>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors() 方法参数1是 beanFactory，参数2是容器中已添加的 BeanFactoryPostProcessor（是在上一节“容器刷新前的准备”阶段添加的， 这里不用关注有哪些）。这个方法的作用是取出容器中当前已保存的、实现了 BeanFactoryPostProcessor 接口的 Bean，并初始化这些 Bean，然后调用这些 Bean 的，以及“参数2”中的 Bean 的 postProcessBeanFactory 方法，若 Bean 实现的接口是 <code>BeanDefinitionRegistryPostProcessor</code>（该接口继承了 BeanFactoryPostProcessor），会先调用其 postProcessBeanDefinitionRegistry 方法，再调用其 postProcessBeanFactory 方法。</p><p>【PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors() 方法的详细解读见附录1。</p><p>在上一节说过，容器刚创建时就注册了 ConfigurationClassPostProcessor 的 BeanDefinidition 对象，它就是 BeanDefinitionRegistryPostProcessor 接口的实现类，所以在这个方法内会创建并实例化它的 Bean，再调用它的 postProcessBeanDefinitionRegistry 方法。</p><p>ConfigurationClassPostProcessor 是在“Bean 定义”阶段最关键的一个类，XXXXXXXXXXXXXXX</p><p>这个类做了什么？</p><p><strong>1、</strong>取出容器当前拥有的 BeanDefinidition 对象，判断它们是否是配置类，不是配置类的不处理，是配置类的继续处理。</p><p>这里判断是不是配置类的方法是<code>ConfigurationClassUtils.checkConfigurationClassCandidate</code>。简单地说，类上有这些注解之一的：@Configuration、@Component、@ComponentScan、@Import、@ImportResource，或类中方法有注解 @Bean 的，都算配置类。</p><p>PS: 从实际使用经验上来说，类上不标任何注解，只在方法上标注解 @Bean，是不起作用的，原因是这样的类在扫描时就扫不到，更进不到这个判断方法。</p><p>在这一步，本身容器中已注册的 BeanDefinidition 就不多，再经过筛选，就只剩下启动类如”DemoApplication”的 BeanDefinidition 会被继续处理了。</p><blockquote><p>@Import 注解可用于导入一个或多个 Bean，它和 @Bean 的区别就是它是标在类上。@ImportResource 类似，但它是用于导入配置文件。</p></blockquote><p><strong>2、</strong>如果筛选完有多个配置类的话，若配置类上有标<code>@Order</code>注解，会排个序，按注解value值升序排序，所以值越小的优先级越高。</p><p><strong>3、</strong>创建<code>ConfigurationClassParser</code>，调用这个类的 parse 方法处理筛选出的配置类 BeanDefinidition 对象（只有启动类一个），这个类最后调用到<code>doProcessConfigurationClass</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数configClass和sourceClass都是启动类Class对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>通过方法内注释可以知道，这个方法会处理被这些注解标注的配置类：@PropertySource（可以和@Value注解配合使用读取配置项）、@ComponentScan、@Import、@ImportResource，和用 @Bean 标注的方法。</p><p>已知，Spring 会根据启动类上的 @ComponentScan 注解，扫描启动类所在包下所有的 Bean 定义信息，保存到 beanFactory=DefaultListableBeanFactory 中。这里就来说说 ConfigurationClassParser 是怎么处理 @ComponentScan 注解的。</p><h1 id="附录1：PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors"><a href="#附录1：PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors" class="headerlink" title="附录1：PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()"></a>附录1：PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存已经执行过的processor的名字</span></span><br><span class="line">Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123; <span class="comment">// 一般都走这个分支，因为 beanFactory=DefaultListableBeanFactory</span></span><br><span class="line"></span><br><span class="line">BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整理参数2中的processors，把有实现BeanDefinitionRegistryPostProcessor和没实现的分开存放</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line"><span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line"><span class="comment">// 保存前先执行BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">registryProcessors.add(registryProcessor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">regularPostProcessors.add(postProcessor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用来暂存当前要执行的processor，执行完即清空</span></span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从beanFactory中找实现了 BeanDefinitionRegistryPostProcessor 和 PriorityOrdered 接口的Bean，初始化，执行它们的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line"><span class="comment">// 这一步就会执行到 ConfigurationClassPostProcessor 的 postProcessBeanDefinitionRegistry 方法</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory); <span class="comment">// PriorityOrdered 接口可以定义执行顺序，执行前先排序</span></span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从beanFactory中找实现了 BeanDefinitionRegistryPostProcessor 和 Ordered 接口的Bean，初始化，执行它们的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从beanFactory中找只实现了 BeanDefinitionRegistryPostProcessor 接口的Bean，初始化，执行它们的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line"><span class="comment">// 循环的原因：一个processor可能会添加新的 BeanDefinitionRegistryPostProcessor 接口的Bean，所以循环到找不到新的为止</span></span><br><span class="line"><span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">reiterate = <span class="keyword">false</span>;</span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">reiterate = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历调用 registryProcessors 中的 postProcessBeanFactory 方法，registryProcessors 包含参数2中实现了 BeanDefinitionRegistryPostProcessor 的类和前面几次从 beanFactory 中找 BeanDefinitionRegistryPostProcessor 类型的Bean定义生成的Bean</span></span><br><span class="line">invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line"><span class="comment">// 遍历调用 regularPostProcessors 中的 postProcessBeanFactory 方法，regularPostProcessors 包含参数2中未实现 BeanDefinitionRegistryPostProcessor 的类</span></span><br><span class="line">invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">// 遍历调用参数2 beanFactoryPostProcessors 中的 postProcessBeanFactory 方法</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这部分和上面相似，只是类型换成了 BeanFactoryPostProcessor</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line"><span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line">invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// beanFactory清除缓存</span></span><br><span class="line">beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结这个方法做的事：</p><ol><li>执行 BeanDefinitionRegistryPostProcessor 类型的、实现了 PriorityOrdered 接口的 postProcessor 的 postProcessBeanDefinitionRegistry 方法 — 这里会执行到 ConfigurationClassPostProcessor</li><li>执行 BeanDefinitionRegistryPostProcessor 类型的、实现了 Ordered 接口的 postProcessor 的 postProcessBeanDefinitionRegistry 方法</li><li>执行 BeanDefinitionRegistryPostProcessor 类型的、没有实现 PriorityOrdered/Ordered 接口的 postProcessor 的 postProcessBeanDefinitionRegistry 方法</li><li>执行方法参数中实现了 BeanDefinitionRegistryPostProcessor 的，和前面三步的BeanDefinitionRegistryPostProcessor 类型的  postProcessor 的 postProcessBeanFactory 方法</li><li>执行方法参数中未实现 BeanDefinitionRegistryPostProcessor 的 postProcessor 的 postProcessBeanFactory 方法</li><li>执行 BeanFactoryPostProcessor 类型的、实现了 PriorityOrdered 接口的 postProcessor 的 postProcessBeanFactory 方法</li><li>执行 BeanFactoryPostProcessor 类型的、实现了 Ordered 接口的 postProcessor 的 postProcessBeanFactory 方法</li><li>执行 BeanFactoryPostProcessor 类型的 postProcessor 的 postProcessBeanFactory 方法</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java类的生命周期</title>
      <link href="/2021/08/08/java-class-lifecycle/"/>
      <url>/2021/08/08/java-class-lifecycle/</url>
      
        <content type="html"><![CDATA[<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>加载 -&gt; 链接 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p><h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><p>一个 Java 源代码文件（后缀 .java），通常被称为“编译单元”。每个编译单元中只能有一个 public 类，可以有其他非 public 类。.java 文件名与文件中这个唯一的 public 类同名。</p><p>编译一个 .java 文件时，文件中的<strong>每个类</strong>都会有一个输出文件（后缀 .class），每个 .class 文件名与类名相同。这个工作是 Java 编辑器负责，命令是”javac”。</p><p>Java 可运行程序（后缀 .jar）是一组 .class 文件，Java 解释器负责这些文件的查找、装载和解释。</p><p>Java 解释器的运行过程：</p><ol><li>找出环境变量<code>CLASSPATH</code>，例如”CLASSPATH=.;%JAVA_HOME%/lib”，作为查找 .class 文件的根目录</li><li>从根目录开始，解释器在每个<br>。。。。</li></ol><p>由类加载器执行，该步骤将查找字节码，并从这些字节码中创建一个 Class 对象。</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>在链接阶段验证类中的字节码，为静态域（static）分配存储空间，并且将解析这个类创建的其他类的引用（若有）。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>举例说明，初始化<code>Dog</code>类时的执行顺序：</p><ol><li>当首次创建类型为 Dog 的对象时，或 Dog 类的 static 成员/static 方法首次被访问时，Java 解释器查找类路径，定位 Dog.class 文件 – 这一步属于加载</li><li>载入 Dog.class 文件创建 Class 对象（加载），执行静态初始化（链接）。因此，静态初始化只在 Class 对象首次加载的时候执行一次</li><li>用”new Dog()”创建对象时，在堆上分配存储空间</li><li>这块存储空间会被清零，这也就完成了将 Dog 对象中的基本数据类型成员设置成了默认值，引用成员被设置成 null</li><li>执行所有字段定义处的初始化动作。字段初始化顺序同它们定义的先后顺序</li><li>执行构造器，若有父类则先执行父类构造器再执行子类构造器</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6大设计原则</title>
      <link href="/2021/08/01/design-principle/"/>
      <url>/2021/08/01/design-principle/</url>
      
        <content type="html"><![CDATA[<h1 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h1><p>应该有且仅有一个原因引起类的变更，换句话说，类的职责应尽量单一。</p><p>为什么？如果类的职责单一，那么只有它负责的部分出现了变化，它才会被修改。这个类被修改的次数越少，那么其他模块依赖它的部分修改的次数也就少了。这可以提高系统的可维护性。</p><p>该原则试用于接口、类、方法。</p><p><strong>实际使用时，</strong>因为对“职责”划分的标准不同，所以很难实现真正的单一职责。一般建议是，接口职责单一（接口尽量少修改），类不一定单一，一个类可以实现多个接口，但类尽量保证只有一个原因需要修改。</p><h1 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h1><p>父类能出现的地方，子类就能出现。相反，子类出现的地方，父类不一定能出现。即，子类能替换父类，但父类不能替换子类。</p><p>通俗地讲，代码里使用了父类的地方，把父类类型直接替换成子类后，对运行结果无影响。但如果反过来，使用了子类的地方，不能替换成父类，要么编译不通过要么运行结果变了。</p><p>做到这个原则，要遵守4个条件：</p><ol><li>子类必须全部实现父类方法</li><li>子类可以有自己的“个性”，即有自己的 public 方法或自己的子类</li><li>子类重载父类方法时，输入参数的范围比父类方法的大。如父类方法参数是 HashMap 类型，子类的应该是 Map 类型。<strong>注意这里是重载不是重写</strong></li><li>子类重写父类方法时，返回参数的范围要么与父类一致，要么缩小，总之不能比父类返回的范围大。<strong>注意这里是重写不是重载</strong></li></ol><p>这4个条件是针对场景制定的，若子类不需要增加 public 方法，也不需要重载或重写父类方法，就只需遵守第一条就够。</p><p>对于第二条，若子类拥有了“个性”，那么使用这个子类的模块就与一个具体的类强耦合，这个模块不能通过依赖父类来依赖子类（因为父类没有子类的个性方法）。除非有这种需求场景，否则应该避免子类的“个性”，才能完美替换父类和子类。</p><p>子类在重载或重写时做到了第三、第四点，可以保证，用子类替换父类时，既不会编译报错，也不会影响运行结果。</p><p>平时用到里氏替换的场景：做设计时，经常先定义一个接口或抽象类，然后编码实现，声明这个类的变量时，是写接口或抽象类类型，但实际传入的对象类型是子类类型，这里就已经使用了里氏替换原则。</p><blockquote><p>方法重写是子类 Override 父类方法，方法重载是方法名相同但参数不同</p></blockquote><h1 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h1><p>定义：</p><ol><li>模块间的依赖是通过接口或抽象类产生，实现类之间没有直接的依赖关系</li><li>接口或抽象类不依赖于实现类</li><li>实现类依赖接口或抽象类</li></ol><p>更加精简的定义是：“面向接口编程”。</p><p>这个原则可以结合里氏替换原则使用。因为里氏替换原则使得父类可以被替换为子类，所以，如果把依赖的模块声明为接口或抽象类，那么就能通过“注入”的方式直接换成它们的子类。</p><p>Spring 的依赖注入就体现了这个原则。我们声明注入的对象都是以接口类型声明，由 IoC 容器注入实现类。若有多个实现类，我们可以控制注入哪个，注入哪个实现类都不会影响原依赖关系和逻辑。</p><h1 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h1><p>客户端不应该依赖它不需要的接口。即，提供给外部的接口最好是“定制化”的，外部模块需要什么就只给什么，其他的都不开放。</p><p>如果一个接口有10个方法，提供给多个外部模块使用，一个模块可能只使用其中一两个，这就不符合接口隔离原则。接口隔离原则希望接口尽量“小”，即只有少量的 public 方法。</p><p>给外部模块提供太多方法会导致，也许口头约定只使用一两个接口，但因为外部模块开发组的疏忽使用了不该使用的方法且你不知情，增加风险。</p><p>要做到接口隔离，首先要决定接口的粒度，接口粒度太小，会导致接口数量太多；粒度太大，灵活性降低（因为一个接口同时被多个模块使用，修改时有影响多个模块的风险）。</p><p>接口粒度如何决定，只能靠实践、经验和感悟。</p><h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h1><p>类中方法不应该引入“朋友类”之外的类对象。“朋友类”的定义是，出现在成员变量、方法的输入输出参数声明中的类是朋友类，而出现在方法内部的类则是“非朋友类”。这个原则规定，方法内部不应该出现“非朋友类”，应该只有朋友类，这样做是为了降低类之间的耦合性。</p><p>同时，这个原则也强调，接口对外提供的方法要尽量少，即朋友类之间的依赖也要尽量少。这点和接口隔离原则一致。</p><p>遇到问题：一个方法既可以放在本类，又可以放在其他类，到底应该放在哪儿？这个原则告诉我们，如果这个方法放在本类中，即不增加类间耦合，也不对本类产生负面影响，那就放在本类中。这也是为了本类在使用这个方法时不用依赖其他类。</p><p>这个原则的核心观念就是类间解耦，类的弱耦合。但结果可能是一个类要访问另一个类时，中间有很多跳转类。一般来说，一个类访问到另一个类的跳转次数最多不超过2次，否则系统复杂性太大，可维护性小。</p><h1 id="开闭原则（OCP）"><a href="#开闭原则（OCP）" class="headerlink" title="开闭原则（OCP）"></a>开闭原则（OCP）</h1><p>对扩展开放，对修改关闭。换句话说，一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。“软件实体”指的是，一个接口、类、方法，或一部分逻辑模块。</p><p>开闭原则是最基础的原则，以上5个原则是它的具体形态。</p><p>实现方法：</p><ol><li>抽象约束<ol><li>通过抽象限定扩展范围</li><li>方法参数类型、成员变量尽量使用接口或抽象类，避免使用实现类</li><li>抽象层尽量稳定，一旦确定就不允许修改</li></ol></li><li>元数据控制模块行为。“元数据”就是配置参数（从配置文件或数据库取），通过配置就可以实现大部分的功能，不需要修改代码。举例：通过配置IP黑名单，就可以控制不允许某个IP访问接口。</li><li>封装变化。若预测到将来可能出现的变化，尽量把它封装在一个接口中，这样这个变化只影响一个接口。23种设计模式就是用于封装变化的。</li><li>制定项目章程。要求成员按照项目组指定的开发规范编写，如要求做到上面提到的几点，使得代码不杂乱，将来可维护性强。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java强引用软引用弱引用虚引用</title>
      <link href="/2021/07/25/java-reference-type/"/>
      <url>/2021/07/25/java-reference-type/</url>
      
        <content type="html"><![CDATA[<p>Java有4种引用类型：强引用、软引用、弱引用、虚引用。</p><p><strong>程序中一般只用强引用和软引用</strong>，软引用的优点在于内存不够时GC会主动回收，防止OutOfMemory异常。</p><p>参考：<a href="https://segmentfault.com/a/1190000015282652" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015282652</a></p><h1 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h1><p>平时程序中的引用就是强引用。如果一个对象具有强引用，GC一定不会回收它，即使内存不够用了。</p><h1 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h1><p>如果一个对象只具有软引用，只有当内存不够时，GC会回收它。GC会先回收很久没用的软引用。</p><p>软引用的使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"abc"</span>);</span><br><span class="line">SoftReference&lt;Person&gt; = <span class="keyword">new</span> SoftReference&lt;Person&gt;(person);</span><br><span class="line">person = <span class="keyword">null</span>; <span class="comment">// 对象Person("abc")只剩下软引用</span></span><br></pre></td></tr></table></figure><p>创建软引用对象<code>SoftReference</code>时，可以将软引用对象和一个引用队列<code>ReferenceQueue</code>关联，如果软引用所引用的对象被垃圾回收，JVM就会把这个软引用加入到与之关联的引用队列中。 </p><h1 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h1><p>如果一个对象只具有弱引用，无论内存是否足够，到GC回收的时间时它都会被回收。弱引用也可以和一个引用队列<code>ReferenceQueue</code>关联。</p><p>弱引用的使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"abc"</span>);</span><br><span class="line">WeakReference&lt;Person&gt; = <span class="keyword">new</span> WeakReference&lt;Person&gt;(person);</span><br><span class="line">person = <span class="keyword">null</span>; <span class="comment">// 对象Person("abc")只剩下弱引用</span></span><br></pre></td></tr></table></figure><h1 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h1><p>如果一个对象只具有虚引用，那么它和“没有引用”的对象无区别，随时都会被GC回收。虚引用必须和一个引用队列<code>ReferenceQueue</code>关联。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化策略</title>
      <link href="/2021/07/18/redis-rdb-aof/"/>
      <url>/2021/07/18/redis-rdb-aof/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis内存数据库"><a href="#Redis内存数据库" class="headerlink" title="Redis内存数据库"></a>Redis内存数据库</h1><p>单机Redis默认有16个数据库，名字就是编号0到15，用<code>redis-cli</code>进入时默认用0号数据库。可以自己切换数据库，当前在哪个数据库会直接显示在命令行。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 1 -- 切换到1号数据库</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; -- 编号显示[1]，当前在1号数据库</span><br><span class="line">127.0.0.1:6379[1]&gt; select 0 -- 切换到0号数据库</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; -- 回到0号</span><br></pre></td></tr></table></figure><p>数据库之间时完全隔离的，但也可以用一个命令同时清空所有数据库的数据（不推荐）。</p><p><strong>集群模式的Redis，每个Redis服务器只有一个数据库。</strong></p><p>Redis所有数据基本上都存在<strong>内存</strong>中，所以读写的速度很快。对比一下，Mysql的数据存在硬盘中，如果用的是 MyISAM 存储引擎，每次都要从硬盘中取数据。【如果是 InnoDB 引擎，会先从缓存中取数据，比 MyISAM 效率更高</p><p>Redis是内存数据库，所有数据保存在内存中，所以读写效率高。内存数据在计算机断电后不保存。对比一下，Mysql的数据存在硬盘中，如果用的是MyISAM存储引擎，每次都要从硬盘中取数据。</p><p>Redis持久化就是把内存数据保存到硬盘中，机器断电后也不会丢失，用于故障恢复。</p><p>Redis提供了两种<strong>持久化策略</strong>：RDB和AOF。默认使用RDB。</p><blockquote><p>内存、缓存、磁盘、硬盘<br><strong>硬盘</strong>就是<strong>磁盘</strong>，电脑中的“本地磁盘C”“本地磁盘D”就是硬盘的分区。<br><strong>内存</strong>是硬盘和CPU沟通的桥梁，计算机运行程序时，必须将磁盘中的内容加载到内存中，不加载是不能运行程序的。在内存中有一部分数据存的是磁盘的缓存，这样做可以加速磁盘访问速度。内存在计算机断电后不保存数据。<br><strong>缓存</strong>种类有一级、二级、三级缓存，作用是CPU要读取一个数据时，首先从缓存中查找，缓存没有CPU再从内存查找。<br>另外，<strong>虚拟内存</strong>，是指把磁盘中的一部分作为假想的内存使用。</p></blockquote><h1 id="持久化策略"><a href="#持久化策略" class="headerlink" title="持久化策略"></a>持久化策略</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB策略是，把当前时间，数据库中<strong>所有数据</strong>保存在文件中，重启Redis时会自动加载这个文件，恢复数据。RDB是默认的持久化方式。</p><p>存储数据的文件是二进制文件，文件名默认为 dump.rdb。文件过大时，可以设置是否压缩存储。</p><p>实现方法：</p><ol><li>save命令</li><li>bgsave命令</li><li>配置自动保存</li></ol><p>save 和 bgsave 的区别是，save 是占用主进程来保存，即保存期间Redis服务器不能处理其他请求，导致阻塞。bgsave 是调用操作系统方法生成一个子进程，子进程负责保存，主进程不阻塞（只有在生成子进程时阻塞）。</p><p>PS: Redis在Linux系统中调用fork()函数生成子进程，该函数的作用是创建一个与主进程基本相同的子进程。Windows系统中类似函数是createProcess()。</p><p>通过在Redis配置文件中添加配置<code>save N M</code>，实现“当N秒内至少有M个KEY被改动，就触发bgsave保存”的功能。因为是bgsave，所以不会阻塞主进程。</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF策略是，把<strong>所有写命令</strong>保存在文件中，重启Redis时会自动加载这个文件，逐条执行文件中的命令，恢复数据。</p><p>存储命令的文件不是二进制文件，是可以直接打开读的，文件名默认为 appendonly.aof。</p><p>PS: 当rdb和aof文件同时存在时，若Redis配置文件中设置开启了AOF，重启时只加载aof文件。仅当设置AOF关闭时，重启时才会加载rdb文件。</p><p>在Redis配置文件中添加<code>appendonly yes</code>，就开启了AOF持久化。</p><p>AOF持久化流程：</p><ol><li>所有的写命令都会追加到AOF缓冲区中</li><li>使用3种不同的策略将AOF缓冲区中的命令写到aof文件中</li></ol><p>3种不同的策略分别是：</p><ol><li>appendfsync always<br>每输入一条写命令，就把这条命令写入文件</li><li>appendfsync everysec<br>每秒种执行，这这一秒内增加的写命令写入文件</li><li>appendfsync no<br>由操作系统决定何时写入文件，不可控</li></ol><p>注意，Redis把命令从缓冲区写到文件中时，是<strong>同步</strong>的。所以如果是用<code>always</code>策略，性能会很低，一般使用<code>everysec</code>策略。</p><p>由于AOF文件一般会很大，因此可以在配置文件中，配置当aof文件大小达到某个阈值时，开始<strong>AOF文件重写</strong>。重写时，是调用操作系统方法生成一个子进程，子进程负责重写，主进程不阻塞。子进程复制原AOF文件进行重写，完毕后通知主进程。重写过程中，新增的命令除了追加到AOF缓冲区，还会追加到<strong>AOF重写缓冲区</strong>，AOF缓冲区中的命令在AOF策略调度时写入原AOF文件，当子进程通知重写完毕后，主进程把<strong>AOF重写缓冲区</strong>的命令写到AOF缓冲区，并用新文件替换旧文件，那些在重写过程中新增的命令，会在下一次AOF策略调度时写入新的aof文件。</p><p>重写后的aof文件会变小，但产生的数据不变。例如下面两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> cys ccc -- 增</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; del cys -- 删</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>结果相当于没有新增任何key，因此重写时就可以删除原aof文件中的这两天命令。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>RDB和AOF相比，优势在于，rdb文件一般较小，因为直接存储数据，所以恢复较快。劣势在于，在子进程持久化的过程中，主进程新增的数据不会保存到文件，若此时Redis挂掉会造成一段时间内的数据丢失。</p><p>AOF和RDB相比，优势在于，aof调度策略紧凑，最多丢失一秒内的数据。劣势在于，数据量大时，恢复速度比rdb文件慢。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁</title>
      <link href="/2021/07/18/redis-distributed-lock/"/>
      <url>/2021/07/18/redis-distributed-lock/</url>
      
        <content type="html"><![CDATA[<p>用 redis 实现分布式锁思路：</p><p>用<code>setnx</code>命令，作用是当key存在时不设置。</p><p>指定一个分布式锁的key，如“synclock”。</p><p>线程获取锁的操作就是执行<code>setnx key value</code>命令，key=synclock，value=这个key的超时时间（当前时间+指定毫秒数）和当前线程的某个标识（若在一个线程中要重复获取锁时会用上）</p><p>若set成功，说明成功获取锁，返回。</p><p>若set失败，则<code>get synclock</code>，查看此时synclock的超时时间是否已经超时，或者是否为当前线程已经得到的锁，如果超时或是当前线程的锁，则重新设置超时时间，获取锁返回。</p><p>其余情况说明未获取到锁，sleep几秒后再次尝试获取，在指定时间内一直未获取到锁则放弃。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock NO_LOCK = <span class="keyword">new</span> Lock(<span class="keyword">new</span> UUID(<span class="number">0l</span>,<span class="number">0l</span>), <span class="number">0l</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ONE_SECOND = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EXPIRY_TIME_MILLIS = Integer.getInteger(<span class="string">"com.github.jedis.lock.expiry.millis"</span>, <span class="number">60</span> * ONE_SECOND);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_ACQUIRE_TIMEOUT_MILLIS = Integer.getInteger(<span class="string">"com.github.jedis.lock.acquiry.millis"</span>, <span class="number">10</span> * ONE_SECOND);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_ACQUIRY_RESOLUTION_MILLIS = Integer.getInteger(<span class="string">"com.github.jedis.lock.acquiry.resolution.millis"</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisClient jedis; <span class="comment">// 自己封装StringRedisTemplate CRUD方法的类</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockKeyPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> lockExpiryInMillis;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> acquiryTimeoutInMillis;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UUID lockUUID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> UUID uuid;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> expiryTime;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">Lock</span><span class="params">(UUID uuid, <span class="keyword">long</span> expiryTimeInMillis)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.uuid = uuid;</span><br><span class="line">            <span class="keyword">this</span>.expiryTime = expiryTimeInMillis;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Lock <span class="title">fromString</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String[] parts = text.split(<span class="string">":"</span>);</span><br><span class="line">                UUID theUUID = UUID.fromString(parts[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">long</span> theTime = Long.parseLong(parts[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Lock(theUUID, theTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception any) &#123;</span><br><span class="line">                <span class="keyword">return</span> NO_LOCK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> UUID <span class="title">getUUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> uuid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpiryTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> expiryTime;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> uuid.toString()+<span class="string">":"</span>+expiryTime;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getExpiryTime() &lt; System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isExpiredOrMine</span><span class="params">(UUID otherUUID)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.isExpired() || <span class="keyword">this</span>.getUUID().equals(otherUUID);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Detailed constructor with default acquire timeout 10000 msecs and lock</span></span><br><span class="line"><span class="comment">     * expiration of 60000 msecs.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey</span></span><br><span class="line"><span class="comment">     *            lock key (ex. account:1, ...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(RedisClient jedis, String lockKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(jedis, lockKey, DEFAULT_ACQUIRE_TIMEOUT_MILLIS, DEFAULT_EXPIRY_TIME_MILLIS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Detailed constructor with default lock expiration of 60000 msecs.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey</span></span><br><span class="line"><span class="comment">     *            lock key (ex. account:1, ...)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquireTimeoutMillis</span></span><br><span class="line"><span class="comment">     *            acquire timeout in miliseconds (default: 10000 msecs)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(RedisClient jedis, String lockKey, <span class="keyword">int</span> acquireTimeoutMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(jedis, lockKey, acquireTimeoutMillis, DEFAULT_EXPIRY_TIME_MILLIS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Detailed constructor.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey</span></span><br><span class="line"><span class="comment">     *            lock key (ex. account:1, ...)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquireTimeoutMillis</span></span><br><span class="line"><span class="comment">     *            acquire timeout in miliseconds (default: 10000 msecs)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expiryTimeMillis</span></span><br><span class="line"><span class="comment">     *            lock expiration in miliseconds (default: 60000 msecs)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(RedisClient jedis, String lockKey, <span class="keyword">int</span> acquireTimeoutMillis, <span class="keyword">int</span> expiryTimeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(jedis, lockKey, acquireTimeoutMillis, expiryTimeMillis, UUID.randomUUID());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Detailed constructor.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey</span></span><br><span class="line"><span class="comment">     *            lock key (ex. account:1, ...)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquireTimeoutMillis</span></span><br><span class="line"><span class="comment">     *            acquire timeout in miliseconds (default: 10000 msecs)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expiryTimeMillis</span></span><br><span class="line"><span class="comment">     *            lock expiration in miliseconds (default: 60000 msecs)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uuid</span></span><br><span class="line"><span class="comment">     *            unique identification of this lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(RedisClient jedis, String lockKey, <span class="keyword">int</span> acquireTimeoutMillis, <span class="keyword">int</span> expiryTimeMillis, UUID uuid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="keyword">this</span>.lockKeyPath = lockKey;</span><br><span class="line">        <span class="keyword">this</span>.acquiryTimeoutInMillis = acquireTimeoutMillis;</span><br><span class="line">        <span class="keyword">this</span>.lockExpiryInMillis = expiryTimeMillis+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.lockUUID = uuid;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> lock uuid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UUID <span class="title">getLockUUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lockUUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> lock key path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLockKeyPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lockKeyPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquire lock.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if lock is acquired, false acquire timeouted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     *             in case of thread interruption</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> acquire(jedis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquire lock.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if lock is acquired, false acquire timeouted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     *             in case of thread interruption</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">(RedisClient jedis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> timeout = acquiryTimeoutInMillis;</span><br><span class="line">        <span class="keyword">while</span> (timeout &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Lock newLock = asLock(System.currentTimeMillis() + lockExpiryInMillis);</span><br><span class="line">            <span class="keyword">if</span> (jedis.setIfNotExist(lockKeyPath, newLock.toString())) &#123;</span><br><span class="line">                <span class="keyword">this</span>.lock = newLock;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String currentValueStr = jedis.getKeyString(lockKeyPath);</span><br><span class="line">            <span class="keyword">final</span> Lock currentLock = Lock.fromString(currentValueStr);</span><br><span class="line">            <span class="keyword">if</span> (currentLock.isExpiredOrMine(lockUUID)) &#123;</span><br><span class="line">                String oldValueStr = jedis.getKeyStringAndSet(lockKeyPath, newLock.toString());</span><br><span class="line">                <span class="keyword">if</span> (oldValueStr != <span class="keyword">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.lock = newLock;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            timeout -= DEFAULT_ACQUIRY_RESOLUTION_MILLIS;</span><br><span class="line">            Thread.sleep(DEFAULT_ACQUIRY_RESOLUTION_MILLIS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Renew lock.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if lock is acquired, false otherwise</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     *             in case of thread interruption</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Lock lock = Lock.fromString(jedis.getKeyString(lockKeyPath));</span><br><span class="line">        <span class="keyword">if</span> (!lock.isExpiredOrMine(lockUUID)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> acquire(jedis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquired lock release.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        release(jedis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquired lock release.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(RedisClient jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isLocked()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"----------Release lock------------"</span>);</span><br><span class="line">            jedis.delKeyString(lockKeyPath);</span><br><span class="line">            <span class="keyword">this</span>.lock = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Check if owns the lock</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  true if lock owned</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lock != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the expiry time of this lock</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the expiry time in millis (or null if not locked)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getLockExpiryTimeInMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lock.getExpiryTime();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Lock <span class="title">asLock</span><span class="params">(<span class="keyword">long</span> expires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Lock(lockUUID, expires);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis CRUD命令</title>
      <link href="/2021/07/18/redis-crud/"/>
      <url>/2021/07/18/redis-crud/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Redis是一个key-value存储系统，存储的数据都是key-value格式的，key固定是String类型，value类型可以是：</p><ol><li>String</li><li>Hash：和HashMap一样，由key-value组成</li><li>List：列表，有序的，按插入顺序排序，可以指定从头部插入还是尾部插入，可以含重复值</li><li>Set：集合，无序的，不含重复值（插入重复值不会成功也不会报错）</li><li>ZSet：有序集合，比Set多一个排序用的score字段，有序的，不含重复值，score值可以重复</li></ol><h1 id="CRUD命令"><a href="#CRUD命令" class="headerlink" title="CRUD命令"></a>CRUD命令</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> cys ccc -- 增</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get cys -- 查</span><br><span class="line"><span class="string">"ccc"</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> cys yyy -- 改</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; del cys -- 删</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><code>del</code>命令就是删掉整个key-value，无论value是什么格式。所以下面的Hash、List等整个删除也是用<code>del</code>。</p><p>要查看新增、删除结果，可以用如下方法查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys * -- 查看所有key，可以看到新增的key，看不到已删除的key</span><br><span class="line">1) <span class="string">"cys"</span></span><br></pre></td></tr></table></figure><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset cyshash name cys age 22 -- 增，新增Map并添加元素，cyshash就是Map名字</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hset cyshash age 23 -- 改单个元素</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hmset cyshash city shenzhen -- 改，给Map添加元素</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hdel cyshash age -- 删Map中单个元素</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; del cyshash -- 删整个Map</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall cyshash -- 查整个Map</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">2) <span class="string">"cys"</span></span><br><span class="line">3) <span class="string">"age"</span></span><br><span class="line">4) <span class="string">"22"</span></span><br><span class="line">127.0.0.1:6379&gt; hget cyshash name -- 查单个元素</span><br><span class="line"><span class="string">"cys"</span></span><br><span class="line">127.0.0.1:6379&gt; hmget cyshash name age -- 同时查多个元素</span><br><span class="line">1) <span class="string">"cys"</span></span><br><span class="line">2) <span class="string">"22"</span></span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush cyslist a -- 增，新增List并添加一个元素</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; llen cyslist -- 查List长度</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange cyslist 0 2 -- 查，限定List下标范围查包含元素</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; lpush cyslist b c d f -- 改，给List添加元素</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; lset cyslist 0 e -- 改，改某个下标的值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange cyslist 0 10 -- 可以看到0位<span class="string">"f"</span>改成了<span class="string">"e"</span></span><br><span class="line">1) <span class="string">"e"</span></span><br><span class="line">2) <span class="string">"d"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br><span class="line">4) <span class="string">"b"</span></span><br><span class="line">5) <span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; lpop cyslist -- 删一个元素，返回被删的元素值</span><br><span class="line"><span class="string">"e"</span></span><br><span class="line">127.0.0.1:6379&gt; del cyslist -- 删整个List</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：List的添加、删除元素可以在头尾两端添加，上面的<code>lpush</code>是在头部添加，<code>lpop</code>是在头部删除。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd cysset abc 123 -- 增，新增Set并添加元素</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; smembers cysset -- 查所有元素</span><br><span class="line">1) <span class="string">"123"</span></span><br><span class="line">2) <span class="string">"abc"</span></span><br><span class="line">127.0.0.1:6379&gt; sadd cysset dfh 098 -09 -- 改，给Set添加元素</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers cysset -- 可以看到元素无序</span><br><span class="line">1) <span class="string">"dfh"</span></span><br><span class="line">2) <span class="string">"098"</span></span><br><span class="line">3) <span class="string">"123"</span></span><br><span class="line">4) <span class="string">"abc"</span></span><br><span class="line">5) <span class="string">"-09"</span></span><br><span class="line">127.0.0.1:6379&gt; spop cysset -- 删除尾部一个元素</span><br><span class="line"><span class="string">"-09"</span></span><br><span class="line">127.0.0.1:6379&gt; srem cysset 098 -- 删除指定元素</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; del cysset -- 删整个Set</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>注意：Set因为无序，所以不能指定下标或下标范围查找元素，也不能指定下标修改元素。另外，Set还有求多个Set之间交集、差集、并集的命令。</p><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd cyszet 1 a 2 b 3 c -- 增，新增ZSet并添加元素</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange cyszet 0 10 -- 查，下标在0~10的元素</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br><span class="line">127.0.0.1:6379&gt; zrange cyszet 0 10 WITHSCORES -- 查，下标在0~10的元素，结果带分数</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"1"</span></span><br><span class="line">3) <span class="string">"b"</span></span><br><span class="line">4) <span class="string">"2"</span></span><br><span class="line">5) <span class="string">"c"</span></span><br><span class="line">6) <span class="string">"3"</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore cyszet 2 3 -- 查，分数在2~3的元素，这个方法也可以带 WITHSCORES</span><br><span class="line">1) <span class="string">"b"</span></span><br><span class="line">2) <span class="string">"c"</span></span><br><span class="line">127.0.0.1:6379&gt; zscore cyszet c -- 查，某个元素的分数</span><br><span class="line"><span class="string">"3"</span></span><br><span class="line">127.0.0.1:6379&gt; zadd cyszet 4 d 5 f -- 改，给ZSet添加元素</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zrem cyszet a -- 删，指定元素</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange cyszet 0 10 -- 删指定元素的结果</span><br><span class="line">1) <span class="string">"b"</span></span><br><span class="line">2) <span class="string">"c"</span></span><br><span class="line">3) <span class="string">"d"</span></span><br><span class="line">4) <span class="string">"f"</span></span><br><span class="line">127.0.0.1:6379&gt; zremrangebyrank cyszet 0 1 -- 删，按下标范围删除元素</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange cyszet 0 10 -- 按下标范围删除元素的结果</span><br><span class="line">1) <span class="string">"d"</span></span><br><span class="line">2) <span class="string">"f"</span></span><br><span class="line">127.0.0.1:6379&gt; del cyszet -- 删整个ZSet</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>注意：ZSet有根据下标区间、分数区间、字典区间查找、删除元素的方法，还有求多个ZSet之间交集、并集的命令。</p><h1 id="操作Key的命令"><a href="#操作Key的命令" class="headerlink" title="操作Key的命令"></a>操作Key的命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys * -- 查看所有key</span><br><span class="line">1) <span class="string">"cysset"</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> cysset -- 查看key对应value类型</span><br><span class="line"><span class="built_in">set</span></span><br><span class="line">127.0.0.1:6379&gt; expire cysset 2 -- 设置key在2秒后过期</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>其余还有很多，没列出来。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池种类</title>
      <link href="/2021/07/18/java-thread-pool/"/>
      <url>/2021/07/18/java-thread-pool/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>线程池的基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多未死亡的线程，池中线程执行调度由池管理器来处理。当有线程任务时（线程任务保存在队列里），从池中取一个线程，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。</p><p>Java<code>Executors</code>类中提供了6种线程池：</p><ol><li>newFixedThreadPool</li><li>newCachedThreadPool</li><li>newSingleThreadExecutor</li><li>newScheduledThreadPool</li><li>newSingleThreadScheduledExecutor</li><li>newWorkStealingPool</li></ol><p>其实这6种线程池都是对线程池类<code>ThreadPoolExecutor</code>的封装，以<code>Executors.newFixedThreadPool()</code>方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面先介绍线程池类<code>ThreadPoolExecutor</code>，接着按顺序介绍每种线程池的特点，其中第6个很少使用，所以忽略不介绍。</p><h1 id="线程池类ThreadPoolExecutor"><a href="#线程池类ThreadPoolExecutor" class="headerlink" title="线程池类ThreadPoolExecutor"></a>线程池类ThreadPoolExecutor</h1><p>ThreadPoolExecutor 有多个重载构造函数，下面是它参数最全的一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">  BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">  ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">  RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"><span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line"><span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line"><span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line"><span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line"><span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line"><span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面介绍每个参数的含义。</p><h2 id="核心线程数corePoolSize"><a href="#核心线程数corePoolSize" class="headerlink" title="核心线程数corePoolSize"></a>核心线程数corePoolSize</h2><p>指核心线程的数量。</p><p>“核心线程”、“非核心线程”是一个虚拟的概念，并没有哪些线程被标记为“核心”或“非核心”，这个“核心线程数量”仅仅指线程池中会永远保持几个线程活着不被销毁，即使线程池并没有任务要做。</p><h2 id="最大线程数maximumPoolSize"><a href="#最大线程数maximumPoolSize" class="headerlink" title="最大线程数maximumPoolSize"></a>最大线程数maximumPoolSize</h2><p>指线程池允许创建的最大线程数。</p><p>如果任务队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。所以只有任务队列满了的时候，这个参数才有意义。因此当你使用了无界任务队列的时候，这个参数就没有效果了。</p><h2 id="keepAliveTime和TimeUnit"><a href="#keepAliveTime和TimeUnit" class="headerlink" title="keepAliveTime和TimeUnit"></a>keepAliveTime和TimeUnit</h2><p>指线程活动保持时间，即当线程池的线程空闲后，保持存活的时间。</p><p>所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率，不然线程刚执行完一个任务，还没来得及处理下一个任务，线程就被终止，而需要线程的时候又再次创建，刚创建完不久执行任务后，没多少时间又终止，会导致资源浪费。</p><p>注意：这里指的是核心线程池以外的线程。可以设置 allowCoreThreadTimeout = true ，这样就会让核心线程池中的线程也有存活时间的控制。</p><h2 id="任务队列workQueue"><a href="#任务队列workQueue" class="headerlink" title="任务队列workQueue"></a>任务队列workQueue</h2><p>用来保存“等待被执行的”任务的<strong>阻塞队列</strong>。即当线程池中无可用线程时，新的任务会被放到此队列中等待被执行。</p><blockquote><p>阻塞队列的含义是，当一个线程从队列中取元素时，队列为空，会要求该线程等待直到队列中有元素可取；当一个线程往队列中添加元素时，队列已满，会要求该线程等待直到队列有位置。所以叫做“阻塞”。非阻塞队列就不会要求线程等待，直接返回操作成功或失败。在 Java 中，阻塞队列就是实现了<code>BlockingQueue</code>接口的类，非阻塞队列就没实现该接口，例如 LinkedList 类。</p></blockquote><p>一般来说可以选择如下阻塞队列：</p><ol><li>ArrayBlockingQueue：基于数组的有界阻塞队列</li><li>LinkedBlockingQueue：基于链表的阻塞队列</li><li>SynchronousQueue：一个不存储元素的阻塞队列</li><li>PriorityBlockingQueue：一个具有优先级的阻塞队列</li></ol><p>注意：设置阻塞队列时应该指定队列长度，特别是<code>LinkedBlockingQueue</code>，它默认的长度是<code>Integer.MAX_VALUE</code>，会导致队列太长，进而导致OOM。</p><blockquote><p>Integer.MAX_VALUE = 2^31 - 1 = 2147483647 。 Integer.MIN_VALUE = -2^31 = -2147483648</p></blockquote><h2 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h2><p>指创建线程的工厂：可以通过线程工厂给每个创建出来的线程设置更加有意义的名字。<br>默认：<code>DefaultThreadFactory</code></p><h2 id="线程饱和策略RejectedExecutionHandler"><a href="#线程饱和策略RejectedExecutionHandler" class="headerlink" title="线程饱和策略RejectedExecutionHandler"></a>线程饱和策略RejectedExecutionHandler</h2><p>指拒绝执行任务的处理，可以理解为饱和策略。当任务队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。<br>默认：<code>AbortPolicy</code></p><ol><li>AbortPolicy：直接抛出异常 RejectedExecutionException</li><li>CallerRunsPolicy: 由调用者所在的线程来运行任务。一般是由 main 线程来执行，会导致 main 线程阻塞</li><li>DiscardOldestPolicy：丢弃任务队列里最近的一个任务，并执行当前任务</li><li>DiscardPolicy：不处理，直接丢掉</li></ol><blockquote><p>参考资料：<a href="https://www.jianshu.com/p/9fec2424de54" target="_blank" rel="noopener">https://www.jianshu.com/p/9fec2424de54</a></p></blockquote><h2 id="ThreadPoolExecutor参数总结"><a href="#ThreadPoolExecutor参数总结" class="headerlink" title="ThreadPoolExecutor参数总结"></a>ThreadPoolExecutor参数总结</h2><p>线程池中，固定有<code>corePoolSize</code>数量的存活线程，当它们空闲时，需要被执行的任务直接分配给这些线程执行。当这些线程都不可用时（即繁忙状态），新的任务就加入<code>workQueue</code>任务队列，等待被分配给空闲线程执行。当任务队列满了，线程池开始创建新线程来接收任务，直到线程数量达到<code>maximumPoolSize</code>就不再创建。若任务队列满，且线程数满，则新任务既不能添加到队列中，也不能被线程接收，会根据设置的饱和策略<code>RejectedExecutionHandler</code>处理。</p><h1 id="线程池种类特点"><a href="#线程池种类特点" class="headerlink" title="线程池种类特点"></a>线程池种类特点</h1><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一直拥有固定数量的存活线程的线程池（最大线程数=核心线程数）。</p><p>任务阻塞队列是<code>LinkedBlockingQueue</code>（链表阻塞队列），队列长度默认为<code>Integer.MAX_VALUE</code>。</p><p>若任务队列满了则使用默认的饱和策略<code>AbortPolicy</code>，直接抛出异常 RejectedExecutionException。</p><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心线程数=0，最大线程数=Integer.MAX_VALUE，即它的线程数无限制。由于无核心线程，每个线程在空闲 60s 后被销毁。</p><p>任务阻塞队列是<code>SynchronousQueue</code>，队列长度默认为<code>Integer.MAX_VALUE</code>。</p><p><code>SynchronousQueue</code>是一个不存储元素的队列，它只负责传递任务给池中线程，且添加任务时必须等待上一次任务已传递出去。可以理解为有一个任务进来时它就“满了”，需要线程池新建线程来接收队列中的任务。</p><p>这个线程池因为线程数无限制，所以一般用来执行任务较小的线程，执行完 60s 后即可销毁。若任务数量多且每个任务执行时间较长，则会不断创建线程，占用内存。</p><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一直有且仅有一个线程的线程池（最大线程数=核心线程数=1），线程空闲后即被销毁。</p><p>任务阻塞队列是<code>LinkedBlockingQueue</code>（链表阻塞队列），队列长度默认为<code>Integer.MAX_VALUE</code>。</p><p>若任务队列满了则使用默认的饱和策略<code>AbortPolicy</code>，直接抛出异常 RejectedExecutionException。</p><p>这个线程池因为只有一个线程，所以可以保证队列中的任务会被<strong>顺序执行</strong>（队列本身是先进先出的顺序），若这个线程异常结束，会有另一个取代它。</p><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="comment">// 纳秒</span></span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个线程池的创建被封装了，其实等同于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br></pre></td></tr></table></figure><p>核心线程数=corePoolSize，最大线程数=Integer.MAX_VALUE，即它的线程数无限制。线程空闲后即被销毁。</p><p>任务阻塞队列是<code>DelayedWorkQueue</code>（优先级队列），队列长度默认为<code>Integer.MAX_VALUE</code>。</p><p>优先级队列的意思是，它会对插入的数据进行优先级排序，保证优先级越高的数据首先被获取，与数据的插入顺序无关。这里的<code>DelayedWorkQueue</code>就是按照时间排序。</p><p><code>DelayedWorkQueue</code>存储的任务元素只能是<code>RunnableScheduledFutures</code>，而上面提到的 LinkedBlockingQueue、SynchronousQueue 的任务只需要是<code>Runnable</code>。</p><p>这个线程池提供了<code>schedule</code>和<code>scheduleAtFixedRate</code>方法，可以设置任务的延时执行时间和周期性执行时间，用于需要延迟或周期性执行任务的场景。</p><h2 id="newSingleThreadScheduledExecutor"><a href="#newSingleThreadScheduledExecutor" class="headerlink" title="newSingleThreadScheduledExecutor"></a>newSingleThreadScheduledExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从创建这个线程池的方法中可以看出，它结合了<code>newSingleThreadExecutor</code>和<code>newScheduledThreadPool</code>的特点，只有单线程，任务按优先级队列中的时间顺序执行。</p><h1 id="线程池中的线程“活着”的原理"><a href="#线程池中的线程“活着”的原理" class="headerlink" title="线程池中的线程“活着”的原理"></a>线程池中的线程“活着”的原理</h1><p>问题：线程池中的线程做完任务后，为什么不会被销毁，而是“活着”等待任务？</p><p>ThreadPoolExecutor 借助其成员 Worker worker 间接执行<strong>任务线程</strong> thread.run()。Worker 是 ThreadPoolExecutor 的内部类，其中一个属性是<code>Thread thread</code>。同时，worker 本身实现了<code>Runnable</code>，它的 run 方法就是负责执行成员<code>thread.run()</code>，或着等待任务。</p><p>当 worker 中的 thread=null 时，会去任务队列中取任务，取到任务则执行任务。取不到任务的情况分两种，一种是活动线程数 &lt; 核心线程数时，worker 会进入阻塞状态，直到能取到任务为止；另一种是活动线程数 &gt; 核心线程数时，worker 会在限定时间内等待任务，若没等到任务，则 worker 线程销毁。</p><p>因此，线程池可以保证池中一定有“核心线程数”的线程存在，超过“核心线程数”的线程没有任务就会被销毁。</p><p>参考资料： <a href="https://blog.csdn.net/anhenzhufeng/article/details/88870374" target="_blank" rel="noopener">https://blog.csdn.net/anhenzhufeng/article/details/88870374</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存问题</title>
      <link href="/2021/07/18/redis-cache/"/>
      <url>/2021/07/18/redis-cache/</url>
      
        <content type="html"><![CDATA[<h1 id="正常缓存流程"><a href="#正常缓存流程" class="headerlink" title="正常缓存流程"></a>正常缓存流程</h1><p>用户访问网站，网站服务器请求Redis查询数据，Redis中有数据就直接返回，若Redis中没有数据，服务器再请求MySQL查询，MySQL查询到数据写入Redis，并返回。</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>网站访问量大，Redis中大量的key在同一时间全部失效，导致这些key对应的用户请求全部集中到MySQL，导致MySQL挂掉。</p><p><strong>解决方法：</strong>key的失效时间随机设置，使得这些key不会在同一时间失效；Redis集群部署，热点key平均分布在不同节点；定时任务刷新缓存，在缓存失效前重置key的失效时间。</p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>有非法请求访问网站，请求的数据在Redis和MySQL中都不可能存在，因此该请求穿过Redis再进入MySQL，非法请求量过大，导致MySQL挂掉。</p><p><strong>解决方法：</strong>提前校验请求参数，使非法请求不会到Redis；MySQL中未查询到数据也写入Redis，下次请求时Redis中有这个key可直接返回；使用布隆过滤器在Redis之前过滤请求。</p><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>网站访问量大且持续时间长，Redis中某一个热点key过了生效时间，失效后针对这个热点key的请求全部集中到MySQL，导致MySQL挂掉。</p><p><strong>解决方法：</strong>使用分布式锁，使得同一时间只有一个请求线程访问MySQL，其他未抢到锁的线程睡几毫秒后再去访问Redis，此时Redis中就有数据了。</p><h1 id="Redis和MySQL缓存一致性问题"><a href="#Redis和MySQL缓存一致性问题" class="headerlink" title="Redis和MySQL缓存一致性问题"></a>Redis和MySQL缓存一致性问题</h1><p>数据更新时，如何保证MySQL和Redis数据一起更新？</p><p>首先要设置缓存过期时间；<br>其次，在更新MySQL时，若采用“先删redis再更新mysql”，应使用 延时双删 方法，即更新Mysql后sleep几毫秒再删除redis；还可以采用“先更新Mysql，再删除redis”</p><p>Redis删除失败怎么办？<br>首先redis一定要有过期时间，使其能自动更新，其次可以用kafka或定时任务刷新缓存</p><p>参考博客； <a href="https://www.cnblogs.com/liuqingzheng/p/11080680.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuqingzheng/p/11080680.html</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RestTemplate负载均衡原理</title>
      <link href="/2021/02/05/resttemplate-loadbalance/"/>
      <url>/2021/02/05/resttemplate-loadbalance/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当我们使用 RestTemplate 调用服务时，会经过以下几个过程：</p><ol><li>RestTemplate 发送的请求被 LoadBalancerInterceptor 拦截，LoadBalancerInterceptor 调用 LoadBalancerClient.execute() 方法处理请求。LoadBalancerClient 默认使用的实现类是 RibbonLoadBalancerClient</li><li>在 RibbonLoadBalancerClient.execute() 方法中，用 serviceId（被调方的服务名）获取一个 ILoadBalancer 对象，再调用 ILoadBalancer.chooseServer() 方法</li><li>在 ILoadBalancer.chooseServer() 方法中，调用 IRule.choose() 方法，从被调服务的多个节点中选出一个节点</li><li>选出服务节点后，把原本是服务名的请求 URI 换成这个节点的IP+端口，发送请求，得到响应</li></ol><p>下面先讲第一个重点： ILoadBalancer 和 IRule 是怎么挑选被调服务的某个节点的？</p><p>PS：文中的源码版本是 SpringCloud Finchley.RELEASE, SpringBoot 2.0.9.RELEASE</p><h1 id="挑选服务节点"><a href="#挑选服务节点" class="headerlink" title="挑选服务节点"></a>挑选服务节点</h1><p>这部分的逻辑有一丢丢复杂，我只选有关联的讲，能省则省，注意跟紧不要掉队咯~</p><h2 id="ILoadBalancer"><a href="#ILoadBalancer" class="headerlink" title="ILoadBalancer"></a>ILoadBalancer</h2><p>ILoadBalancer 的实现类的继承关系（从父类到子类）：ILoadBalancer -&gt; AbstractLoadBalancer -&gt; BaseLoadBalancer -&gt; DynamicServerListLoadBalancer -&gt; ZoneAwareLoadBalancer</p><p><code>ILoadBalancer</code>定义了挑选服务节点的基本方法：<code>chooseServer</code>。<code>AbstractLoadBalancer</code>只是给 ILoadBalancer 接口扩展了几个方法。</p><p><code>BaseLoadBalancer</code>定义了成员变量<code>IRule</code>，IRule 的默认值为<code>RoundRobinRule</code>，就是轮询算法。它还实现了 chooseServer 方法，在方法中，直接调用 IRule.choose() 方法挑选服务节点。</p><p><code>DynamicServerListLoadBalancer</code>未重写父类 BaseLoadBalancer 的 chooseServer 方法，但它实现了服务实例清单在运行期的动态更新能力（这个后面讲）。</p><p><code>ZoneAwareLoadBalancer</code>重写了 chooseServer 方法，它比父类方法多了一个判断：被调服务的节点存在于一个 Zone 内还是分布在多个 Zone？</p><p>如果是分布在多个 Zone，ZoneAwareLoadBalancer 首先使用<code>ZoneAvoidanceRule</code>计算每个 Zone 的可用性，再从可用的 Zone 中<strong>随机选一个</strong>。选出一个 Zone 后，再用 IRule 从这个 Zone 内的节点列表内挑选一个节点。</p><p>如果就只存在于一个 Zone 内，那就不需要选择 Zone 了，直接用 IRule 从这个 Zone 内的节点列表内挑选一个节点。</p><p><strong>因此，无论是哪种情况，最后都是调用成员 IRule 的 choose 方法挑选服务节点</strong>。</p><p>在配置类<code>RibbonClientConfiguration</code>中，配置了 ILoadBalancer 实现类是<code>ZoneAwareLoadBalancer</code>，IRule 实现类是<code>ZoneAvoidanceRule</code>。所以在默认配置下，最后负责挑选服务节点的方法是<code>ZoneAvoidanceRule.choose()</code>。</p><hr><p>不了解什么是 Zone？这里简单介绍下：</p><p>Zone 和 Region 是两个区域的概念。一个 Region 下可以包含多个 Zone，一个 Zone 只对应一个 Region。这两个属性的意义在于可以指定客户端的某个节点位于某个 Zone 内，这个客户端调用其他服务时，优先在自己的 Zone 内选被调服务的节点，如果没有再去别的 Zone 选服务节点，减少了远程调用的次数。</p><p>对于这两个属性的概念，我也参照其他博客的理解：Region 代表地区，如北京、新加坡，Zone 代表机房，如北京下有两个机房：bj-zone1 和 bj-zone2。</p><p>我们没有使用到这两个属性时，每个节点的注册中心地址配置都是<code>eureka.client.serviceUrl.defalutZone = xxx</code>。在这个配置下，所有节点所在的 Region =”us-east-1”，Zone = “defalutZone”，这两个默认值在<code>EurekaClientConfigBean</code>中指定。</p><h2 id="IRule"><a href="#IRule" class="headerlink" title="IRule"></a>IRule</h2><p>因为默认使用的是 ZoneAvoidanceRule，所以这里只介绍它和它的父类们 O(∩_∩)O</p><p>继承关系（从父类到子类）：IRule -&gt; AbstractLoadBalancerRule -&gt; ClientConfigEnabledRoundRobinRule -&gt; PredicateBasedRule -&gt; ZoneAvoidanceRule</p><p><code>IRule</code>接口和<code>AbstractLoadBalancerRule</code>抽象类定义了挑选服务节点的基本方法：choose，以及成员<code>ILoadBalancer lb</code>，ILoadBalancer 在 IRule 中的作用就是“获取服务节点列表”。【结合上面介绍的 BaseLoadBalancer，可以看出 ILoadBalancer 和 IRule 互相依赖</p><p><code>ClientConfigEnabledRoundRobinRule</code>实现了 choose 方法：调用 RoundRobinRule.choose() 挑选服务节点。这个类的作用是为其子类的 choose 方法提供一个备选方案。</p><p><code>PredicateBasedRule</code>是个抽象类，定义了获取<code>AbstractServerPredicate</code>对象的方法，交由子类实现。它的 choose 方法就是调用 AbstractServerPredicate 对象的 chooseRoundRobinAfterFiltering 方法挑选服务节点并返回。</p><hr><p>下面先介绍一下 AbstractServerPredicate.chooseRoundRobinAfterFiltering() 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title">chooseRoundRobinAfterFiltering</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">    List&lt;Server&gt; eligible = getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">    <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.absent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(eligible.get(incrementAndGetModulo(eligible.size())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，chooseRoundRobinAfterFiltering 方法把形参 List<Server> servers（被调服务的节点列表）交给<code>getEligibleServers</code>方法进行过滤，得到过滤后的节点列表。如果返回的列表为空，则用 Optional.absent() 表示服务不存在，反之则以<strong>线性轮询</strong> 的方式从过滤后的节点列表中获取一个实例并返回。</p><p>getEligibleServers 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getEligibleServers</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loadBalancerKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ImmutableList.copyOf(Iterables.filter(servers, <span class="keyword">this</span>.getServerOnlyPredicate()));            </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        List&lt;Server&gt; results = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">for</span> (Server server: servers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.apply(<span class="keyword">new</span> PredicateKey(loadBalancerKey, server))) &#123;</span><br><span class="line">                results.add(server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，进入 else 分支，遍历 servers，对每个 server 执行 apply 方法，<strong>apply 方法就是服务过滤的逻辑</strong>，apply 方法返回true，就将此 server 加入要返回的列表，false就不加入。</p><blockquote><p>什么情况下不进入 else 分支？<br>很少。因为从RibbonLoadBalancerClient.execute() 方法开始一直传进来的 loadBalancerKey=”default”，所以都会进入 else 分支。</p></blockquote><p>综上，AbstractServerPredicate.chooseRoundRobinAfterFiltering() 是一个模板方法，<strong>定义了处理被调服务节点列表的模板：先过滤列表，再轮询选择。</strong>其中用于过滤服务节点列表的 apply 方法由 AbstractServerPredicate 的子类实现。</p><p>AbstractServerPredicate 有一个重要的子类：<code>CompositePredicate</code>。</p><p>CompositePredicate 成员变量包括一个主过滤条件<code>AbstractServerPredicate delegate</code>和一组次过滤条件<code>List&lt;AbstractServerPredicate&gt; fallbacks</code>。它重写了 getEligibleServers 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getEligibleServers</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">    List&lt;Server&gt; result = <span class="keyword">super</span>.getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">    Iterator&lt;AbstractServerPredicate&gt; i = fallbacks.iterator();</span><br><span class="line">    <span class="keyword">while</span> (!(result.size() &gt;= minimalFilteredServers &amp;&amp; result.size() &gt; (<span class="keyword">int</span>) (servers.size() * minimalFilteredPercentage))</span><br><span class="line">            &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">        AbstractServerPredicate predicate = i.next();</span><br><span class="line">        result = predicate.getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，它的 getEligibleServers 方法先调用了父类 AbstractServerPredicate 的同名方法，父类的这个方法又会调用子类（此处是 CompositePredicate）的 apply 方法。CompositePredicate 的 apply 方法就是使用主过滤条件 ———— delegate.apply()。</p><p>从父类方法返回 List<Server> result 后，对 result 列表长度进行判断，判断条件简单地写就是：”!(result.size() &gt;= 1 &amp;&amp; result.size() &gt; 0)”，即如果 result 列表长度大于1，该条件就不成立，不会进入 while 循环，直接将 result 列表返回。如果这个条件成立，就依次使用次过滤条件 fallbacks 对 servers 进行过滤，直到该条件不成立，或 fallbacks 全部使用过了，就返回最后的过滤结果。</p><hr><p>说回到 PredicateBasedRule，它的子类<code>ZoneAvoidanceRule</code>使用的 AbstractServerPredicate 对象就是 CompositePredicate 类，其中主过滤条件是<code>ZoneAvoidancePredicate</code>，次过滤条件只有<code>AvailabilityPredicate</code>。</p><p><code>ZoneAvoidanceRule</code>未重写父类的 choose 方法，所以它的 choose 方法的调用链为：</p><p>ZoneAvoidanceRule.choose() -&gt; AbstractServerPredicate.chooseRoundRobinAfterFiltering() -&gt; CompositePredicate.getEligibleServers()</p><p>因此，ZoneAvoidanceRule.choose() 逻辑为“先过滤列表，再轮询选择”。过滤节点列表时，先用 ZoneAvoidancePredicate 过滤一遍，如果过滤后的列表个数小于1，才会使用到次过滤条件 AvailabilityPredicate。</p><p>ZoneAvoidancePredicate 和 AvailabilityPredicate 的过滤逻辑，简单地说就是：<br>ZoneAvoidancePredicate 计算了列表内所有节点所在的 Zone 的可用性，只留下了在可用 Zone 内的节点；<br>AvailabilityPredicate 排除了断路器打开（说明服务可能故障）或并发请求数过多的节点。</p><p>因为很少使用次过滤条件，我们可以简单地说：<strong>ZoneAvoidanceRule 先筛选出在可用 Zone 内的被调服务节点列表，再用“线性轮询”的方法从中选出一个。</strong></p><p>至此，默认配置下的挑选服务的逻辑讲完啦~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在默认配置下，负责挑选服务节点的是 ZoneAwareLoadBalancer.chooseServer() 方法。</p><p>ZoneAwareLoadBalancer.chooseServer() 方法先判断：被调服务的节点存在于一个 Zone 内还是分布在多个 Zone？有多个 Zone 就先计算每个 Zone 的可用性，从可用的 Zone 中随机选一个 Zone。如果只有一个 Zone 就不需要选择了。</p><p>确定好 Zone 后，再调用 ZoneAvoidanceRule.choose() 挑选服务节点，此时待挑选的服务列表内的节点都是存在于这个确定好的 Zone 内。</p><p>ZoneAvoidanceRule 的 choose 方法就是调用其成员 CompositePredicate 的 chooseRoundRobinAfterFiltering 方法。在这个方法中，先过滤被调服务的节点列表，再用“线性轮询”的方法从过滤后的列表选出一个节点。</p><p>过滤列表时，先使用的是 ZoneAvoidancePredicate.apply() 方法，它计算了列表内所有节点所在的 Zone 的可用性，只留下了在可用 Zone 内的节点。</p><p>如果 ZoneAvoidancePredicate 过滤后的列表不为空，就用“线性轮询”的方法从这个列表里选出一个节点，结束。【考虑到此时待挑选的列表内的节点都是存在于一个 Zone 内，除非这个 Zone 变得不可用了，不然经过 ZoneAvoidancePredicate 过滤后的列表都是不为空的</p><p>如果 ZoneAvoidancePredicate 过滤后的列表为空，再使用 AvailabilityPredicate.apply()  方法过滤，它排除了断路器打开（说明服务可能故障）或并发请求数过多的节点。最后也是用“线性轮询”的方法从过滤后的列表里选出一个节点，结束。</p><blockquote><p>扩展内容：如果现在需要你自己实现“灰度部署”或“蓝绿部署”，是不是就有思路了？</p></blockquote><p>哎，就是先自定义一个 AbstractServerPredicate 的子类，在这个子类的 apply 方法里编写过滤服务的代码，比如在“灰度发布”阶段，灰度请求只能进入灰度节点，那么在 apply 方法里就要排除掉正常节点，只留下灰度节点。【至于如何识别正常服务还是灰度服务，可以借助<code>eureka.instance.metadata-map</code>属性，在服务的元数据里体现</p><p>然后还需要自定义一个 PredicateBasedRule 的子类，它使用的 AbstractServerPredicate 对象就是刚刚自定义的 AbstractServerPredicate 子类。最后要记得配置 IRule Bean 是自己创建的那个 PredicateBasedRule 子类哦~</p><p>Github上有一个实现蓝绿发布的工程：<a href="https://github.com/jmnarloch/ribbon-discovery-filter-spring-cloud-starter" target="_blank" rel="noopener">https://github.com/jmnarloch/ribbon-discovery-filter-spring-cloud-starter</a> 。作者就是在自定义的 AbstractServerPredicate 子类中，过滤出和调用方 flag 一样的节点，比如调用方是蓝节点，就只过滤出被调方的蓝节点。</p><h1 id="获取服务列表"><a href="#获取服务列表" class="headerlink" title="获取服务列表"></a>获取服务列表</h1><p>上面我们提到，ILoadBalancer 也是 IRule 的成员，它在 IRule 中的作用就是“获取服务节点列表”。那么问题来了，ILoadBalancer 是怎么获取服务节点列表的？</p><p>ILoadBalancer 接口定义了两个方法：<br>(1) <code>List&lt;Server&gt; getReachableServers()</code>————获取正常服务节点<br>(2) <code>List&lt;Server&gt; getAllServers()</code>————获取所有服务节点，包括正常的和停止的节点</p><p>IRule.choose() 方法就是先调用 ILoadBalancer 的这两个方法的其中一个，如 PredicateBasedRule 是调用 ILoadBalancer.getAllServers()，获取被调服务的节点列表，再用特定算法选出一个节点。</p><p>BaseLoadBalancer 实现了这两个方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有服务，包括正常和停止</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; allServerList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Server&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常服务</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; upServerList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Server&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getReachableServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Collections.unmodifiableList(upServerList);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getAllServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Collections.unmodifiableList(allServerList);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>DynamicServerListLoadBalancer 未重写这两个方法，它实现的是对这两个服务列表，allServerList 和 upServerList 的动态更新。</p><p>为了实现服务列表的动态更新，DynamicServerListLoadBalancer 定义了一个成员：<code>ServerList&lt;T&gt; serverListImpl</code>，默认初始化 serverListImpl = <code>DomainExtractingServerList</code>。DomainExtractingServerList 对象里又包含一个成员：<code>ServerList&lt;DiscoveryEnabledServer&gt; list</code>，默认初始化 list = <code>DiscoveryEnabledNIWSServerList</code>。<br>这个“套娃”关系展示如下：</p><img src="/2021/02/05/resttemplate-loadbalance/taowa.PNG" class="" title="套娃"><p><code>ServerList</code>接口有两个方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServerList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Server</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getInitialListOfServers</span><span class="params">()</span></span>; <span class="comment">// 获取初始的服务列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getUpdatedListOfServers</span><span class="params">()</span></span>; <span class="comment">// 获取更新后的服务列表</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DynamicServerListLoadBalancer 就是依赖 ServerList 的 getUpdatedListOfServers 方法获取最新的服务列表，调用链为：</p><p>DynamicServerListLoadBalancer.updateListOfServers() -&gt; DomainExtractingServerList.getUpdatedListOfServers() -&gt; DiscoveryEnabledNIWSServerList.getUpdatedListOfServers() -&gt; DiscoveryEnabledNIWSServerList.obtainServersViaDiscovery()</p><p>这个调用链最后一环<code>DiscoveryEnabledNIWSServerList.obtainServersViaDiscovery()</code>调用了<code>DiscoveryClient.getInstancesByVipAddress()</code>方法，这个方法根据 serviceId（被调服务的名字），优先从同个 Region 中找服务节点，找到了就返回服务节点列表，同个 Region 下没有再去别的 Region 中找【<strong>DiscoveryClient 的服务列表的来源就是注册中心</strong></p><p>DiscoveryEnabledNIWSServerList 得到 DiscoveryClient 返回的节点列表后，从该列表选出状态为 UP 的节点，把每个服务节点包装成<code>DiscoveryEnabledServer</code>对象。</p><p>DomainExtractingServerList 得到 DiscoveryEnabledNIWSServerList 返回的节点列表后，再把每个节点包装成<code>DomainExtractingServer</code>对象返回给 DynamicServerListLoadBalancer，其中每个节点的 Zone 属性来源于节点的元数据配置，配置项为<code>eureka.instance.metadata-map.zone</code>。</p><p>上面的调用链中第一个方法<code>DynamicServerListLoadBalancer.updateListOfServers()</code>，就是负责更新 allServerList 和 upServerList 的方法。这个方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateListOfServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       List&lt;T&gt; servers = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">       <span class="keyword">if</span> (serverListImpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">           servers = serverListImpl.getUpdatedListOfServers();<span class="comment">// 调用成员serverListImpl</span></span><br><span class="line">           LOGGER.debug(<span class="string">"List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,</span><br><span class="line">                   getIdentifier(), servers);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (filter != <span class="keyword">null</span>) &#123;</span><br><span class="line">               servers = filter.getFilteredListOfServers(servers);<span class="comment">// 调用成员filter</span></span><br><span class="line">               LOGGER.debug(<span class="string">"Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,</span><br><span class="line">                       getIdentifier(), servers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       updateAllServerList(servers);<span class="comment">// 最终把列表传给另一个方法，由这个方法更新服务列表</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如上，从 serverListImpl.getUpdatedListOfServers() 得到节点列表后，接着使用成员<code>filter</code>对这个列表进行过滤， filter 默认初始化为<code>ZonePreferenceServerListFilter</code>。</p><p>ZonePreferenceServerListFilter 过滤列表时，先调用父类方法。在父类方法中，判断是否启用“区域感知”功能（shouldEnableZoneAffinity），判断的依据是当前区域（Zone）是否健康（有几个指标来评估），如果当前 Zone 健康，就启用“区域感知”功能，过滤出和调用方 Zone 一致的节点并返回。如果当前 Zone 不健康，就不启用“区域感知”，返回的列表是没过滤的、分布在多个 Zone 的被调方节点列表。</p><p>从父类方法返回后，ZonePreferenceServerListFilter 接着判断父类是不是已经做过过滤了（过滤后的列表和过滤前是否一样）。如果已经被过滤了，就直接返回父类的结果。如果没有被过滤，则子类再从列表中过滤出和调用方 Zone 一致的节点，返回。</p><p>总之，经过 ZonePreferenceServerListFilter 的过滤，被调方节点列表中只留下了和调用方在同一个 Zone 内的节点。这就实现了“优先调用同个 Zone 内的节点”。但，前提是被调方在这个 Zone 内有节点，否则结果依然是没过滤的、分布在其他多个 Zone 的被调方节点列表。</p><p>filter 过滤完后，把过滤后的、最新的节点列表传入<code>updateAllServerList</code>方法，这个方法内接着调用<code>DynamicServerListLoadBalancer.setServersList()</code>方法。</p><p>DynamicServerListLoadBalancer.setServersList() 方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServersList</span><span class="params">(List lsrv)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.setServersList(lsrv); <span class="comment">// 调用父类方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据节点所在的 Zone 进行分类</span></span><br><span class="line">       List&lt;T&gt; serverList = (List&lt;T&gt;) lsrv;</span><br><span class="line">       Map&lt;String, List&lt;Server&gt;&gt; serversInZones = <span class="keyword">new</span> HashMap&lt;String, List&lt;Server&gt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (Server server : serverList) &#123;</span><br><span class="line">           <span class="comment">// make sure ServerStats is created to avoid creating them on hot</span></span><br><span class="line">           <span class="comment">// path</span></span><br><span class="line">           getLoadBalancerStats().getSingleServerStat(server);</span><br><span class="line">           String zone = server.getZone();</span><br><span class="line">           <span class="keyword">if</span> (zone != <span class="keyword">null</span>) &#123;</span><br><span class="line">               zone = zone.toLowerCase();</span><br><span class="line">               List&lt;Server&gt; servers = serversInZones.get(zone);</span><br><span class="line">               <span class="keyword">if</span> (servers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   servers = <span class="keyword">new</span> ArrayList&lt;Server&gt;();</span><br><span class="line">                   serversInZones.put(zone, servers);</span><br><span class="line">               &#125;</span><br><span class="line">               servers.add(server);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       setServerListForZones(serversInZones); <span class="comment">// 调用子类方法</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法形参<code>List lsrv</code>就是过滤后的、最新的节点列表，这个方法做了3件事：</p><ol><li>调用父类 BaseLoadBalancer 的 setServersList 方法，这个方法将 allServerList 和 upServerList 都更新为 lsrv</li><li>整理过滤后的节点列表，根据节点所在的 Zone 进行分类，分类完后是一个 Map，key 为 Zone 的名字，value 为这个 Zone 下的节点列表</li><li>把分类后的 Map 传给子类方法 ZoneAwareLoadBalancer.setServerListForZones()</li></ol><p><code>ZoneAwareLoadBalancer.setServerListForZones()</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setServerListForZones</span><span class="params">(Map&lt;String, List&lt;Server&gt;&gt; zoneServersMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setServerListForZones(zoneServersMap);</span><br><span class="line">    <span class="keyword">if</span> (balancers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        balancers = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BaseLoadBalancer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Server&gt;&gt; entry: zoneServersMap.entrySet()) &#123;</span><br><span class="line">    String zone = entry.getKey().toLowerCase();</span><br><span class="line">        getLoadBalancer(zone).setServersList(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, BaseLoadBalancer&gt; existingLBEntry: balancers.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!zoneServersMap.keySet().contains(existingLBEntry.getKey())) &#123;</span><br><span class="line">            existingLBEntry.getValue().setServersList(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BaseLoadBalancer <span class="title">getLoadBalancer</span><span class="params">(String zone)</span> </span>&#123;</span><br><span class="line">    zone = zone.toLowerCase();</span><br><span class="line">    BaseLoadBalancer loadBalancer = balancers.get(zone);</span><br><span class="line">    <span class="keyword">if</span> (loadBalancer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// We need to create rule object for load balancer for each zone</span></span><br><span class="line">    IRule rule = cloneRule(<span class="keyword">this</span>.getRule());</span><br><span class="line">        loadBalancer = <span class="keyword">new</span> BaseLoadBalancer(<span class="keyword">this</span>.getName() + <span class="string">"_"</span> + zone, rule, <span class="keyword">this</span>.getLoadBalancerStats());</span><br><span class="line">        BaseLoadBalancer prev = balancers.putIfAbsent(zone, loadBalancer);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loadBalancer = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> loadBalancer;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也做了3件事：</p><ol><li>调用父类 DynamicServerListLoadBalancer 的 setServerListForZones 方法，记录一下参数 Map 里拥有的 Zone</li><li>对每个 Zone 都初始化一个<code>BaseLoadBalancer</code>对象，然后把这个 Zone 内的节点列表赋值给这个 BaseLoadBalancer 的 allServerList 和 upServerList</li><li>检查成员 balancers 内是不是有过期的 Zone 信息，即参数 Map 里已经没有这个 Zone 了但 balancers 里还有，把过期的 Zone 对应的 BaseLoadBalancer 的服务列表置为空</li></ol><p>对每个 Zone 初始化 BaseLoadBalancer 对象时，初始化的这个 BaseLoadBalancer 对象的成员 IRule = ZoneAvoidanceRule（因为是从 ZoneAwareLoadBalancer 的 IRule 克隆过来的），属性 name = 服务名 + “_” + zone名。Zone 和 BaseLoadBalancer 的对应关系保存在成员<code>ConcurrentHashMap&lt;String, BaseLoadBalancer&gt; balancers</code>内。</p><hr><p>服务列表的更新过程说完了，现在我们简单提一下何时更新服务列表？</p><p>DynamicServerListLoadBalancer 还有这样两个成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ServerListUpdater.UpdateAction updateAction = <span class="keyword">new</span> ServerListUpdater.UpdateAction() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        updateListOfServers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> ServerListUpdater serverListUpdater;</span><br></pre></td></tr></table></figure><p>成员<code>serverListUpdater</code>是 PollingServerListUpdater 类，在 RibbonClientConfiguration 中配置的。这是个定时任务，它<strong>周期性（默认30秒）执行</strong><code>ServerListUpdater.UpdateAction.doUpdate()</code>方法。如上，这个 doUpdate 方法就是执行 DynamicServerListLoadBalancer.updateListOfServers() 方法。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>BaseLoadBalancer 定义了保存服务节点列表的成员：allServerList 和 upServerList。</p><p>DynamicServerListLoadBalancer 借助成员 ServerListUpdater，周期性（默认30秒）调用 updateListOfServers 方法更新服务节点列表。</p><p>在 updateListOfServers 方法中，DynamicServerListLoadBalancer 再借助成员 serverListImpl = DomainExtractingServerList 从注册中心获取被调方节点列表，优先获取同个 Region 内的节点列表，每个节点都是 UP 状态，且带有 Zone 信息。</p><p>接着，DynamicServerListLoadBalancer 再调用成员 filter = ZonePreferenceServerListFilter 过滤出和调用方 Zone 一致的被调方节点。若被调方在这个 Zone 内没有节点，则 filter 返回的还是没过滤的、分布在其他多个 Zone 的节点列表。</p><p>最后，过滤完的节点列表更新到 allServerList 和 upServerList。ZoneAwareLoadBalancer 还会根据节点所在的 Zone 对节点进行分类。每个 Zone 对应一个 BaseLoadBalancer 对象（若没有会自动初始化），这个 BaseLoadBalancer 对象保存的节点列表就是仅限于这个 Zone 内的节点，成员 IRule 也是 ZoneAvoidanceRule。</p><hr><p><strong>关于“优先调用同一个 Zone 内的节点”：</strong></p><p>前面说到，调用方会优先调用在同一个 Zone 内的被调方节点，原因就是待挑选的服务节点列表经过 ZonePreferenceServerListFilter 过滤后只剩下了在同一个 Zone 内的节点。调用 ZoneAwareLoadBalancer.chooseServer() 时，因为列表中的节点只存在于一个 Zone，所以使用的 IRule 就是 ZoneAwareLoadBalancer 的成员，待选的服务列表也是 ZoneAwareLoadBalancer 维护的 allServerList，内容是这同一个 Zone 内的被调方节点。</p><p>如果被调方在这个 Zone 内没有节点，只在另一个 Zone 内有节点，则 ZonePreferenceServerListFilter 不会做任何过滤，ZoneAwareLoadBalancer 得到的还是在另一个 Zone 内的节点列表。调用 ZoneAwareLoadBalancer.chooseServer() 时，因为列表中的节点只存在于一个 Zone，所以挑选的逻辑还是和上面一样。</p><p>如果被调方在这个 Zone 内没有节点，在其他多个 Zone 内有节点，则 ZonePreferenceServerListFilter 不会做任何过滤，ZoneAwareLoadBalancer 把每个 Zone 下的节点列表整理出来，保存在每个 Zone 对应的 BaseLoadBalancer 对象中。调用 ZoneAwareLoadBalancer.chooseServer() 时，因为列表中的节点分布在多个 Zone，就先选出一个 Zone，取这个 Zone 对应的 BaseLoadBalancer 对象，再调用这个 BaseLoadBalancer 的 chooseServer 方法选出服务节点。自然而然，方法内使用的 IRule 就是 BaseLoadBalancer 的成员，待选的服务列表也是这个 BaseLoadBalancer 的 allServerList，内容是仅限于这个 Zone 内的节点。</p><p>不管是用谁的 IRule，这个 IRule 都是 ZoneAvoidanceRule，待选的服务列表都是在一个 Zone 内的节点。只要这个 Zone 在这调用过程中保持正常不故障，ZoneAvoidanceRule 就是用“线性轮询”的方式，从这个 Zone 的节点列表内选一个节点，结束。 </p><h1 id="组件的自动配置"><a href="#组件的自动配置" class="headerlink" title="组件的自动配置"></a>组件的自动配置</h1><p>负载均衡中的重点已经说完了，这里是一些旁支末节，可以不用理会~我写下来是因为这部分源码中有一些实现方式蛮新鲜的，所以特地记录一下。</p><p>在“前言”部分已经列出了负载均衡的过程，其中前两点是：</p><ol><li>RestTemplate 发送的请求被 LoadBalancerInterceptor 拦截，LoadBalancerInterceptor 调用 LoadBalancerClient.execute() 方法处理请求。LoadBalancerClient 默认使用的实现类是 RibbonLoadBalancerClient</li><li>在 RibbonLoadBalancerClient.execute() 方法中，用 serviceId（被调方的服务名）获取一个 ILoadBalancer 对象，再调用 ILoadBalancer.chooseServer() 方法</li></ol><p>除了 ILoadBalancer 和 IRule，整个过程用到的组件还有拦截请求的 LoadBalancerInterceptor，具体处理请求的 RibbonLoadBalancerClient，这部分内容就介绍下这几个组件是怎么配置的。</p><h2 id="LoadBalancerInterceptor的配置"><a href="#LoadBalancerInterceptor的配置" class="headerlink" title="LoadBalancerInterceptor的配置"></a>LoadBalancerInterceptor的配置</h2><p>在配置类<code>LoadBalancerAutoConfiguration</code>中，首先扫描被<code>@LoadBalanced</code>修饰的 RestTemplate Bean，然后为每个 RestTemplate Bean 添加拦截器<code>LoadBalancerInterceptor</code>。添加了拦截器后，RestTemplate 发出的每个请求都会被拦截。</p><p>在这个配置类之前还会加载另一个配置类<code>RibbonAutoConfiguration</code>，注入<code>LoadBalancerClient</code>Bean（实现类是<code>RibbonLoadBalancerClient</code>），这个 Bean 成为了 LoadBalancerInterceptor 的成员，最终处理请求的方法就是<code>LoadBalancerClient.execute()</code>方法。</p><p>LoadBalancerInterceptor 配置源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RestTemplate<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnBean</span>(<span class="title">LoadBalancerClient</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">LoadBalancerRetryProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LoadBalancerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SmartInitializingSingleton <span class="title">loadBalancedRestTemplateInitializerDeprecated</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> () -&gt; restTemplateCustomizers.ifAvailable(customizers -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (RestTemplate restTemplate : LoadBalancerAutoConfiguration.<span class="keyword">this</span>.restTemplates) &#123;</span><br><span class="line">                <span class="keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">                    customizer.customize(restTemplate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.springframework.retry.support.RetryTemplate"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> restTemplate -&gt; &#123;</span><br><span class="line">                List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">                        restTemplate.getInterceptors());</span><br><span class="line">                list.add(loadBalancerInterceptor);</span><br><span class="line">                restTemplate.setInterceptors(list); <span class="comment">// restTemplate添加拦截器</span></span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分是我第一次看到<code>@Autowired</code>的这个用法：在 @Autowired 注解上加另一个注解，就会扫描出所有加了这个注解的同类的 Bean 放到 List 内。</p><h2 id="ILoadBalancer的配置"><a href="#ILoadBalancer的配置" class="headerlink" title="ILoadBalancer的配置"></a>ILoadBalancer的配置</h2><p>请求被拦截后，由 RibbonLoadBalancerClient.execute() 方法处理请求，首先根据 serviceId（服务名）取 ILoadBalancer 对象，负责这件事的是 RibbonLoadBalancerClient 的成员<code>SpringClientFactory</code>。</p><p>SpringClientFactory 根据 serviceId 取 IloadBalancer，实际上是根据 serviceId 取 IoC 容器，再从 IoC 容器中取 IloadBalancer Bean。serviceId 和 IoC 容器的关系保存在成员<code>Map&lt;String, AnnotationConfigApplicationContext&gt; contexts</code>中。如果 serviceId 还没有对应的 IoC 容器，就先创建一个以便下次取用。因此，<strong>ILoadBalancer 和 IRule 的初始化不是在系统启动时，而是在第一次调用某个服务的时候</strong>。</p><p>一个分布式应用一般要调用多个服务，按照这个设计，调用方要为每个被调服务创建一个 IoC 容器，这个容器中的 ILoadBalancer、IRule 等都是调用这个服务专用的。这种做法比起用同一个 ILoadBalancer Bean 调所有服务，可以更好的维护每个服务的节点列表，使它们之间互不干扰。</p><p>SpringClientFactory 中创建容器的方法源码（方法参数 name 就是 serviceId）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">.getConfiguration()) &#123;</span><br><span class="line">context.register(configuration);<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">"default."</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">context.register(configuration); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">context.register(PropertyPlaceholderAutoConfiguration<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class"><span class="title">this</span>.<span class="title">defaultConfigType</span>)</span>; <span class="comment">// 3</span></span><br><span class="line">context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line"><span class="keyword">this</span>.propertySourceName,</span><br><span class="line">Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">&#125;</span><br><span class="line">context.setDisplayName(generateDisplayName(name));</span><br><span class="line">context.refresh();</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，创建的容器注册了4个东西：</p><ol><li>Map&lt;String, C&gt; configurations 中 key=serviceId 的 value 的 getConfiguration() 返回值</li><li>Map&lt;String, C&gt; configurations 中 以”default.”开头的 key 对应的 value 的 getConfiguration() 返回值</li><li>PropertyPlaceholderAutoConfiguration.class</li><li>defaultConfigType</li></ol><p>其中，第三个不用关注，第四个 defaultConfigType =<code>RibbonClientConfiguration.class</code>，这个属性是在构造方法<code>SpringClientFactory()</code>中设置。</p><p>接下来研究下 SpringClientFactory 的成员<code>Map&lt;String, C&gt; configurations</code>的内容是什么。</p><p>它的来源在<code>RibbonAutoConfiguration</code>配置类，对，就是注入了 RibbonLoadBalancerClient 的那个类。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringClientFactory <span class="title">springClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，Map&lt;String, C&gt; configurations 的来源是所有<code>RibbonClientSpecification</code>Bean。那么，RibbonClientSpecification Bean 又在哪注册呢？它又包含了什么内容？</p><p>在配置类<code>RibbonEurekaAutoConfiguration</code>中，通过<code>@RibbonClients</code>注解，import 另一个类<code>RibbonClientConfigurationRegistrar</code>。</p><p>RibbonEurekaAutoConfiguration 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="meta">@RibbonClients</span>(defaultConfiguration = EurekaRibbonClientConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RibbonEurekaAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RibbonClients 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="meta">@Import</span>(RibbonClientConfigurationRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">RibbonClients</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">RibbonClient[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] defaultConfiguration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RibbonClientConfigurationRegistrar 继承自<code>ImportBeanDefinitionRegistrar</code>，它是和<code>@Import</code>注解配合的一个类：使用<code>@Import</code>，如果括号中的类是<code>ImportBeanDefinitionRegistrar</code>接口的实现类，则会调用接口方法<code>registerBeanDefinitions</code>，在这个方法里可以注入 Bean。</p><p>在 RibbonClientConfigurationRegistrar 类中，调用了 registerBeanDefinitions 方法后，如果 RibbonClients 的 defaultConfiguration 属性有值，就会进入<code>registerClientConfiguration</code>方法（方法源码如下），在这个方法内创建了 RibbonClientSpecification Bean并注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">Object name, Object configuration)</span> </span>&#123;</span><br><span class="line">BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(RibbonClientSpecification<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">builder.addConstructorArgValue(name); <span class="comment">// "default." + @RibbonClients注解所在类的全限定名</span></span><br><span class="line"></span><br><span class="line">builder.addConstructorArgValue(configuration); <span class="comment">// @RibbonClients的defaultConfiguration属性</span></span><br><span class="line"></span><br><span class="line">registry.registerBeanDefinition(name + <span class="string">".RibbonClientSpecification"</span>,</span><br><span class="line">builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，因为这个 @RibbonClients 注解是标在<code>RibbonEurekaAutoConfiguration</code>类上，结合 RibbonEurekaAutoConfiguration 类的源码，这个 RibbonClientSpecification 对象的 name = “default.org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration”，configuration = EurekaRibbonClientConfiguration.class。</p><p>然后，这个 RibbonClientSpecification 对象被扫描到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>再然后，SpringClientFactory 把这个 List<RibbonClientSpecification> configurations 转为自己的成员<code>Map&lt;String, C&gt; configurations</code>，key = RibbonClientSpecification 对象的 name 属性，value = RibbonClientSpecification 对象，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurations</span><span class="params">(List&lt;C&gt; configurations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (C client : configurations) &#123;</span><br><span class="line"><span class="keyword">this</span>.configurations.put(client.getName(), client);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，SpringClientFactory 创建容器时注册的4个东西分别是：</p><ol><li>Map&lt;String, C&gt; configurations 中 key=serviceId 的 value 的 getConfiguration() 返回值 – 没有这个 key </li><li>Map&lt;String, C&gt; configurations 中 以”default.”开头的 key 对应的 value 的 getConfiguration() 返回值 – RibbonClientSpecification.getConfiguration() 返回值 = EurekaRibbonClientConfiguration.class</li><li>PropertyPlaceholderAutoConfiguration.class</li><li>defaultConfigType – RibbonClientConfiguration.class</li></ol><p>综上，serviceId 对应的 IoC 容器中加载了配置类<code>EurekaRibbonClientConfiguration</code>和<code>RibbonClientConfiguration</code>。其中，RibbonClientConfiguration 注入了 ILoadBalancer = ZoneAwareLoadBalancer、IRule = ZoneAvoidanceRule。</p><hr><p>补充介绍一下 ZoneAwareLoadBalancer 的初始化过程。</p><p>配置 ZoneAwareLoadBalancer 的源码（在 RibbonClientConfiguration 类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer<span class="class">.<span class="keyword">class</span>, <span class="title">name</span>)) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer<span class="class">.<span class="keyword">class</span>, <span class="title">config</span>, <span class="title">name</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">serverListFilter, serverListUpdater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZoneAwareLoadBalancer 初始化时，先调用父类 DynamicServerListLoadBalancer 初始化， DynamicServerListLoadBalancer 再调用父类 BaseLoadBalancer 初始化。当前 BaseLoadBalancer 的 name = serviceId。</p><p>DynamicServerListLoadBalancer 从父类 BaseLoadBalancer 初始化返回后，再调用 restOfInit 方法，这个方法又会调用到 updateListOfServers 方法。对，这个就是 DynamicServerListLoadBalancer 更新服务列表的方法。所以，ZoneAwareLoadBalancer 初始化时，也把它的服务列表初始化好了，它的成员<code>ConcurrentHashMap&lt;String, BaseLoadBalancer&gt; balancers</code>———— Zone 和 BaseLoadBalancer 的对应关系也初始化好了。</p><p>在没有配置多个 Zone 的一般项目中，如果你在这个初始化过程里调试 BaseLoadBalancer 的构造方法，你就会发现 BaseLoadBalancer 的构造方法被调用了两次，第一次调用是因为 ZoneAwareLoadBalancer 初始化要调用父类构造方法，name 属性为 serviceId；第二次调用是因为 ZoneAwareLoadBalancer 要创建 defaultZone 对应的 BaseLoadBalancer 对象，name 属性为 serviceId + “_defaultzone”。</p><h2 id="配置类的加载顺序"><a href="#配置类的加载顺序" class="headerlink" title="配置类的加载顺序"></a>配置类的加载顺序</h2><p>系统启动时，根据<code>spring.factories</code>文件加载了配置类<code>RibbonAutoConfiguration</code>，其中注入了 RibbonLoadBalancerClient 。</p><p>RibbonAutoConfiguration 注入了 RibbonLoadBalancerClient Bean 后，加载<code>LoadBalancerAutoConfiguration</code>，这个类为 RestTemplate 设置了 LoadBalancerInterceptor。</p><p>RibbonAutoConfiguration 加载完后，加载<code>RibbonEurekaAutoConfiguration</code>，通过<code>@RibbonClients</code>注解，import RibbonClientConfigurationRegistrar 类，这个类注入了 RibbonClientSpecification ，这个对象中包含配置类<code>EurekaRibbonClientConfiguration</code>的 class 信息。</p><p>系统中第一次使用 RestTemplate 调用服务时，为这个服务初始化一个 IoC 容器，IoC 容器加载的配置类包括<code>EurekaRibbonClientConfiguration</code>和<code>RibbonClientConfiguration</code>。其中，RibbonClientConfiguration 注入了 ILoadBalancer = ZoneAwareLoadBalancer、IRule = ZoneAvoidanceRule。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用SSH方式</title>
      <link href="/2020/12/05/git-ssh/"/>
      <url>/2020/12/05/git-ssh/</url>
      
        <content type="html"><![CDATA[<p>我平时git clone时用的都是HTTPS协议，也设置了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>这行代码的作用是在 .gitconfig 文件中加这些内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[credential]</span><br><span class="line">helper &#x3D; store</span><br></pre></td></tr></table></figure><p>以及生成一个 .git-credentials 文件，里面内容是明文的用户名密码：https://&lt;用户名&gt;:&lt;密码&gt;@github.com</p><p>这个方法在一段时间内有用，设置完后输入一次用户名密码，之后就不用再输了，但最近不行了。</p><p>顺便一提，当我设置完后输入一次用户名密码后，电脑的 凭据管理器 -&gt; Windows凭据 里也保存了一个凭据。</p><p>但现在这些即使重新设置一遍都没有用！！</p><p>无奈，我选择改用<strong>SSH协议</strong>。</p><hr><p>使用SSH协议，首先要生成SSH公私钥并把公钥配置到 GitHub 上。”SSH keys”只有在使用 SSH 协议时才会使用。</p><p>在 GitHub 上添加好公钥后，需要用以下命令测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果提示：”Hi &lt;你的用户名&gt;! You’ve successfully authenticated, but GitHub does not provide shell access.” 说明配置成功。<br>如果提示：”ssh: connect to host github.com port 22: Connection timed out” 说明配置不成功，需要修改端口。</p><p>在 .ssh 目录下新建一个 config 文件，不带后缀。【这个文件的作用待研究…<br>文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User &lt;id_rsa.pub 文件中的邮箱&gt;</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><p>文件保存好后，重新执行 ssh -T <a href="mailto:git@github.com">git@github.com</a> 就OK了。</p><hr><p>接着，要把原本用HTTPS的仓库改为SSH。一般的仓库可以先删除再重新 git clone，记得用SSH方式clone。</p><p>hexo博客改为SSH的步骤：</p><p>1) _config.yml 文件中，git地址改为SSH地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:&lt;用户名&gt;&#x2F;&lt;用户名&gt;.github.io.git</span><br></pre></td></tr></table></figure><p>2) 执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url origin &lt;git SSH地址&gt;</span><br></pre></td></tr></table></figure><p>执行完后检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; git remote -v </span><br><span class="line">origin  git@github.com:&lt;用户名&gt;/&lt;用户名&gt;.github.io.git (fetch)</span><br><span class="line">origin  git@github.com:&lt;用户名&gt;/&lt;用户名&gt;.github.io.git (push)</span><br></pre></td></tr></table></figure><p>修改成功！以后 hexo -d 时用的就是SSH协议了！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud健康检查</title>
      <link href="/2020/11/22/springcloud-health-check/"/>
      <url>/2020/11/22/springcloud-health-check/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍 SpringCloud 服务引入<code>spring-boot-starter-actuator</code>依赖后，进行健康检查的原理，以及何时进行健康检查。目前看有两种情况，第一是客户端自己触发健康检查并将检查结果告诉 Server，第二是 SpringBoot Admin Server 主动调用客户端的 health 端点再更新客户端状态。</p><p>文中源码版本：SpringBoot 2.0.9.RELEASE ; SpringCloud Finchley.RELEASE</p><h1 id="健康检查原理"><a href="#健康检查原理" class="headerlink" title="健康检查原理"></a>健康检查原理</h1><p>得到服务的健康状态的接口是<code>HealthCheckHandler</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HealthCheckHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    InstanceInfo.<span class="function">InstanceStatus <span class="title">getStatus</span><span class="params">(InstanceInfo.InstanceStatus currentStatus)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InstanceStatus</code>是服务健康状态的枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> InstanceStatus &#123;</span><br><span class="line">    UP, <span class="comment">// Ready to receive traffic</span></span><br><span class="line">    DOWN, <span class="comment">// Do not send traffic- healthcheck callback failed</span></span><br><span class="line">    STARTING, <span class="comment">// Just about starting- initializations to be done - do not</span></span><br><span class="line">    <span class="comment">// send traffic</span></span><br><span class="line">    OUT_OF_SERVICE, <span class="comment">// Intentionally shutdown for traffic</span></span><br><span class="line">    UNKNOWN;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HealthCheckHandler 接口有两个实现类，<code>HealthCheckCallbackToHandlerBridge</code>和<code>EurekaHealthCheckHandler</code>。前者是默认配置，它的 getStatus() 只会返回 UP 状态。<code>EurekaHealthCheckHandler</code>是在配置项<code>eureka.client.healthcheck.enabled = true</code>时自动装配的（装配类 EurekaDiscoveryClientConfiguration），如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"eureka.client.healthcheck.enabled"</span>, matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaHealthCheckHandlerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> HealthAggregator healthAggregator = <span class="keyword">new</span> OrderedHealthAggregator();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(HealthCheckHandler<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">EurekaHealthCheckHandler</span> <span class="title">eurekaHealthCheckHandler</span>() </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> EurekaHealthCheckHandler(<span class="keyword">this</span>.healthAggregator);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EurekaHealthCheckHandler 的 getStatus() 是调用其成员<code>CompositeHealthIndicator</code>的<code>getHealth()</code>方法来得到状态的。CompositeHealthIndicator 是<code>HealthIndicator</code>接口的实现类。</p><p><code>HealthIndicator</code>接口只有一个方法<code>health()</code>，这个方法负责健康检查，检查完毕返回<code>Health</code>对象。Health 对象只有两个属性：<code>status</code>代表服务状态，<code>details</code>是更细致的说明。</p><p>不同的 HealthIndicator 实现类检查内容不同，如<code>DataSourceHealthIndicator</code>是检查数据库连接的，<code>DiskSpaceHealthIndicator</code>是检查内存大小的。<code>CompositeHealthIndicator</code>比较特别，它不是专门检查某个模块的，它的作用是收纳了系统中所有实现了<code>HealthIndicator</code>的Bean，它的<code>health()</code>方法就是遍历调用这些<code>HealthIndicator.health()</code>方法，将每个方法返回的 Health 对象的 status 属性，用<code>HealthAggregator</code>类聚合为一个 status 返回。聚合方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Status <span class="title">aggregateStatus</span><span class="params">(List&lt;Status&gt; candidates)</span> </span>&#123; <span class="comment">// 参数就是所有status</span></span><br><span class="line"><span class="comment">// 过滤未定义的状态</span></span><br><span class="line">List&lt;Status&gt; filteredCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Status candidate : candidates) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.statusOrder.contains(candidate.getCode())) &#123;</span><br><span class="line">filteredCandidates.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If no status is given return UNKNOWN</span></span><br><span class="line"><span class="keyword">if</span> (filteredCandidates.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> Status.UNKNOWN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把所有Status 按照以下顺序排序，取第一个</span></span><br><span class="line"><span class="comment">// Status.DOWN, Status.OUT_OF_SERVICE, Status.UP, Status.UNKNOWN</span></span><br><span class="line">filteredCandidates.sort(<span class="keyword">new</span> StatusComparator(<span class="keyword">this</span>.statusOrder));</span><br><span class="line"><span class="keyword">return</span> filteredCandidates.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聚合后的Health对象示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"status"</span>:<span class="string">"UP"</span>,</span><br><span class="line">    <span class="attr">"details"</span>:&#123;</span><br><span class="line">        <span class="attr">"diskSpace"</span>:&#123;</span><br><span class="line">            <span class="attr">"status"</span>:<span class="string">"UP"</span>,</span><br><span class="line">            <span class="attr">"details"</span>:&#123;</span><br><span class="line">                <span class="attr">"total"</span>:<span class="number">297428578304</span>,</span><br><span class="line">                <span class="attr">"free"</span>:<span class="number">243281637376</span>,</span><br><span class="line">                <span class="attr">"threshold"</span>:<span class="number">10485760</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"refreshScope"</span>:&#123;</span><br><span class="line">            <span class="attr">"status"</span>:<span class="string">"UP"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"discoveryComposite"</span>:&#123;</span><br><span class="line">            <span class="attr">"status"</span>:<span class="string">"UP"</span>,</span><br><span class="line">            <span class="attr">"details"</span>:&#123;</span><br><span class="line">                <span class="attr">"discoveryClient"</span>:&#123;</span><br><span class="line">                    <span class="attr">"status"</span>:<span class="string">"UP"</span>,</span><br><span class="line">                    <span class="attr">"details"</span>:&#123;</span><br><span class="line">                        <span class="attr">"services"</span>:[</span><br><span class="line">                            <span class="string">"spring-cloud-register2"</span></span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"eureka"</span>:&#123;</span><br><span class="line">                    <span class="attr">"description"</span>:<span class="string">"Remote status from Eureka server"</span>,</span><br><span class="line">                    <span class="attr">"status"</span>:<span class="string">"UP"</span>,</span><br><span class="line">                    <span class="attr">"details"</span>:&#123;</span><br><span class="line">                        <span class="attr">"applications"</span>:&#123;</span><br><span class="line">                            <span class="attr">"SPRING-CLOUD-REGISTER2"</span>:<span class="number">1</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"hystrix"</span>:&#123;</span><br><span class="line">            <span class="attr">"status"</span>:<span class="string">"UP"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义HealthIndicator"><a href="#自定义HealthIndicator" class="headerlink" title="自定义HealthIndicator"></a>自定义HealthIndicator</h2><p>自定义的 HealthIndicator 可以实现自己的健康检查机制。实现类只需要用<code>@Component</code>注解注入就行。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Health.up().build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="客户端自我检查后上报"><a href="#客户端自我检查后上报" class="headerlink" title="客户端自我检查后上报"></a>客户端自我检查后上报</h1><p>SpringCloud Client 依赖了<code>spring-boot-starter-actuator</code>，并配置<code>eureka.client.healthcheck.enabled = true</code>之后，会自己<strong>周期性（默认30秒）</strong>地执行健康检查，若健康状态与上一次检查的不一致，会调用 Server 的<strong>注册</strong>接口，将自己的状态告诉 Server，这样注册中心的页面上可以看到此客户端的健康状态变了。</p><blockquote><p>注册中心的注册接口：POST /eureka/apps/{appId}。appId就是配置文件中的<code>spring.application.name</code>，请求体是<code>InstanceInfo</code>类，其中属性<code>status</code>就是服务的健康状态。</p></blockquote><p><code>DiscoveryClient</code>初始化方法<code>initScheduledTasks()</code>中，判断配置项<code>eureka.client.registerWithEureka = true</code>时，初始化<code>InstanceInfoReplicator</code>，并调用其 start() 方法。</p><p>InstanceInfoReplicator 继承自 Runnable 接口，它有个成员<code>ScheduledExecutorService scheduler</code>，这是可以设置执行周期性任务或延时任务的线程池类，执行的任务内容基本就是 InstanceInfoReplicator 定义的 run 方法。</p><p>InstanceInfoReplicator.run() 方法中调用 DiscoveryClient.refreshInstanceInfo() 方法，DiscoveryClient.refreshInstanceInfo() 方法中调用 EurekaHealthCheckHandler.getStatus() 方法执行健康检查，再调用 ApplicationInfoManager.setInstanceStatus(status) 将检查结果 InstanceStatus 传给<code>ApplicationInfoManager</code>类。</p><p>ApplicationInfoManager.setInstanceStatus() 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setInstanceStatus</span><span class="params">(InstanceStatus status)</span> </span>&#123;</span><br><span class="line">      InstanceStatus next = instanceStatusMapper.map(status);</span><br><span class="line">      <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 设置新状态，返回旧状态</span></span><br><span class="line">      InstanceStatus prev = instanceInfo.setStatus(next);</span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (StatusChangeListener listener : listeners.values()) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  listener.notify(<span class="keyword">new</span> StatusChangeEvent(prev, next));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  logger.warn(<span class="string">"failed to notify listener: &#123;&#125;"</span>, listener.getId(), e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，若 InstanceInfo 的前一个状态 prev 不为 null，会将两个状态作为一个<code>StatusChangeEvent</code>事件通知到<code>StatusChangeListener</code>类。而我们从<code>InstanceInfo.setStatus()</code>方法中得知，当前后状态一致，即健康状态不变，返回的 prev 就是 null，ApplicationInfoManager 就不会通知 StatusChangeListener。</p><p>StatusChangeListener 的实现类也是在 DiscoveryClient.initScheduledTasks() 中定义好的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">statusChangeListener = <span class="keyword">new</span> ApplicationInfoManager.StatusChangeListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"statusChangeListener"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(StatusChangeEvent statusChangeEvent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||</span><br><span class="line">InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123;</span><br><span class="line"><span class="comment">// log at warn level if DOWN was involved</span></span><br><span class="line">logger.warn(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logger.info(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</span><br><span class="line">&#125;</span><br><span class="line">instanceInfoReplicator.onDemandUpdate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它监听到 StatusChangeEvent 事件后，调用了<code>InstanceInfoReplicator.onDemandUpdate()</code>方法，而这个方法中其实就是调用了 InstanceInfoReplicator.run() 方法。</p><p>InstanceInfoReplicator.run() 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceInfoReplicator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            discoveryClient.refreshInstanceInfo();</span><br><span class="line"></span><br><span class="line">            Long dirtyTimestamp = instanceInfo.isDirtyWithTime();</span><br><span class="line">            <span class="keyword">if</span> (dirtyTimestamp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                discoveryClient.register();</span><br><span class="line">                instanceInfo.unsetIsDirty(dirtyTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"There was a problem with the instance info replicator"</span>, t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Future next = scheduler.schedule(<span class="keyword">this</span>, replicationIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">            scheduledPeriodicRef.set(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中除了调用 DiscoveryClient.refreshInstanceInfo() 方法触发健康检查以外，还会调用 DiscoveryClient.register() 进行注册，在这之前有个判断，判断当前 InstanceInfo 是否已经“Dirty”了，若是就要重新注册。“Dirty”的设置在上面提到的 InstanceInfo.setStatus() 方法中，简单地说，当新旧健康状态不一致时，当前 InstanceInfo 会被设置为 Dirty，于是会重新注册。 </p><p>从上面源码中还可以看出，每次执行 run() 方法，都会在 finally 块中设置下一次执行时间是当前时间延迟<code>replicationIntervalSeconds</code>秒，因此等同于每 replicationIntervalSeconds 秒执行一次 run() 方法，这个时间可配置，默认值30秒。</p><p>总结：InstanceInfoReplicator.run() 周期性执行，默认周期30秒，每次执行都会触发 EurekaHealthCheckHandler 进行健康检查（调用链：InstanceInfoReplicator.run() -&gt; DiscoveryClient.refreshInstanceInfo() -&gt; EurekaHealthCheckHandler.getStatus()）。若本次检查结果和上次不一样，就会再次发送注册请求，上报自己的状态信息，注册中心页面上的服务状态就会更新（调用链：ApplicationInfoManager.setInstanceStatus() -&gt; StatusChangeListener.notify() -&gt; InstanceInfoReplicator.onDemandUpdate() -&gt; InstanceInfoReplicator.run() -&gt; DiscoveryClient.register()）。</p><h1 id="SpringBoot-Admin-Server-主动调用"><a href="#SpringBoot-Admin-Server-主动调用" class="headerlink" title="SpringBoot Admin Server 主动调用"></a>SpringBoot Admin Server 主动调用</h1><blockquote><p>spring-boot-admin-starter-server 源码中大量使用<code>Flux</code>、<code>Mono</code>类，它们是 Spring Reactor，即响应式编程中的基本概念。简单地说，Flux 表示可以发射1到N个元素的异步发射器，Mono 表示可以发射0或1个元素的异步发射器。这里不多介绍了。</p></blockquote><p>Admin Server 在装配类<code>AdminServerAutoConfiguration</code>中注入了一个<code>StatusUpdateTrigger</code> Bean，它用来<strong>周期性（默认10秒）</strong>请求客户端的 health 端点，更新客户端状态。从下面源码可以看到，StatusUpdateTrigger 的 Bean 初始化方法是 start 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(initMethod = <span class="string">"start"</span>, destroyMethod = <span class="string">"stop"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatusUpdateTrigger <span class="title">statusUpdateTrigger</span><span class="params">(StatusUpdater statusUpdater, Publisher&lt;InstanceEvent&gt; events)</span> </span>&#123;</span><br><span class="line">    StatusUpdateTrigger trigger = <span class="keyword">new</span> StatusUpdateTrigger(statusUpdater, events);</span><br><span class="line">    trigger.setUpdateInterval(adminServerProperties.getMonitor().getPeriod());</span><br><span class="line">    trigger.setStatusLifetime(adminServerProperties.getMonitor().getStatusLifetime());</span><br><span class="line">    <span class="keyword">return</span> trigger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 StatusUpdateTrigger.start() 方法中，用 Flux 类设置了执行周期（10秒）和执行方法，在执行方法内，对每个服务实例<code>Instance</code>遍历调用了<code>StatusUpdater.updateStatus()</code>方法。<br>updateStatus() 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">updateStatus</span><span class="params">(InstanceId id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> repository.computeIfPresent(id, (key, instance) -&gt; <span class="keyword">this</span>.doUpdateStatus(instance)).then();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 StatusUpdater.updateStatus() 方法中，根据 doUpdateStatus() 方法的返回值更新了 repository 中某个客户端的状态。 repository 是<code>InstanceRepository</code>接口的实现类<code>SnapshottingInstanceRepository</code>对象，作用是保存所有客户端 Instance。</p><p>StatusUpdater.doUpdateStatus() 方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Mono&lt;Instance&gt; <span class="title">doUpdateStatus</span><span class="params">(Instance instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance.isRegistered()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">"Update status for &#123;&#125;"</span>, instance);</span><br><span class="line">    <span class="keyword">return</span> instanceWebClient.instance(instance)</span><br><span class="line">                            .get()</span><br><span class="line">                            .uri(Endpoint.HEALTH)</span><br><span class="line">                            .exchange()</span><br><span class="line">                            .log(log.getName(), Level.FINEST)</span><br><span class="line">                            .flatMap(<span class="keyword">this</span>::convertStatusInfo)</span><br><span class="line">                            .doOnError(ex -&gt; logError(instance, ex))</span><br><span class="line">                            .onErrorResume(<span class="keyword">this</span>::handleError)</span><br><span class="line">                            .map(instance::withStatusInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，发送HTTP请求到客户端 health 端点，根据响应的 HTTP 状态码确定被调客户端的健康状态（用<code>StatusInfo</code>类表示，这个类是 admin-server 依赖定义的）。响应码200时，StatusInfo=(status=UP, details={})；响应码503时，StatusInfo=(status=DOWN, details={error=Service Unavailable, status=503})。如果出现 HTTP 调用失败导致无响应，会打印日志”Couldn’t retrieve status for Instance…”，并把该服务的状态定为 OFFLINE。</p><p>这个HTTP状态码和 StatusInfo 的对应关系是在客户端 health 端点响应中定义的。只有当状态为 Status.DOWN 和 Status.OUT_OF_SERVICE 时，响应码503，其余的响应码都是200。</p><p>顺便一提，Admin Server 调用 Client 的 health 端点是调用到 Client 的这个方法：（delegate 就是上面提到过的 CompositeHealthIndicator）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EndpointWebExtension</span>(endpoint = HealthEndpoint<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HealthEndpointWebExtension</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ReadOperation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebEndpointResponse&lt;Health&gt; <span class="title">getHealth</span><span class="params">(SecurityContext securityContext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.responseMapper.map(<span class="keyword">this</span>.delegate.health(), securityContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，Admin Server 监控服务状态的方法就是用 StatusUpdateTrigger 每隔10秒遍历客户端的 health 端点，把最新状态更新到 SnapshottingInstanceRepository 中，Admin Server 页面上的服务状态也随之变化。</p><p>再说说 SnapshottingInstanceRepository 中所有的客户端服务信息是怎么来的。它的来源是，在 Eureka Server 的 DiscoveryClient 中，因为配置了<code>eureka.client.fetchRegistry = true</code>，所以初始化一个定时任务（定时周期默认30秒），这个任务就是定时向 Eureka Server （也就是它自己）拉取服务列表，这个服务列表就会更新到 SnapshottingInstanceRepository 中。</p><p>实现方式是，DiscoveryClient 拉取服务列表成功后会发布<code>HeartbeatEvent</code>事件。这个事件被<code>InstanceDiscoveryListener</code>监听到了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceDiscoveryListener</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(HeartbeatEvent event)</span> </span>&#123;</span><br><span class="line">        discoverIfNeeded(event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法调用到<code>InstanceRegistry.register()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;InstanceId&gt; <span class="title">register</span><span class="params">(Registration registration)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(registration, <span class="string">"'registration' must not be null"</span>);</span><br><span class="line">    InstanceId id = generator.generateId(registration);</span><br><span class="line">    Assert.notNull(id, <span class="string">"'id' must not be null"</span>);</span><br><span class="line">    <span class="keyword">return</span> repository.compute(id, (key, instance) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = Instance.create(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(instance.register(registration));</span><br><span class="line">    &#125;).map(Instance::getId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，会为每个服务生成一个ID，这个ID是唯一且固定的（即使服务重新注册也不会改变）。当我们在 Admin Server 页面上访问某个服务的某个端点时，这个ID会拼接在前端请求的URL中，如：<a href="http://localhost:18001/admin/instances/eb4fa470685c/actuator/metrics。" target="_blank" rel="noopener">http://localhost:18001/admin/instances/eb4fa470685c/actuator/metrics。</a></p><blockquote><p>Admin 心跳检查的周期是20秒？</p></blockquote><p>在实践中发现， Admin Server 调用客户端 health 端点似乎并不是严格的以10秒为周期，原因在于，虽然 StatusUpdateTrigger 是每隔10秒调用 updateStatusForAllInstances 方法，但在 updateStatusForAllInstances 中有一个判断，当上一次查询的时间是在当前时间的前10秒内，则不执行更新方法 updateStatus 。只有当上一次查询的时间是在当前时间的前10秒之前，才会执行 updateStatus 方法去调这个服务节点的 health 端点。<br>由于时间计算的误差，有时候两次调 health 的间隔是10秒，有时候是20秒。</p><p><code>updateStatusForAllInstances</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Mono&lt;Void&gt; <span class="title">updateStatusForAllInstances</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.debug(<span class="string">"Updating status for all instances"</span>);</span><br><span class="line">    Instant expiryInstant = Instant.now().minus(statusLifetime);</span><br><span class="line">    <span class="keyword">return</span> Flux.fromIterable(lastQueried.entrySet())</span><br><span class="line">               .filter(e -&gt; e.getValue().isBefore(expiryInstant)) <span class="comment">// 判断时间</span></span><br><span class="line">               .map(Map.Entry::getKey)</span><br><span class="line">               .flatMap(<span class="keyword">this</span>::updateStatus) <span class="comment">// 更新方法</span></span><br><span class="line">               .then();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java BIO NIO</title>
      <link href="/2020/10/25/java-io/"/>
      <url>/2020/10/25/java-io/</url>
      
        <content type="html"><![CDATA[<h1 id="BIO基础"><a href="#BIO基础" class="headerlink" title="BIO基础"></a>BIO基础</h1><p>BIO全称是Blocking I/O，意为非阻塞IO。我们平时使用的IO API就是BIO。</p><p>BIO是面向流的。<strong>输入流读取数据，输出流写入数据</strong>。流基类是<code>InputStream</code>和<code>OutputStream</code>。但我们不能直接使用基类，只能使用其子类。基类声明了子类最基本也是最常用的 read/write 方法。</p><p><code>InputStream</code>和<code>OutputStream</code>是直接操作<strong>字节数组</strong>的。使用它们需要手动把字符转为字节输入，字节转为字符读出。它们有“一次读/写一个字节”和“一次读/写多个字节”的方法，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure><p>“一次读/写一个字节”的方法因为效率低下所以很少用。“一次读/写多个字节”的方法很常用。read 方法数据流向：<code>input -&gt; byte[]</code>。write 方法数据流向：<code>byte[] -&gt; output</code>。read 方法返回值int代表实际读取的字节数。</p><p>常用子类：</p><ol><li>FileInputStream、FileOutputStream</li><li>BufferedInputStream、BufferedOutputStream</li><li>ByteArrayInputStream、ByteArrayOutputStream</li></ol><h2 id="BufferedInputStream和BufferedOutputStream"><a href="#BufferedInputStream和BufferedOutputStream" class="headerlink" title="BufferedInputStream和BufferedOutputStream"></a>BufferedInputStream和BufferedOutputStream</h2><p><code>BufferedOutputStream</code>将写入的数据存储在缓冲区中，缓冲区是一个名为buf的字节数组。等到缓冲区满或刷新输出流时，它将数据一次性全部写入底层输出流。因此，调用 BufferedOutputStream 的 write 方法之后，需要手动调用<code>flush()</code>方法把缓冲区数据写入底层输出流。</p><p><code>BufferedInputStream</code>也有一个名为buf的字节数组作缓冲区。调用 read 方法时，它首先从缓冲区读取数据，只有当缓冲区没有数据时，它才会从底层输入流读取数据。和其他输入流子类不同的是，当<code>BufferedInputStream</code>的 read 方法需要从底层读取数据时，它会一直读到“输入流阻塞”或“没有数据可读”时，这些数据会放到缓冲区，然后把缓冲区数据的全部或部分填充到 byte[] 数组。其他输入流在返回前，只从底层读取一次，不会尝试多次读取直到无可读。</p><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream(InputStream in)</span><br><span class="line">BufferedInputStream(InputStream in, <span class="keyword">int</span> bufferSize)</span><br><span class="line"></span><br><span class="line">BufferedOutputStream(OutputStream out)</span><br><span class="line">BufferedOutputStream(OutputStream out, <span class="keyword">int</span> bufferSize)</span><br></pre></td></tr></table></figure><p>第一个参数就是底层输入/输出流，第二个参数是指定缓冲区大小（单位为字节）。默认情况下，输入/输出流的 bufferSize 为8192字节。</p><p>BufferedInputStream和BufferedOutputStream的 read/write 方法同基类，无新增方法。</p><h2 id="ByteArrayInputStream和ByteArrayOutputStream"><a href="#ByteArrayInputStream和ByteArrayOutputStream" class="headerlink" title="ByteArrayInputStream和ByteArrayOutputStream"></a>ByteArrayInputStream和ByteArrayOutputStream</h2><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayInputStream(<span class="keyword">byte</span> buf[])</span><br><span class="line">ByteArrayInputStream(<span class="keyword">byte</span> buf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream()</span><br><span class="line">ByteArrayOutputStream(<span class="keyword">int</span> size)</span><br></pre></td></tr></table></figure><p><code>ByteArrayInputStream</code>的参数 byte buf[] 是这个输入流数据的来源。当调用 ByteArrayInputStream 的 read(byte[] data) 方法时，就是把这个 byte buf[] 的数据复制到 byte[] data 中。offset 和 length 参数和上面所说的 read/write 方法的含义一致。</p><p><code>ByteArrayOutputStream</code>内部也有一个字节数组buf，参数size就是指定这个字节数组的大小（默认值32）。当调用 ByteArrayOutputStream 的 write(byte[] data) 方法时，就是把这个 byte[] data 的数据复制到 byte buf[] 中。</p><p>ByteArrayXXX 和 BufferedXXX 的<strong>区别</strong>在于，ByteArrayXXX 没有用底层输入/输出流，它只把数据存在字节数组 buf 中。而 BufferedXXX 和底层流有交互，字节数组 buf 只是它和底层流之间的缓冲。在使用场景上，BufferedXXX 常用在网络IO，因为读/写缓冲区的速度比直接读/写网络流要快。ByteArrayXXX 常用于复制输入流的内容，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InputStream input =  httpconn.getInputStream();</span><br><span class="line">  </span><br><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();  </span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line"><span class="keyword">int</span> len;  </span><br><span class="line"><span class="keyword">while</span> ((len = input.read(buffer)) &gt; -<span class="number">1</span> ) &#123;  </span><br><span class="line">baos.write(buffer, <span class="number">0</span>, len);  </span><br><span class="line">&#125;</span><br><span class="line">baos.flush();</span><br><span class="line"><span class="comment">// 复制</span></span><br><span class="line">InputStream stream1 = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">InputStream stream2 = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br></pre></td></tr></table></figure><h2 id="处理字符的Reader和Writer"><a href="#处理字符的Reader和Writer" class="headerlink" title="处理字符的Reader和Writer"></a>处理字符的Reader和Writer</h2><p><code>Reader</code>和<code>Writer</code>直接操作的是<strong>字符</strong>而不是字节。字节和字符互相转换需要指定编码方式<code>charset</code>。Reader 和 Writer 默认使用的编码方式来自于<code>Charset.defaultCharset()</code>方法返回值。</p><p>Charset.defaultCharset() 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title">defaultCharset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (defaultCharset == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Charset<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">String csn = AccessController.doPrivileged(</span><br><span class="line"><span class="keyword">new</span> GetPropertyAction(<span class="string">"file.encoding"</span>));</span><br><span class="line">Charset cs = lookup(csn);</span><br><span class="line"><span class="keyword">if</span> (cs != <span class="keyword">null</span>)</span><br><span class="line">defaultCharset = cs;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">defaultCharset = forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> defaultCharset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面方法中，首先取<code>file.encoding</code>属性值，找不到该属性值则返回”UTF-8”。<code>file.encoding</code>属性值在 Eclipse 中设置在 Project -&gt; Properties -&gt; Resource -&gt; Text file encoding。项目不是在 Eclipse 中运行时，file.encoding 就是系统编码。</p><p>Reader 和 Writer 是基类，和 XXXStream 类一样，规定了子类的基本方法，包括“一次读/写一个字符”和“一次读/写多个字符”，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] text)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] text)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String s, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure><p>和 XXXStream 类方法很相似，不同的是字节数组变成了字符数组（字符串），且 read 方法返回值 int 表示实际读取的<strong>字符数</strong>。</p><p>重要子类：</p><ol><li>InputStreamReader、OutputStreamWriter</li><li>BufferedReader、BufferedWriter</li><li>StringReader、StringWriter</li></ol><h2 id="InputStreamReader和OutputStreamWriter"><a href="#InputStreamReader和OutputStreamWriter" class="headerlink" title="InputStreamReader和OutputStreamWriter"></a>InputStreamReader和OutputStreamWriter</h2><p>这两个类是 Reader 和 Writer 最基本的子类，也是 XXXStream 的包装类。<code>InputStreamReader</code>从其底层输入流中读取字节，再根据 charset 把字节转为字符返回。<code>OutputStreamWriter</code>接收字符数组，根据 charset 将字符转为字节，写入底层输出流。</p><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader(InputStream in)</span><br><span class="line">InputStreamReader(InputStream in, String charsetName)</span><br><span class="line"></span><br><span class="line">OutputStreamWriter(OutputStream out)</span><br><span class="line">OutputStreamWriter(OutputStream out, String charsetName)</span><br></pre></td></tr></table></figure><h2 id="BufferedReader和BufferedWriter"><a href="#BufferedReader和BufferedWriter" class="headerlink" title="BufferedReader和BufferedWriter"></a>BufferedReader和BufferedWriter</h2><p>与 BufferedInputStream 和 BufferedOutputStream 相似，<code>BufferedReader</code>和<code>BufferedWriter</code>使用内部的<strong>字符数组</strong>作为缓冲区，读取时先从缓冲区读取，写入时先写入缓冲区，只有当缓冲区满或 flush 时，缓冲区内容才写入底层输出流。</p><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader(Reader in)</span><br><span class="line">BufferedReader(Reader in, <span class="keyword">int</span> bufferSize)</span><br><span class="line"></span><br><span class="line">BufferedWriter(Writer out)</span><br><span class="line">BufferedWriter(Writer out, <span class="keyword">int</span> bufferSize)</span><br></pre></td></tr></table></figure><p>bufferSize为缓冲区字符数组大小，默认为8192字符。</p><h2 id="StringReader和StringWriter"><a href="#StringReader和StringWriter" class="headerlink" title="StringReader和StringWriter"></a>StringReader和StringWriter</h2><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringReader(String s)</span><br><span class="line"></span><br><span class="line">StringWriter()</span><br><span class="line">StringWriter(<span class="keyword">int</span> initialSize)</span><br></pre></td></tr></table></figure><p><code>StringReader</code>和<code>StringWriter</code>都没有与底层输入/输出流交互。StringReader 的成员变量就是一个字符串<code>String s</code>，StringWriter 的成员变量是<code>StringBuffer buf</code>，这也是它们存放数据的地方。读取的数据来源是 String s，写入数据的目的地是 StringBuffer buf。StringWriter 构造函数中 initialSize 是设置 StringBuffer buf 的大小。</p><p>这两个类提供了字符串与 Reader、Writer 之间互相转换的便利。StringWriter 的<code>toString()</code>方法就可以直接输出 StringBuffer buf 的内容，非常方便。</p><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS常用方法</title>
      <link href="/2020/10/25/js-note/"/>
      <url>/2020/10/25/js-note/</url>
      
        <content type="html"><![CDATA[<p>JS（JavaScript）是一种脚本语言，是许多浏览器的默认脚本语言，因此不需要在<code>&lt;script&gt;</code>标签中使用 type=”text/javascript”。</p><p>下面所有JS代码都是写在下面这个模板的<code>&lt;script&gt;</code>标签中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"test()"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// JS代码....</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="获取HTML元素"><a href="#获取HTML元素" class="headerlink" title="获取HTML元素"></a>获取HTML元素</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(id)</span><br></pre></td></tr></table></figure><h1 id="对象与JSON字符串互相转化"><a href="#对象与JSON字符串互相转化" class="headerlink" title="对象与JSON字符串互相转化"></a>对象与JSON字符串互相转化</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr = <span class="built_in">JSON</span>.stringify(obj1) <span class="comment">// 对象转JSON字符串</span></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(jsonStr) <span class="comment">// JSON字符串转对象</span></span><br></pre></td></tr></table></figure><h1 id="判断对象为空"><a href="#判断对象为空" class="headerlink" title="判断对象为空"></a>判断对象为空</h1><p>js的对象有3种状态：undefined、null、空对象（无属性的对象）、有属性的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1</span><br><span class="line">getType(obj1) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="literal">null</span></span><br><span class="line">getType(obj2) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;&#125;</span><br><span class="line">getType(obj3) <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj4 = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">getType(obj4) <span class="comment">// 有属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj === <span class="literal">undefined</span>) <span class="built_in">console</span>.log(<span class="string">'undefined'</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(obj === <span class="literal">null</span>) <span class="built_in">console</span>.log(<span class="string">'null'</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span>) <span class="built_in">console</span>.log(<span class="string">'&#123;&#125;'</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">'有属性'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，很多时候判断变量直接写<code>if(obj)</code>，这个详细展开说下。</p><h1 id="IF-变量"><a href="#IF-变量" class="headerlink" title="IF+变量"></a>IF+变量</h1><p>很多时候，我们直接使用变量作为判断条件，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj) &#123;&#125;</span><br><span class="line">obj ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>对于不同的变量类型，判断为true/false的结果各有差异，具体为：</p><ol><li>undefined、null =&gt; false</li><li>空字符串 =&gt; false （只有空格的字符串不算空字符串）</li><li>整数0 =&gt; false</li></ol><p>为true的情况就与以上情况相反。</p><h1 id="是否相等"><a href="#是否相等" class="headerlink" title="是否相等"></a>是否相等</h1><p>两个等号<code>==</code>与三个等号<code>===</code>都是用来比较变量是否相等，区别在于，两个等号是不严格相等，类型不同的变量只要值相等也属于相等。<strong>一般使用三个等号</strong>，类型不同即不相等。<br>不等号 <code>!=</code>与<code>!==</code>的区别也是如此，一般使用后者。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num == str) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(num === str) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h1><p>遍历数组元素都是通过下标来遍历，无论数组元素是普通类型还是对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123; <span class="comment">// 第一种</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123; <span class="comment">// 第二种</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span>,</span><br><span class="line">c: <span class="number">3</span>,</span><br><span class="line">d: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">e: <span class="number">99</span>,</span><br><span class="line">f: <span class="number">88</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [obj1, obj2] <span class="comment">// 对象数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h1><p>遍历对象属性也可以用<code>for in</code>语法，此外还可以用<code>Object.keys()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span>,</span><br><span class="line">c: <span class="number">3</span>,</span><br><span class="line">d: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(key + <span class="string">":"</span> + obj[key])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj); <span class="comment">// 只包含key的数组 于是遍历对象改为遍历数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> keys) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(keys[i] + <span class="string">":"</span> + obj[keys[i]])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象合并与复制"><a href="#对象合并与复制" class="headerlink" title="对象合并与复制"></a>对象合并与复制</h1><p>使用三点运算符<code>...</code> 或 <code>Object.assign()</code></p><p>三点运算符例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span>,</span><br><span class="line">c: <span class="number">3</span>,</span><br><span class="line">d: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">e: <span class="number">99</span>,</span><br><span class="line">f: <span class="number">88</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;...obj1&#125; <span class="comment">// 复制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj4 = &#123;...obj1, ...obj2&#125; <span class="comment">// 合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj5 = &#123;</span><br><span class="line">e: <span class="number">100</span>,</span><br><span class="line">f: <span class="number">88</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj6 = &#123;...obj4, ...obj5&#125; <span class="comment">// 有相同属性时，后者覆盖前者</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj3)) <span class="comment">// &#123;"a":1,"b":2,"c":3,"d":4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj4)) <span class="comment">// &#123;"a":1,"b":2,"c":3,"d":4,"e":99,"f":88&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj6)) <span class="comment">// &#123;"a":1,"b":2,"c":3,"d":4,"e":100,"f":88&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Object.assign()例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span>,</span><br><span class="line">c: <span class="number">3</span>,</span><br><span class="line">d: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">e: <span class="number">99</span>,</span><br><span class="line">f: <span class="number">88</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj5 = &#123;</span><br><span class="line">e: <span class="number">100</span>,</span><br><span class="line">f: <span class="number">88</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj6 = <span class="built_in">Object</span>.assign(obj1, obj2, obj5) <span class="comment">// 把obj2、obj5都合并到obj1并返回</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1)) <span class="comment">// &#123;"a":1,"b":2,"c":3,"d":4,"e":100,"f":88&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj6)) <span class="comment">// &#123;"a":1,"b":2,"c":3,"d":4,"e":100,"f":88&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：合并后的对象属性顺序与合并顺序一致。当参与合并的两个对象有相同属性 key 时，后一个对象的属性 value 会覆盖前一个对象的value。</p><h1 id="对象属性的增删"><a href="#对象属性的增删" class="headerlink" title="对象属性的增删"></a>对象属性的增删</h1><p>JS对象可以随意新增、删除属性字段。前提是这个对象不为 null 或 undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> user = &#123;&#125;</span><br><span class="line"></span><br><span class="line">user.name = <span class="string">"abc"</span> <span class="comment">// 添加属性</span></span><br><span class="line">user.age = <span class="number">24</span></span><br><span class="line">user.sex = <span class="string">"male"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(user)) <span class="comment">// &#123;"name":"abc","age":24,"sex":"male"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> user.age <span class="comment">// 删除属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(user)) <span class="comment">// &#123;"name":"abc","sex":"male"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user2 = <span class="literal">null</span></span><br><span class="line">user2.name = <span class="string">"efg"</span> <span class="comment">// Cannot set property 'name' of null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user3</span><br><span class="line">user3.name = <span class="string">"efg"</span> <span class="comment">// Cannot set property 'name' of undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找数组元素并返回"><a href="#查找数组元素并返回" class="headerlink" title="查找数组元素并返回"></a>查找数组元素并返回</h1><p>JS的<code>Array.find</code>方法用于查找出满足指定条件的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = arr.find(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">e = e + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> e === <span class="number">6</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// 不改变原数组元素</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = []</span><br><span class="line"><span class="keyword">var</span> result2 = arr2.find(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e + <span class="number">1</span> === <span class="number">6</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在回调函数中，“return + 条件”，条件符合则返回true，查找到元素。回调函数中即使对每个元素有修改，也<strong>不会改变原数组和原数组中的元素</strong>。若符合条件的元素有多个，<strong>只返回第一个</strong>。</p><p>若数组为空，则返回 undefined 。</p><p>此外，还有<strong>返回符合条件的元素的下标</strong>的方法：<code>Array.findIndex</code>。除了返回的是下标值外，其他和 find 方法无异。空数组返回 -1 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = arr.findIndex(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">e = e + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> e === <span class="number">6</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// 不改变原数组元素</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = []</span><br><span class="line"><span class="keyword">var</span> result2 = arr2.findIndex(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e + <span class="number">1</span> === <span class="number">6</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找元素下标还有更简单的方法： <code>indexOf</code>和<code>lastIndexOf</code>，用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = arr.indexOf(<span class="number">4</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> result2 = arr.lastIndexOf(<span class="number">4</span>) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="built_in">console</span>.log(result2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要<strong>返回所有符合条件的元素</strong>，用 filter 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = arr.filter(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e === <span class="number">4</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="遍历数组元素并执行函数"><a href="#遍历数组元素并执行函数" class="headerlink" title="遍历数组元素并执行函数"></a>遍历数组元素并执行函数</h1><p>这个功能用上面小节“遍历数组”中的方法也可实现。这里介绍更高级的方法。</p><p><strong>map:</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = arr.map(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map 方法对原数组每个元素执行一遍回调函数，返回新数组。如果没有return，则新数组元素为 undefined。若原数组为空，则新数组也为空：[]</p><p>map 方法也可以这么用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">a: <span class="number">3</span>,</span><br><span class="line">b: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">a: <span class="number">5</span>,</span><br><span class="line">b: <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [obj1, obj2, obj3]</span><br><span class="line"><span class="keyword">var</span> arrA = []</span><br><span class="line"><span class="keyword">var</span> arrB = []</span><br><span class="line"></span><br><span class="line">arr.map(<span class="function">(<span class="params">e, index</span>) =&gt;</span> &#123;</span><br><span class="line">arrA[index] = e.a</span><br><span class="line">arrB[index] = e.b</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="built_in">console</span>.log(arrA) <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrB) <span class="comment">// [2, 4, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>forEach:</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">e, index</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 map 不同，forEach 没有返回值，但也是每个元素都执行一遍回调函数。</p><blockquote><p>map 和 forEach 会不会改变原数组？这个要看具体情况。</p></blockquote><p>如果是对象数组，则会改变原数组：<br>【因为对象数组遍历时的 e 是引用类型，改变引用即改变原对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">a: <span class="number">3</span>,</span><br><span class="line">b: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">a: <span class="number">5</span>,</span><br><span class="line">b: <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [obj1,obj2,obj3]</span><br><span class="line"></span><br><span class="line">arr.map(<span class="function">(<span class="params">e, index</span>) =&gt;</span> &#123;</span><br><span class="line">e.b = e.a</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [&#123;a: 1, b: 1&#125;,&#123;a: 3, b: 3&#125;,&#123;a: 5, b: 5&#125;]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是基本类型数组，则不改变原数组：<br>【基本类型包括number, string, boolean, null, undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">arr.map(<span class="function">(<span class="params">e, index</span>) =&gt;</span> &#123;</span><br><span class="line">e = e*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是下面这样用，不管是什么类型的数组都会改变原数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">arr.map(<span class="function">(<span class="params">e, index</span>) =&gt;</span> &#123;</span><br><span class="line">arr[index] = <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 1, 1, 1, 1]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子都是用 map，改成 forEach 现象相同。</p><h1 id="增删数组元素"><a href="#增删数组元素" class="headerlink" title="增删数组元素"></a>增删数组元素</h1><p>pop：删除数组的最后一个元素，返回删除的元素。</p><p>push：向数组的末尾添加一个或更多元素，返回新的长度。</p><p>shift：删除数组的第一个元素，返回删除的元素。</p><p>unshift：向数组的开头添加一个或更多元素，返回新的长度。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = arr.pop() </span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(result1) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = arr.push(<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13]</span></span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result3 = arr.shift()</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13]</span></span><br><span class="line"><span class="built_in">console</span>.log(result3) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result4 = arr.unshift(<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [20, 21, 22, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13]</span></span><br><span class="line"><span class="built_in">console</span>.log(result4) <span class="comment">// 14</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指定下标增删元素：splice 方法</strong></p><p>array.splice(index, howmany, item1,…..,itemX)</p><p>index：要添加/删除元素的下标位置<br>howmany：在此下标位 删除 多少元素，为0表示不删除元素<br>item1,…..,itemX：要添加的元素，一个或多个</p><p>只返回被删除的元素组成的数组，若没有删除元素则返回空数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = arr.splice(<span class="number">2</span>,<span class="number">2</span>) <span class="comment">// 删除index=2,3 的元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"><span class="built_in">console</span>.log(result1) <span class="comment">// [3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = arr.splice(<span class="number">7</span>,<span class="number">0</span>,<span class="number">20</span>,<span class="number">21</span>) <span class="comment">// 在 index=7 插入两个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 5, 6, 7, 8, 9, 20, 21, 10]</span></span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result3 = arr.splice(<span class="number">1</span>,<span class="number">3</span>,<span class="number">30</span>,<span class="number">31</span>)  <span class="comment">// 删除index=1,2,3 的元素，再在 index=1 插入两个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 30, 31, 7, 8, 9, 20, 21, 10]</span></span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h1><p>JS中的字符串变量有很多方法的使用方式和作用与 Java 类似，其中包括：<br>substring(start, end)<br>split(regex, limit)<br>concat(str1, str2, …)<br>indexOf(searchString，position)<br>lastIndexOf(searchString, position)<br>replace(searchValue, replaceValue)</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件开发</title>
      <link href="/2020/08/30/vue-component-build/"/>
      <url>/2020/08/30/vue-component-build/</url>
      
        <content type="html"><![CDATA[<h1 id="父子组件之间的交互"><a href="#父子组件之间的交互" class="headerlink" title="父子组件之间的交互"></a>父子组件之间的交互</h1><ol><li>子组件要求父组件传递的变量写在<code>props</code>中</li><li>子组件自己维护的，不需要父组件传递的变量写在<code>data</code>中</li><li>在子组件内调用父组件方法：子组件用<code>$emit</code>发起一个事件（可以带事件参数），父组件用<code>v-on</code>或<code>@</code>监听这个事件并做处理（监听方法的形参就是子组件传的参数）</li><li>父组件调用子组件方法：父组件在子组件上定义<code>ref</code>属性,  父组件用<code>this.$refs.refName.method</code>去调用子组件方法。</li></ol><h1 id="示例：分页表格组件"><a href="#示例：分页表格组件" class="headerlink" title="示例：分页表格组件"></a>示例：分页表格组件</h1><p><code>TablePage</code>功能：</p><ol><li>翻页时、改变页大小时，自动调用后台查找</li><li>固定一列操作列，数据列和操作列分开从父组件传</li><li>当操作列中的按钮大于1时，这些按钮应折叠在“更多”下拉按钮中，如“编辑”、“删除”。如果不需要这些操作，操作列应该隐藏</li></ol><p>框架是iView。设置好跨域访问和axios全局后，使用<code>&lt;Table /&gt;</code>和<code>&lt;Page /&gt;</code>以及<code>slot-scope</code>实现以上功能。</p><p><code>TablePage</code>组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表格 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Table</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">:columns</span>=<span class="string">"insideColumns"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">:data</span>=<span class="string">"data"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">border</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"&#123; row, index &#125;"</span> <span class="attr">slot</span>=<span class="string">"action"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"actionNumber &lt; 2"</span>&gt;</span>     </span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"firstAction.onClick(row)"</span>&gt;</span>&#123;&#123;firstAction.name&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 按钮数超过一个时，显示更多操作的下拉菜单 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Dropdown</span> <span class="attr">transfer</span> <span class="attr">trigger</span>=<span class="string">"click"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0)"</span>&gt;</span>More<span class="tag">&lt;<span class="name">Icon</span> <span class="attr">type</span>=<span class="string">"ios-arrow-down"</span>&gt;</span><span class="tag">&lt;/<span class="name">Icon</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">DropdownMenu</span> <span class="attr">slot</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">DropdownItem</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in insideActions"</span> <span class="attr">:key</span>=<span class="string">"index"</span> &gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"item.onClick(row)"</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">DropdownItem</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">DropdownMenu</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">Dropdown</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Table</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 分页组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 10px"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Page</span> <span class="attr">transfer</span> <span class="attr">:current</span>=<span class="string">"currentPage"</span> <span class="attr">:total</span>=<span class="string">"count"</span> <span class="attr">:page-size</span>=<span class="string">"pageSize"</span> <span class="attr">show-elevator</span> <span class="attr">show-total</span> <span class="attr">show-sizer</span> @<span class="attr">on-change</span>=<span class="string">"changePage"</span> @<span class="attr">on-page-size-change</span>=<span class="string">"changePageSize"</span> /&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'TablePage'</span>,</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 子组件要求父组件传递的变量</span></span></span><br><span class="line">    props: &#123;</span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">default</span> () &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> [];</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, </span><br><span class="line"><span class="actionscript">        columns: &#123; <span class="comment">// 数据列</span></span></span><br><span class="line"><span class="javascript">            type: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">default</span> () &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> [];</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        actions: &#123; <span class="comment">// 操作列</span></span></span><br><span class="line"><span class="javascript">            type: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">default</span> () &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> [];</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,         </span><br><span class="line">        count: &#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">default</span>: <span class="number">0</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        currentPage: &#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">default</span>: <span class="number">1</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        pageSize: &#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">default</span>: <span class="number">10</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript"><span class="comment">// 子组件自己维护的变量</span></span></span><br><span class="line">    data () &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line">            insideColumns: [],</span><br><span class="line">            actionNumber: 0,</span><br><span class="line">            firstAction: &#123;&#125;,</span><br><span class="line">            insideActions: [],            </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changePage (newPage) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.currentPage = newPage;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.getData();</span></span><br><span class="line">        &#125;,</span><br><span class="line">        changePageSize (newPageSize) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.pageSize = newPageSize;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.getData();</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript"><span class="comment">// 在子组件内调用父组件方法：子组件用`$emit`发起一个事件</span></span></span><br><span class="line">        getData () &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.$emit(<span class="string">'get-data'</span>, <span class="keyword">this</span>.currentPage, <span class="keyword">this</span>.pageSize);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript"><span class="comment">// 当actions有元素时，新增一列操作列</span></span></span><br><span class="line">        handleColumns (columns) &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> actionColumn = &#123;</span></span><br><span class="line"><span class="actionscript">                title: <span class="string">'Action'</span>,</span></span><br><span class="line"><span class="actionscript">                slot: <span class="string">'action'</span>,</span></span><br><span class="line">                width: 130,</span><br><span class="line"><span class="actionscript">                fixed: <span class="string">'right'</span>,</span></span><br><span class="line"><span class="actionscript">                resizable: <span class="literal">true</span></span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">this</span>.actions &amp;&amp; <span class="keyword">this</span>.actions.length &gt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.insideColumns = columns.concat(actionColumn);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="comment">// 处理外部传入的 actions</span></span></span><br><span class="line">        handleActions (actions) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.actionNumber = actions.length; <span class="comment">// 按钮数</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">this</span>.actionNumber &gt; <span class="number">0</span>) &#123; </span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.firstAction = actions[<span class="number">0</span>]; <span class="comment">// 设置唯一的按钮</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span>(<span class="keyword">this</span>.actionNumber &gt; <span class="number">1</span>) &#123; <span class="comment">// 按钮多于1个，设置下拉按钮项</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> more = [...actions];</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.insideActions = more;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.handleColumns(<span class="keyword">this</span>.columns);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.handleActions(<span class="keyword">this</span>.actions);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中的<code>getData()</code>方法很关键，它是<code>TablePage</code>与父组件通信的桥梁，通过<code>this.$emit()</code>触发名为”get-data”的事件，并传递参数<code>currentPage</code>和<code>pageSize</code>。在父组件中，需要<code>v-on</code>这个事件，得到这两个参数。</p><p>父组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 点击按钮触发查询，加载表格数据 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-bottom: 10px"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> @<span class="attr">click</span>=<span class="string">"search()"</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--分页表格区域--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TablePage</span> <span class="attr">:columns</span>=<span class="string">"columns"</span> <span class="attr">:data</span>=<span class="string">"data"</span> <span class="attr">:count</span>=<span class="string">"count"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:currentPage</span>=<span class="string">"currentPage"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:pageSize</span>=<span class="string">"pageSize"</span></span></span><br><span class="line">            @get-data="loadData" &lt;!--子组件内$emit的事件--&gt;</span><br><span class="line">            :actions="actions"</span><br><span class="line">            &gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">TablePage</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> TablePage <span class="keyword">from</span> <span class="string">'./table-page'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'PersonManage'</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line"><span class="actionscript">    TablePage <span class="comment">// 引入组件</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">        currentPage: 1,</span><br><span class="line">        pageSize: 10,        </span><br><span class="line"><span class="actionscript">        <span class="comment">// 总条数</span></span></span><br><span class="line">        count: 0,</span><br><span class="line"><span class="actionscript">        <span class="comment">// 表格数据列</span></span></span><br><span class="line">        columns: [</span><br><span class="line">            &#123;</span><br><span class="line"><span class="actionscript">                title: <span class="string">'ID'</span>,</span></span><br><span class="line"><span class="actionscript">                key: <span class="string">'id'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line"><span class="actionscript">                title: <span class="string">'Lastname'</span>,</span></span><br><span class="line"><span class="actionscript">                key: <span class="string">'lastname'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line"><span class="actionscript">                title: <span class="string">'Firstname'</span>,</span></span><br><span class="line"><span class="actionscript">                key: <span class="string">'firstname'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line"><span class="actionscript">                title: <span class="string">'City'</span>,</span></span><br><span class="line"><span class="actionscript">                key: <span class="string">'city'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line"><span class="actionscript">                title: <span class="string">'Address'</span>,</span></span><br><span class="line"><span class="actionscript">                key: <span class="string">'address'</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"><span class="actionscript">        <span class="comment">// 表格源数据</span></span></span><br><span class="line">        data: [],</span><br><span class="line"><span class="actionscript">        <span class="comment">// 操作列</span></span></span><br><span class="line">        actions: [</span><br><span class="line"><span class="javascript">            &#123; <span class="attr">name</span>: <span class="string">'Edit'</span>, <span class="attr">onClick</span>: <span class="function">(<span class="params">row</span>) =&gt;</span> <span class="keyword">this</span>.handleEdit(row) &#125;,</span></span><br><span class="line"><span class="javascript">            &#123; <span class="attr">name</span>: <span class="string">'Delete'</span>, <span class="attr">onClick</span>: <span class="function">(<span class="params">row</span>) =&gt;</span> <span class="keyword">this</span>.handleDelete(row.id)&#125;</span></span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">      search()&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.currentPage = <span class="number">1</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.loadData(<span class="keyword">this</span>.currentPage, <span class="keyword">this</span>.pageSize)</span></span><br><span class="line">      &#125;,      </span><br><span class="line"><span class="actionscript">      <span class="comment">// 调用后台接口获取表格数据</span></span></span><br><span class="line">      loadData(currentPage, pageSize)&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.currentPage = currentPage</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.pageSize = pageSize</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$axios(&#123;</span></span><br><span class="line"><span class="actionscript">            url: <span class="string">'/man/person/getListByPage'</span>,</span></span><br><span class="line"><span class="actionscript">            method: <span class="string">'post'</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="actionscript">                currentPage: <span class="keyword">this</span>.currentPage,</span></span><br><span class="line"><span class="actionscript">                pageSize: <span class="keyword">this</span>.pageSize</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> resData = res.data</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> pageData = resData.data</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.data = pageData.dataList</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.count = pageData.count</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,  </span><br><span class="line"><span class="actionscript">  <span class="comment">// 按钮事件</span></span></span><br><span class="line">      handleEdit(row)&#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'edit=====&gt;'</span>+<span class="built_in">JSON</span>.stringify(row))</span></span><br><span class="line">      &#125;,</span><br><span class="line">      handleDelete(rowId)&#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'delete=====&gt;'</span>+<span class="built_in">JSON</span>.stringify(rowId))</span></span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>currentPage</code>和<code>pageSize</code>由父组件传入子组件，而不是由子组件维护，原因是：父组件在改变<code>currentPage</code>和<code>pageSize</code>的值后应该同步到子组件，这样子组件的<code>&lt;Page /&gt;</code>组件才能与实际页码和页大小匹配。</p><p>父组件改变<code>currentPage</code>和<code>pageSize</code>的场景：点击查询按钮时，需要把当前页码<code>currentPage</code>改为1。</p><p>因此，这两个参数也应该由父组件传入子组件，子组件改变它的值后通知到父组件。</p><h1 id="父组件调用子组件方法例子"><a href="#父组件调用子组件方法例子" class="headerlink" title="父组件调用子组件方法例子"></a>父组件调用子组件方法例子</h1><p>抄自：<a href="https://www.cnblogs.com/renzm0318/p/8762129.html" target="_blank" rel="noopener">https://www.cnblogs.com/renzm0318/p/8762129.html</a></p><p>子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">childComponent</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">name: <span class="string">"child"</span>,</span></span><br><span class="line">methods: &#123;</span><br><span class="line"><span class="actionscript">childClick(e) &#123; <span class="comment">// 子组件方法</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(e)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"parentClick"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">"mychild"</span> /&gt;</span><span class="comment">&lt;!--子组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./child'</span>;   <span class="comment">//引入子组件Child</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">name: <span class="string">"parent"</span>,</span></span><br><span class="line">components: &#123;</span><br><span class="line">Child</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">parentClick() &#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.$refs.mychild.childClick(<span class="string">"子组件方法"</span>);<span class="comment">// 调用子组件的方法childClick</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security 认证与授权流程</title>
      <link href="/2020/08/23/spring-security-auth/"/>
      <url>/2020/08/23/spring-security-auth/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>只要是权限校验框架，就离不开两个步骤：认证（Authentication）和授权（Authorization）。认证即“用户登录”，授权即“允许用户访问目标URI”。这篇博客介绍了Spring Security 5.0.6版本认证与授权这两个过程的执行链条，未涉及到更高级的功能（如单点登录、RememberMe）。</p><blockquote><p>官方文档（Security5.0.6）：<a href="https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/" target="_blank" rel="noopener">https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/</a></p></blockquote><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>Spring Security的认证工作主要由<code>UsernamePasswordAuthenticationFilter</code>完成。这个Filter是默认配置的，每个请求都会被它拦截。认证成功后，会生成经过认证的用户信息对象<code>Authentication</code>。<strong>无论认证成功或失败，都不会继续走后面的Filter。</strong></p><p>步骤简述：</p><ol><li>请求进入<code>UsernamePasswordAuthenticationFilter.doFilter()</code>方法</li><li>在doFilter()方法中，先判断请求URI是否为<code>POST loginProcessingUrl</code>，是则继续，<strong>否则跳过认证，直接进入Security过滤器链中下一个Filter</strong>。loginProcessingUrl表示登录提交的URI，可自定义，默认值为”/login”</li><li>判断为“是”，doFilter()调用<code>AuthenticationManager.authenticate()</code>。默认调用到AuthenticationManager的实现类<code>ProviderManager</code></li><li>在ProviderManager.authenticate()中，调用<code>AuthenticationProvider.authenticate()</code>方法执行真正的认证逻辑。默认调用到AuthenticationProvider的实现类<code>DaoAuthenticationProvider</code></li><li>在AuthenticationProvider.authenticate()中，根据请求中的用户名参数”username”，调用<code>UserDetailsService.loadUserByUsername()</code>，该方法返回<code>UserDetails</code>对象，表示数据源中存储的用户信息</li><li>AuthenticationProvider获得UserDetails对象后，校验此UserDetails对象，校验依据是UserDetails接口的几个boolean方法，如isEnabled()。说明一下，因为此UserDetails对象是用请求中的用户名查找出的，所以校验此对象状态也就是对请求中的用户名进行<strong>认证</strong></li><li>若在“第5步”中<code>UserDetailsService.loadUserByUsername()</code>没有找到UserDetails，或在“第6步”中校验UserDetails对象不通过，则说明请求中的用户名有误。这两个方法会抛出<code>AuthenticationException</code>子类，说明认证失败。这个异常向上传递最终由<code>UsernamePasswordAuthenticationFilter</code>捕获处理。UsernamePasswordAuthenticationFilter捕获异常后，调用<code>AuthenticationFailureHandler.onAuthenticationFailure()</code>进行后续处理，默认调用到实现类<code>SimpleUrlAuthenticationFailureHandler</code>，作用是返回403状态码，或者在设置了failureUrl时跳转到此URL。之后不会再经过其他Filter</li><li>若认证成功，则AuthenticationProvider生成通过认证的<code>Authentication</code>对象（含用户名、密码、权限等），并返回到<code>AuthenticationManager.authenticate()</code>，再向上传递到<code>UsernamePasswordAuthenticationFilter.doFilter()</code></li><li>doFilter()获得<code>Authentication</code>对象后，调用<code>SecurityContextHolder.getContext().setAuthentication()</code>将Authentication对象赋予给当前的<code>SecurityContext</code></li><li>doFilter()调用<code>AuthenticationSuccessHandler.onAuthenticationSuccess()</code>进行后续处理，默认调用到实现类<code>SavedRequestAwareAuthenticationSuccessHandler</code>，作用是从request header或配置中取targetUrl并跳转。之后不会再经过其他Filter</li></ol><p>认证成功流程：</p><img src="/2020/08/23/spring-security-auth/authentication_success.PNG" class="" title="认证成功"><p>认证失败流程：</p><img src="/2020/08/23/spring-security-auth/authentication_fail.PNG" class="" title="认证失败"><h2 id="UserDetailsService和UserDetails"><a href="#UserDetailsService和UserDetails" class="headerlink" title="UserDetailsService和UserDetails"></a>UserDetailsService和UserDetails</h2><p>在上述“第5步”中，提到了<code>UserDetailsService.loadUserByUsername()</code>方法。该方法源码；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException, DataAccessException</span>;</span><br></pre></td></tr></table></figure><p>该方法的作用就是查找数据源中的用户信息，<code>AuthenticationProvider.authenticate()</code>就是以此为依据对当前请求进行认证。根据UserDetailsService的已有实现类推测，数据源可以是JDBC数据库、内存。</p><p>该方法的返回对象<code>UserDetails</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的4个boolean方法，就是<code>DaoAuthenticationProvider</code>对请求进行认证的依据。Spring默认使用的实现类是<code>User</code>。</p><p><code>getAuthorities()</code>方法返回一个<code>Collection&lt;GrantedAuthority&gt;</code>对象，GrantedAuthority是个接口，一般使用它的实现类<code>SimpleGrantedAuthority</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GrantedAuthority</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回表示权限的String</span></span><br><span class="line"><span class="function">String <span class="title">getAuthority</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义实现思路"><a href="#自定义实现思路" class="headerlink" title="自定义实现思路"></a>自定义实现思路</h2><ol><li>自定义<code>AuthenticationProvider.authenticate()</code>，实现自己的认证逻辑，如校验密码是否正确</li><li>自定义<code>UserDetailsService.loadUserByUsername()</code>，实现自己的查找原用户信息的方式，如从数据库查找</li><li>自定义<code>UserDetails</code>，这是原用户信息对象，也是认证成功后被保存在<code>SecurityContext</code>的对象，可以自定义需要的属性，如用户所在组、岗位等</li><li>自定义会进入认证逻辑的<code>POST loginProcessingUrl</code>，如果你的登录表单action不是”/login”就需要设置</li><li>自定义登录页地址</li><li>自定义认证成功和失败后的处理，<code>AuthenticationSuccessHandler</code>和<code>AuthenticationFailureHandler</code></li></ol><p>以上自定义可以实现基本的认证需求，更高级的如RememberMe、单点登录等这里没有列出，需要查阅其他资料。</p><h2 id="自定义实现示例"><a href="#自定义实现示例" class="headerlink" title="自定义实现示例"></a>自定义实现示例</h2><p>配置示例（只写出与认证有关的部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">CustomAuthenticationProvider customAuthenticationProvider;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">http</span><br><span class="line">.formLogin() <span class="comment">// 这行下面的语句都是在设置UsernamePasswordAuthenticationFilter的属性</span></span><br><span class="line">.loginPage(<span class="string">"/login"</span>) <span class="comment">// 登录页</span></span><br><span class="line">.loginProcessingUrl(<span class="string">"/login/submit"</span>) <span class="comment">// 登录提交URI，访问此URI的请求会进入认证逻辑</span></span><br><span class="line">.successHandler(<span class="keyword">new</span> LoginSuccessHandler()) <span class="comment">// 自定义AuthenticationSuccessHandler</span></span><br><span class="line">.failureHandler(<span class="keyword">new</span> LoginFailureHandler()) <span class="comment">// 自定义AuthenticationFailureHandler</span></span><br><span class="line">.and()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 给AuthenticationManager设置自定义AuthenticationProvider</span></span><br><span class="line">auth.authenticationProvider(customAuthenticationProvider);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义AuthenticationProvider示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"securityUserService"</span>)</span><br><span class="line">UserDetailsService userDetailsService; <span class="comment">// 自定义UserDetailsService</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">String username = authentication.getName();</span><br><span class="line">Object password = (String) authentication.getCredentials();</span><br><span class="line"><span class="comment">// SecurityUser是自定义的UserDetails</span></span><br><span class="line">SecurityUser userDetails = (SecurityUser) userDetailsService.loadUserByUsername(username);</span><br><span class="line"><span class="keyword">if</span> (userDetails == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="string">"账号不存在"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!userDetails.getPassword().equals(password)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="string">"账号密码错误"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userDetails, password, userDetails.getAuthorities());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><p>在认证流程中，只有当请求URI是设置的登录提交URI loginProcessingUrl时，才会进入<code>UsernamePasswordAuthenticationFilter</code>的认证逻辑，且不论认证结果如何都会直接返回，不会进入授权流程。<strong>是其他URI时，就会跳过认证，直接进入授权流程</strong>。</p><p>Spring Security的授权工作主要由<code>FilterSecurityInterceptor</code>完成，它也是个Filter实现类。它是Security过滤器链中位置倒数第二的Filter，若进入了它的授权逻辑，授权成功则走出Security过滤器链，进入下一步；授权失败则请求结束，返回响应体或跳转页面。</p><ol><li>请求进入<code>FilterSecurityInterceptor</code>拦截器，调用其父类方法<code>super.beforeInvocation(fi)</code>，继续调用<code>FilterInvocationSecurityMetadataSource.getAttributes()</code>获取被拦截URI所需的权限字符串集合。Security内置了一些权限字符串，如“permitAll”</li><li>若<code>FilterInvocationSecurityMetadataSource.getAttributes()</code>方法返回NULL，则FilterSecurityInterceptor执行完毕，<strong>请求走出Security过滤器链</strong>。因此可以认为返回NULL的URI是无需权限访问的</li><li>被拦截URI的权限不为NULL，则FilterSecurityInterceptor通过<code>SecurityContext.getAuthentication()</code>取得当前用户的权限信息，再调用授权管理器<code>AccessDecisionManager.decide()</code>方法决定是否允许用户访问此URI。这个方法由AccessDecisionManager子类实现，Spring已实现的decide策略有<code>AffirmativeBased</code>一票肯定，<code>UnanimousBased</code>一票否定，<code>ConsensusBased</code>少数服从多数。默认使用AffirmativeBased</li><li>若用户无权访问，AccessDecisionManager.decide()抛出<code>AccessDeniedException</code>异常，这个异常会被<code>ExceptionTranslationFilter</code>处理，这个后面再讲</li><li>AccessDecisionManager.decide()顺利执行完毕，表示用户有权访问，即授权成功，<strong>请求走出Security过滤器链</strong></li></ol><blockquote><p>若未登录用户直接访问URI，AccessDecisionManager会怎么判断？<br>这个要看URI的权限，如果URI的权限是“permitAll”，则未登录用户也可以访问。具体看AffirmativeBased类的源码。</p></blockquote><p>另外，请求走出Security过滤器链后，不一定就直接进入Controller，因为走完Security过滤器链之后可能还有过滤器。这部分内容见“过滤器链”一节。</p><p>授权成功流程：</p><img src="/2020/08/23/spring-security-auth/authorization_success.png" class="" title="授权成功"><p>授权失败流程：</p><img src="/2020/08/23/spring-security-auth/authorization_fail.png" class="" title="授权失败"><h2 id="AccessDecisionManager和FilterInvocationSecurityMetadataSource"><a href="#AccessDecisionManager和FilterInvocationSecurityMetadataSource" class="headerlink" title="AccessDecisionManager和FilterInvocationSecurityMetadataSource"></a>AccessDecisionManager和FilterInvocationSecurityMetadataSource</h2><p>接口源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * authentication是当前用户信息，里面包含用户拥有的权限</span></span><br><span class="line"><span class="comment"> * object是被拦截URI</span></span><br><span class="line"><span class="comment"> * configAttributes是被拦截URI对应的权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException,</span></span><br><span class="line"><span class="function">InsufficientAuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回true表示此类失效</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decide()方法参数介绍：</p><ol><li><code>authentication</code>是从SecurityContext中拿到的当前用户信息，里面包含用户拥有的权限</li><li><code>object</code>代表被拦截URI</li><li><code>configAttributes</code>是<code>FilterInvocationSecurityMetadataSource.getAttributes()</code>返回的，代表被拦截URI所需权限</li></ol><p>FilterInvocationSecurityMetadataSource.getAttributes()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Collection&lt;ConfigAttribute&gt; <span class="title">getAttributes</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br></pre></td></tr></table></figure><p><code>getAttributes()</code>方法返回一个<code>Collection&lt;ConfigAttribute&gt;</code>对象，ConfigAttribute是个接口，一般使用它的实现类<code>SecurityConfig</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigAttribute</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回表示权限的String</span></span><br><span class="line"><span class="function">String <span class="title">getAttribute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>Collection&lt;ConfigAttribute&gt;</code>是不是和认证流程中提到的<code>Collection&lt;GrantedAuthority&gt;</code>很像？它们都是权限字符串的集合，区别在于前者是被拦截URI的权限集合，后者是用户拥有的权限集合。</p><h2 id="ExceptionTranslationFilter"><a href="#ExceptionTranslationFilter" class="headerlink" title="ExceptionTranslationFilter"></a>ExceptionTranslationFilter</h2><p>ExceptionTranslationFilter在Security过滤器链中放在FilterSecurityInterceptor前一位，但它可以捕获过滤器链中，甚至过滤器链之后的，任一个Filter抛出的异常，这其中就包括FilterSecurityInterceptor抛出的异常。这是因为，它在doFilter方法中，把<code>chain.doFilter(request, response);</code>整个try-catch了。</p><p>虽然它捕获了过滤器链中所有类型的异常，但它只处理两种异常：<code>AuthenticationException</code>和<code>AccessDeniedException</code>，其它的异常它会继续抛出。</p><p>若异常为<code>AuthenticationException</code>，它会调用<code>AuthenticationEntryPoint.commence()</code>处理。一般的做法是重定向到登录页。若异常为<code>AccessDeniedException</code>，它分两种情况，若用户未登录，它调用<code>AuthenticationEntryPoint.commence()</code>处理；若用户已登录但无权限，它调用<code>AccessDeniedHandler.handle()</code>处理。</p><p>值得一提的是，在认证过程中抛出的<code>AuthenticationException</code>由<code>UsernamePasswordAuthenticationFilter</code>自己处理后返回，不会进入ExceptionTranslationFilter。即<strong>只有授权时抛出的异常会由它处理</strong>。</p><h2 id="自定义实现思路-1"><a href="#自定义实现思路-1" class="headerlink" title="自定义实现思路"></a>自定义实现思路</h2><ol><li>自定义<code>AccessDecisionManager.decide()</code>，实现自己的授权逻辑，比如直接判断用户权限是否包含此URI，而不是用Security提供的投票方式</li><li>自定义<code>FilterInvocationSecurityMetadataSource.getAttributes()</code>，实现自己的查找URI所需权限的方式，如从数据库查找</li><li>自定义ExceptionTranslationFilter处理异常的方法，<code>AuthenticationEntryPoint.commence()</code>和<code>AccessDeniedHandler.handle()</code></li></ol><p>以上自定义可以实现基本的授权需求，更高级的需要查阅其他资料。</p><h2 id="自定义实现示例-1"><a href="#自定义实现示例-1" class="headerlink" title="自定义实现示例"></a>自定义实现示例</h2><p>配置示例（只写出与授权有关的部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">http</span><br><span class="line">.authorizeRequests()</span><br><span class="line">.anyRequest().authenticated() <span class="comment">// 所有请求都需要认证授权</span></span><br><span class="line">.withObjectPostProcessor(<span class="keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123; <span class="comment">// 设置FilterSecurityInterceptor属性</span></span><br><span class="line"><span class="keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="function">O <span class="title">postProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">O fsi)</span> </span>&#123;</span><br><span class="line">fsi.setAccessDecisionManager(<span class="keyword">new</span> CustomAccessDecisionManager()); <span class="comment">// 自定义AccessDecisionManager</span></span><br><span class="line">fsi.setSecurityMetadataSource(<span class="keyword">new</span> CustomFilterInvocationSecurityMetadataSource()); <span class="comment">// 自定义FilterInvocationSecurityMetadataSource</span></span><br><span class="line"><span class="keyword">return</span> fsi;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.and()</span><br><span class="line">.exceptionHandling() <span class="comment">// 以下两行设置ExceptionTranslationFilter属性</span></span><br><span class="line">.accessDeniedHandler(<span class="keyword">new</span> CustomAccessDeniedHandler()) <span class="comment">// 自定义AccessDeniedHandler</span></span><br><span class="line">.authenticationEntryPoint(<span class="keyword">new</span> CustomAuthenticationEntryPoint()) <span class="comment">// 自定义AuthenticationEntryPoint</span></span><br><span class="line">.and()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义AccessDecisionManager示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAccessDecisionManager</span> <span class="keyword">implements</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// authentication是从spring的全局缓存SecurityContextHolder中拿到的，里面是用户的权限信息(权限编码)</span></span><br><span class="line"><span class="comment">// object是被拦截URI</span></span><br><span class="line"><span class="comment">// configAttributes是被拦截URI对应的权限(权限编码)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"=========================AccessDecisionManager=============================="</span>);</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(configAttributes)) &#123; <span class="comment">// 被拦截URI所需权限为空，直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br><span class="line"><span class="comment">// 简单的判断用户权限中是否包含URI权限</span></span><br><span class="line"><span class="keyword">for</span> (ConfigAttribute attr : configAttributes) &#123;</span><br><span class="line">String attribute = attr.getAttribute();</span><br><span class="line"><span class="keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">String authority2 = authority.getAuthority();</span><br><span class="line"><span class="keyword">if</span> (authority2.equals(attribute)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(<span class="string">"无权访问"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h1><p>在Security配置类<code>WebSecurityConfigurerAdapter</code>的初始化方法中，会给<code>HttpSecurity</code>设置一些过滤器。这个动作在执行我们重写的<code>configure()</code>方法之前。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> HttpSecurity <span class="title">getHttp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!disableDefaults) &#123; <span class="comment">// 启用默认配置</span></span><br><span class="line">http</span><br><span class="line">.csrf().and() <span class="comment">// 4.CsrfFilter</span></span><br><span class="line">.addFilter(<span class="keyword">new</span> WebAsyncManagerIntegrationFilter()) <span class="comment">// 1.WebAsyncManagerIntegrationFilter</span></span><br><span class="line">.exceptionHandling().and() <span class="comment">//11.ExceptionTranslationFilter</span></span><br><span class="line">.headers().and() <span class="comment">// 3.HeaderWriterFilter</span></span><br><span class="line">.sessionManagement().and() <span class="comment">// 10.SessionManagementFilter</span></span><br><span class="line">.securityContext().and() <span class="comment">// 2.SecurityContextPersistenceFilter</span></span><br><span class="line">.requestCache().and() <span class="comment">//7.RequestCacheAwareFilter</span></span><br><span class="line">.anonymous().and() <span class="comment">// 9.AnonymousAuthenticationFilter</span></span><br><span class="line">.servletApi().and() <span class="comment">// 8.SecurityContextHolderAwareRequestFilter</span></span><br><span class="line">.apply(<span class="keyword">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and()</span><br><span class="line">.logout(); <span class="comment">// 5.LogoutFilter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面展示的部分源码，作用主要是注册了10个Filter，数字代表它们在过滤器链中的顺序。这些过滤器的顺序是在<code>FilterComparator</code>类中定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FilterComparator() &#123;</span><br><span class="line"><span class="keyword">int</span> order = <span class="number">100</span>;</span><br><span class="line">put(ChannelProcessingFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line">order += STEP;</span><br><span class="line">put(ConcurrentSessionFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line">order += STEP;</span><br><span class="line">put(WebAsyncManagerIntegrationFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line">order += STEP;</span><br><span class="line">put(SecurityContextPersistenceFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line">order += STEP;</span><br><span class="line">put(HeaderWriterFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line"><span class="comment">// 太多了，其余略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那在我们什么配置都没有的情况下，<code>UsernamePasswordAuthenticationFilter</code>是在哪里注册并起作用的？<br>在默认的<code>WebSecurityConfigurerAdapter.configure()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">http</span><br><span class="line">.authorizeRequests()</span><br><span class="line">.anyRequest().authenticated()</span><br><span class="line">.and()</span><br><span class="line">.formLogin().and() <span class="comment">// UsernamePasswordAuthenticationFilter</span></span><br><span class="line">.httpBasic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一行<code>formLogin()</code>，工作包括初始化UsernamePasswordAuthenticationFilter，并设置其成员变量<code>requiresAuthenticationRequestMatcher=POST /login</code>，这个成员变量就代表登录提交URI loginProcessingUrl，即要进入认证流程的URI。</p><p><strong>注意：</strong>Spring Security的这一整套过滤器，是以<strong>一个过滤器的身份</strong>被添加到<code>ApplicationFilterChain</code>中。ApplicationFilterChain就是Tomcat整理的过滤器链。这“一个过滤器”名叫“SpringSecurityFilterChain”。若我们自定义Filter没有添加到Security过滤器链中，这个Filter会排在Security过滤器链之后，即执行完Security所有过滤器后才会执行到这个Filter。</p><p>像下面这个自定义Filter就是没有加入到Security过滤器链中，只是加入了ApplicationFilterChain：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何把自定义Filter添加到Security过滤器链中？下面说明。</p><h2 id="添加自定义过滤器"><a href="#添加自定义过滤器" class="headerlink" title="添加自定义过滤器"></a>添加自定义过滤器</h2><p>想在Security的过滤器链中的某个位置加入自定义过滤器，可以使用HttpSecurity的3种方法：</p><ol><li>addFilterBefore(Filter filter, Class&lt;? extends Filter&gt; beforeFilter)</li><li>addFilterAfter(Filter filter, Class&lt;? extends Filter&gt; afterFilter)</li><li>addFilterAt(Filter filter, Class&lt;? extends Filter&gt; atFilter)</li></ol><p>这3个方法的前一个参数就是自定义Filter对象，后一个表示自定义Filter要放在哪个默认Filter的前面，或者后面，或者就放在默认Filter所在位置。</p><p>下面这个例子表示把自定义Filter放在UsernamePasswordAuthenticationFilter的前一个位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterBefore(<span class="keyword">new</span> BeforeLoginFilter(), UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure><p>有一个问题，若使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterAt(<span class="keyword">new</span> AtLoginFilter(), UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure><p>AtLoginFilter是在UsernamePasswordAuthenticationFilter的前面还是后面，还是把UsernamePasswordAuthenticationFilter覆盖？</p><p>答案是addFilterAt()不会覆盖UsernamePasswordAuthenticationFilter，且在它之前。具体原因是，<code>HttpSecurity</code>会用一个<code>List&lt;Filter&gt;</code>保存系统中所有自定义和默认的Filter，<strong>自定义过滤器是先于大部分默认过滤器被加入到List中的</strong>。在放入的同时，自定义Filter会被<code>FilterComparator</code>安排一个序号，这个序号等于UsernamePasswordAuthenticationFilter的序号。Spring在初始化过滤器链时，调用<code>HttpSecurity.performBuild()</code>方法，方法中使用FilterComparator对List中元素进行排序，<strong>序号一致的维持原序</strong>。因此使用addFilterAt()时，自定义Filter会在默认Filter之前。</p><h1 id="permitAll"><a href="#permitAll" class="headerlink" title="permitAll()"></a>permitAll()</h1><p>我在参考官方文档配置Spring Security时，看到两个<code>permitAll()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">.authorizeRequests()</span><br><span class="line">.antMatchers(<span class="string">"/favicon.ico"</span>).permitAll() <span class="comment">// 1</span></span><br><span class="line">.and()</span><br><span class="line">.formLogin()</span><br><span class="line">.permitAll()<span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>第一个permitAll是<code>ExpressionUrlAuthorizationConfigurer.AuthorizedUrl.permitAll()</code>，第二个是<code>FormLoginConfigurer&lt;HttpSecurity&gt;.permitAll()</code>。它们的作用都是，把这些指定的URI的权限字符串设置为“permitAll”，表示允许任何用户访问这些指定的URI，即这些URI无需权限访问，即使用户未登录。</p><p>第一个指定URI是自己添加的，第二个指定的URI是认证过程中会用到的loginPage、loginProcessingUrl、failureUrl这三个URI，它们有默认值。</p><p>无论使用哪个permitAll，这些URI最后会被添加到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfigAttributeRequestMatcherRegistry</span>&lt;<span class="title">C</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class"><span class="title">AbstractRequestMatcherRegistry</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// URI和对应权限保存在此变量</span></span><br><span class="line"><span class="keyword">private</span> List&lt;UrlMapping&gt; urlMappings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlMapping</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> RequestMatcher requestMatcher; <span class="comment">// URI</span></span><br><span class="line"><span class="keyword">private</span> Collection&lt;ConfigAttribute&gt; configAttrs; <span class="comment">// URI对应权限</span></span><br><span class="line"></span><br><span class="line">UrlMapping(RequestMatcher requestMatcher, Collection&lt;ConfigAttribute&gt; configAttrs) &#123;</span><br><span class="line"><span class="keyword">this</span>.requestMatcher = requestMatcher;</span><br><span class="line"><span class="keyword">this</span>.configAttrs = configAttrs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestMatcher <span class="title">getRequestMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> requestMatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getConfigAttrs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> configAttrs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些URI保存后，在创建<code>ExpressionBasedFilterInvocationSecurityMetadataSource</code>时会被取出。这个类是Spring在授权时默认使用的<code>FilterInvocationSecurityMetadataSource</code>实现类。</p><p>被取出时的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfigAttributeRequestMatcherRegistry</span>&lt;<span class="title">C</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class"><span class="title">AbstractRequestMatcherRegistry</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; createRequestMap() &#123;</span><br><span class="line"></span><br><span class="line">LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; requestMap = <span class="keyword">new</span> LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (UrlMapping mapping : getUrlMappings()) &#123;</span><br><span class="line">RequestMatcher matcher = mapping.getRequestMatcher();</span><br><span class="line">Collection&lt;ConfigAttribute&gt; configAttrs = mapping.getConfigAttrs();</span><br><span class="line">requestMap.put(matcher, configAttrs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> requestMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出后被封装为<code>LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt;</code>类型，保存了原本在List中的顺序，赋值给<code>ExpressionBasedFilterInvocationSecurityMetadataSource</code>的成员变量<code>requestMap</code>。</p><p>在Spring默认配置的授权流程中，有请求访问这些URI时，只要不是会进入认证过程的<code>POST loginProcessingUrl</code>，就会进入<code>FilterSecurityInterceptor</code>。FilterSecurityInterceptor调用<code>ExpressionBasedFilterInvocationSecurityMetadataSource.getAttribute()</code>方法，得到这些URI的权限字符串是“permitAll”，再通过<code>AccessDecisionManager.decide()</code>决定此URI允许访问（默认调用AffirmativeBased）。因此无论用户是否登录、是否有权限，都可访问此URI。</p><p>由于这些permitAll()方法是在Spring默认实现的AccessDecisionManager.decide()中起作用，若我们自定义的AccessDecisionManager.decide()不会使用“permitAll”权限字符串，则可以不用设置。</p><h1 id="WebSecurity"><a href="#WebSecurity" class="headerlink" title="WebSecurity"></a>WebSecurity</h1><p>WebSecurity一般用来设置不想被Security拦截的静态资源URI。如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">web.ignoring().antMatchers(<span class="string">"/css/**"</span>, <span class="string">"/webjars/**"</span>, <span class="string">"/img/**"</span>, <span class="string">"/js/**"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些URI会跳过Security的过滤器链，但不会跳过在Security过滤器链之后的Filter。</p><h1 id="Security保存登录用户信息原理"><a href="#Security保存登录用户信息原理" class="headerlink" title="Security保存登录用户信息原理"></a>Security保存登录用户信息原理</h1><p>在“授权”过程中我们提到，FilterSecurityInterceptor 通过 SecurityContext.getAuthentication() 取得当前用户的权限信息来做访问权限校验。那么在用户登录后的每次请求中，SecurityContext 如何准确获取该用户的认证信息？</p><p>首先说明， 在一次请求线程中，SecurityContext 整个对象都是是通过<code>SecurityContextHolder</code>来存取的。在默认配置下，SecurityContextHolder 用<code>ThreadLocal&lt;SecurityContext&gt; contextHolder</code>存储 SecurityContext 对象，使得该对象在一次请求中都有效且无线程安全问题。这个存储方式可配置修改，也可自定义，具体见 SecurityContextHolder 类源码。</p><p>那么请求结束后，线程销毁，SecurityContextHolder 如何在用户下一次请求时还能取得该对象？答案在 Security 过滤器 SecurityContextPersistenceFilter 中，这个过滤器在过滤器链中排第二。</p><p>SecurityContextPersistenceFilter 部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityContextPersistenceFilter</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SecurityContextRepository repo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="keyword">null</span>) &#123; <span class="comment">// 这是为了控制该过滤器只走一次</span></span><br><span class="line"><span class="comment">// ensure that filter is only applied once per request</span></span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (forceEagerSessionCreation) &#123; <span class="comment">// 这个值默认false，起个预读取session的作用</span></span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line"><span class="keyword">if</span> (debug &amp;&amp; session.isNew()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Eagerly created session: "</span> + session.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HttpRequestResponseHolder holder = <span class="keyword">new</span> HttpRequestResponseHolder(request, response);</span><br><span class="line"><span class="comment">// 这一步就是从session中取SecurityContext对象，如果取不到会创建一个空对象</span></span><br><span class="line">SecurityContext contextBeforeChainExecution = repo.loadContext(holder);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 把从session中取的SecurityContext对象保存到SecurityContextHolder中</span></span><br><span class="line">SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line"><span class="comment">// 执行后面的过滤器</span></span><br><span class="line">chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后面所有过滤器执行完且程序也处理完请求后，回到这里</span></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 这次请求过后的SecurityContext对象</span></span><br><span class="line">SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();</span><br><span class="line"><span class="comment">// 清除threadLocal</span></span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line"><span class="comment">// 把新的SecurityContext对象保存到session</span></span><br><span class="line">repo.saveContext(contextAfterChainExecution, holder.getRequest(),</span><br><span class="line">holder.getResponse());</span><br><span class="line"></span><br><span class="line">request.removeAttribute(FILTER_APPLIED);</span><br><span class="line"><span class="keyword">if</span> (debug) &#123;</span><br><span class="line">logger.debug(<span class="string">"SecurityContextHolder now cleared, as request processing completed"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个过滤器中可以看到，Security在每次请求过后，把用户的 SecurityContext 对象保存在 HttpSession 中。下一次用户请求中会带着<code>Cookie:JSESSIONID=xxxx</code>过来，Security 就能找到这个用户的 SecurityContext 对象了。</p><blockquote><p>如果用户禁用了Cookie，要怎么实现这个功能呢？<br>用户禁用了cookie也不妨碍我们使用session，关键是要拿到JSESSIONID。网上有教程介绍禁用cookie继续使用session的方法，一种方法就是把JSESSIONID放在每个URL之后。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java Web 流处理笔记</title>
      <link href="/2020/08/01/java-web-stream-note/"/>
      <url>/2020/08/01/java-web-stream-note/</url>
      
        <content type="html"><![CDATA[<h1 id="不同ContentType的请求流读取方式"><a href="#不同ContentType的请求流读取方式" class="headerlink" title="不同ContentType的请求流读取方式"></a>不同ContentType的请求流读取方式</h1><p>读取请求流一般就用这三种方式：</p><ol><li>request.getInputStream()</li><li>request.getReader()</li><li>request.getParameterNames()/request.getParameterMap()/request.getParameter(key)</li></ol><blockquote><p>记住，流只能读取一次。</p></blockquote><p>其中，<code>request.getInputStream()</code>和<code>request.getReader()</code>适用：</p><ul><li>GET application/x-www-form-urlencoded</li><li>POST application/json</li></ul><p>不适用：</p><ul><li>GET URI参数</li><li>POST application/x-www-form-urlencoded</li></ul><p><code>request.getParameter</code>的适用场景刚好相反。</p><p>示例代码：<br><code>request.getInputStream()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/is"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">is</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">String result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(request.getInputStream());</span><br><span class="line"><span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line"><span class="keyword">while</span> ((len = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">out.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">result = out.toString();</span><br><span class="line">System.out.println(result); <span class="comment">// 打印请求内容</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(result))&#123; <span class="comment">// 读不到就返回500</span></span><br><span class="line">response.setStatus(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">response.setStatus(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>request.getReader()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/reader"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">String result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">BufferedReader reader = request.getReader();</span><br><span class="line">StringWriter writer = <span class="keyword">new</span> StringWriter();</span><br><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((count = reader.read(chars)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">writer.write(chars, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br><span class="line">result = writer.toString();</span><br><span class="line">System.out.println(result); <span class="comment">// 打印请求内容</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(result))&#123; <span class="comment">// 读不到就返回500</span></span><br><span class="line">response.setStatus(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">response.setStatus(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>request.getParameterMap()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/param"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">param</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">String result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">Set&lt;Map.Entry&lt;String, String[]&gt;&gt; entrySet = parameterMap.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String[]&gt; entry : entrySet) &#123;</span><br><span class="line">String key = entry.getKey();</span><br><span class="line">String value = Arrays.toString(entry.getValue());</span><br><span class="line">result += key + <span class="string">"="</span> + value + <span class="string">"&amp;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result); <span class="comment">// 打印请求内容</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(result))&#123; <span class="comment">// 读不到就返回500</span></span><br><span class="line">response.setStatus(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">response.setStatus(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包装请求流"><a href="#包装请求流" class="headerlink" title="包装请求流"></a>包装请求流</h1><p>我们经常要在Filter或Interceptor中提前处理请求，如果在这里读了请求流，会导致后面的Controller读不到任何请求参数。为了解决“流只能读取一次”的问题，我们需要一个<code>HttpServletRequestWrapper</code>。<br>HttpServletRequestWrapper示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String[]&gt; parameterMap = <span class="keyword">new</span> HashMap&lt;String, String[]&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String bodyString;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHttpServletRequestWrapper</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(request);</span><br><span class="line"><span class="comment">// 读请求流</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(request.getInputStream());</span><br><span class="line"><span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line"><span class="keyword">while</span> ((len = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">out.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">body = out.toByteArray(); <span class="comment">// 把请求体保存在body</span></span><br><span class="line">bodyString = <span class="keyword">new</span> String(body, StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用getInputStream没读到请求体，改用getParameterMap读</span></span><br><span class="line"><span class="keyword">if</span>(body.length == <span class="number">0</span>) &#123;</span><br><span class="line">parameterMap.putAll(request.getParameterMap());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(body);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ServletInputStream() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bais.read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReadListener</span><span class="params">(ReadListener readListener)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BufferedReader <span class="title">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(getInputStream()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">String[] values = <span class="keyword">this</span>.parameterMap.get(name);</span><br><span class="line"><span class="keyword">if</span>(values != <span class="keyword">null</span> &amp; values.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> values[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.parameterMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;(parameterMap.keySet());</span><br><span class="line"><span class="keyword">return</span> vector.elements();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBodyString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bodyString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBodyString</span><span class="params">(String bodyString)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.bodyString = bodyString;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了上面这个包装类的Filter示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@WebFilter</span>(urlPatterns = &#123;<span class="string">"/*"</span>&#125;) <span class="comment">// 拦截URI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">        HttpServletResponse httpServletResponse = (HttpServletResponse) response;</span><br><span class="line">        </span><br><span class="line">        MyHttpServletRequestWrapper requestWrapper = <span class="keyword">new</span> MyHttpServletRequestWrapper(httpServletRequest);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"请求URI: "</span> + httpServletRequest.getRequestURI());</span><br><span class="line">        System.out.println(<span class="string">"请求参数: "</span> + requestWrapper.getBodyString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把原生的httpServletRequest换成requestWrapper传给Controller</span></span><br><span class="line">        chain.doFilter(requestWrapper, httpServletResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Zuul网关包装请求流"><a href="#Zuul网关包装请求流" class="headerlink" title="Zuul网关包装请求流"></a>Zuul网关包装请求流</h2><p>Spring Cloud的组件Zuul网关的一大功能就是可以由我们自定义一串Filter链，在这些Filter中也会需要读请求流。为了在每个Filter以及网关后面的服务能重复读取请求流，是否要在Zuul网关实现一个<code>HttpServletRequestWrapper</code>？Zuul已经帮我们实现好了。</p><p>到达网关的请求一定会经过<code>Servlet30WrapperFilter</code>，在这个Filter中，会把请求封装到<code>Servlet30RequestWrapper</code>，它是<code>HttpServletRequestWrapper</code>的实现类。</p><p><code>Servlet30WrapperFilter</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet30WrapperFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Field requestField = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Servlet30WrapperFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.requestField = ReflectionUtils.findField(HttpServletRequestWrapper<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">"req", HttpServletRequest.class);</span><br><span class="line">Assert.notNull(<span class="keyword">this</span>.requestField,</span><br><span class="line"><span class="string">"HttpServletRequestWrapper.req field not found"</span>);</span><br><span class="line"><span class="keyword">this</span>.requestField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Field <span class="title">getRequestField</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.requestField;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> PRE_TYPE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SERVLET_30_WRAPPER_FILTER_ORDER; <span class="comment">// -2，值越小优先级越高</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// <span class="doctag">TODO:</span> only if in servlet 3.0 env</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">HttpServletRequest request = ctx.getRequest();</span><br><span class="line"><span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequestWrapper) &#123;</span><br><span class="line">request = (HttpServletRequest) ReflectionUtils.getField(<span class="keyword">this</span>.requestField,</span><br><span class="line">request);</span><br><span class="line">ctx.setRequest(<span class="keyword">new</span> Servlet30RequestWrapper(request)); <span class="comment">// 用wrapper封装</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RequestUtils.isDispatcherServletRequest()) &#123;</span><br><span class="line"><span class="comment">// If it's going through the dispatcher we need to buffer the body</span></span><br><span class="line">ctx.setRequest(<span class="keyword">new</span> Servlet30RequestWrapper(request)); <span class="comment">// 用wrapper封装</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在自定义Filter中，用下面两行代码获取HTTP请求时，请求的类型就是<code>Servlet30RequestWrapper</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">HttpServletRequest request = ctx.getRequest(); <span class="comment">// Servlet30RequestWrapper类型</span></span><br></pre></td></tr></table></figure><h1 id="上传文件接口的请求流"><a href="#上传文件接口的请求流" class="headerlink" title="上传文件接口的请求流"></a>上传文件接口的请求流</h1><p>WEB项目中经常要实现文件上传，这就涉及到文件流的处理。下面一段代码展示了如何接受文件并保存在本地。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/upload"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(MultipartFile file, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 除了文件以外的请求字段</span></span><br><span class="line">String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">String type = request.getParameter(<span class="string">"type"</span>);</span><br><span class="line">System.out.println(<span class="string">"name="</span> + name);</span><br><span class="line">System.out.println(<span class="string">"type="</span> + type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件保存到本地</span></span><br><span class="line">OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">InputStream is = <span class="keyword">null</span>;</span><br><span class="line">String fileName = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">is = file.getInputStream();</span><br><span class="line">fileName = file.getOriginalFilename();</span><br><span class="line">String path = <span class="string">"D:\\test\\"</span>;</span><br><span class="line"><span class="comment">// 1K的数据缓冲</span></span><br><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// 读取到的数据长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">// 输出的文件流保存到本地文件</span></span><br><span class="line">File tempFile = <span class="keyword">new</span> File(path);</span><br><span class="line"><span class="keyword">if</span> (!tempFile.exists()) &#123;</span><br><span class="line">tempFile.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">os = <span class="keyword">new</span> FileOutputStream(tempFile.getPath() + File.separator + fileName);</span><br><span class="line"><span class="keyword">while</span> ((len = is.read(bs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">os.write(bs, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="string">"fail"</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 完毕，关闭所有链接</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">is.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">os.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用Postman测试该接口时，Body中Content-Type选择<code>form-data</code>。</p></blockquote><h1 id="复制InputStream"><a href="#复制InputStream" class="headerlink" title="复制InputStream"></a>复制InputStream</h1><p>如何把一个inputStream复制成多份？需要借助<code>ByteArrayInputStream/OutputStream</code>。<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InputStream input =  httpconn.getInputStream();</span><br><span class="line">  </span><br><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();  </span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line"><span class="keyword">int</span> len;  </span><br><span class="line"><span class="keyword">while</span> ((len = input.read(buffer)) &gt; -<span class="number">1</span> ) &#123;  </span><br><span class="line">baos.write(buffer, <span class="number">0</span>, len);  </span><br><span class="line">&#125;</span><br><span class="line">baos.flush();</span><br><span class="line"><span class="comment">// 复制</span></span><br><span class="line">InputStream stream1 = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">InputStream stream2 = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br></pre></td></tr></table></figure><h1 id="附：流基本方法"><a href="#附：流基本方法" class="headerlink" title="附：流基本方法"></a>附：流基本方法</h1><p><strong>输入流读取数据，输出流写入数据</strong>。所以下面的read方法都是InputStream的，write方法都是OutputStream的。</p><h2 id="一次读取-写入一个字节"><a href="#一次读取-写入一个字节" class="headerlink" title="一次读取/写入一个字节"></a>一次读取/写入一个字节</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br></pre></td></tr></table></figure><p>读取方法返回值int，代表从input读到的一个字节内容，可以按ASCII码转为char类型。写入方法的参数int则是要写入output的一个字节。尽管int类型数据最多可以是4个字节，但在流这里就被限制在了0~255之间。循环调用这两个读写方法可以达到读取/写入多个字节的效果，但效率低下，<strong>不建议使用</strong>。</p><h2 id="一次写入多个字节"><a href="#一次写入多个字节" class="headerlink" title="一次写入多个字节"></a>一次写入多个字节</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure><p>第一个方法是把字节数组<code>byte[] data</code>的内容全部写入output，第二个方法是指定字节数组从<code>offset</code>开始连续<code>length</code>长度的子数组的内容写入output。数据流向：byte[] -&gt; output<br>PS：如果使用BufferedOutputStream，往流中写数据时，数据会先存放在一个缓冲区，当缓冲区满了，数据才会被发送出去。最好调用<code>output.flush()</code>强制缓冲区发送数据。</p><h2 id="一次读取多个字节"><a href="#一次读取多个字节" class="headerlink" title="一次读取多个字节"></a>一次读取多个字节</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure><p>第一个方法是读取input填充到字节数组<code>byte[] data</code>，第二个方法是读取input填充到字节数组<code>byte[] data</code>从<code>offset</code>开始连续<code>length</code>长度的子数组。数据流向：input -&gt; byte[]</p><p>返回值int代表实际读取的字节数。如下面方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = input.read(bytes);</span><br></pre></td></tr></table></figure><p>上面两行代码尝试从输入流input中读取1024字节，但可能一次读取只读到512字节，因此len=512。<br>如果希望读取输入流input的全部内容，需要多次调用read方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line"><span class="keyword">while</span> ((len = input.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">output.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读不到内容时，len=-1，退出循环，此时输入流in的内容全部读完了。<br>上面代码表示，从输入流input中读取数据，可能一次全部读完，也可能只读出部分，读出的数据填充到bytes，再把bytes的数据写入输出流output，这个过程循环，直到input数据读完。数据流向：input -&gt; byte[] -&gt; output</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java HashMap原理·</title>
      <link href="/2020/07/08/java-hashmap/"/>
      <url>/2020/07/08/java-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Map接口实现类包括：HashMap、TreeMap、Hashtable、LinkedHashMap、ConcurrentHashMap。根据key的hashcode值来存储数据，可以根据key获取value。</p><p>实现类之间的区别：</p><ul><li><p>HashMap</p><ul><li>不保存每个元素的插入顺序，无序存放（存放顺序与key的hash值有关）</li><li>具有很快的访问速度</li><li>最多只允许一条记录的key值为null(多条会覆盖)</li><li>允许多条记录的value为null</li><li>非同步；非线程安全</li></ul></li><li><p>TreeMap</p><ul><li>是通过红黑树实现的</li><li>默认key升序排序存放，可以写Comparator接口改变排序方式</li><li>不允许key的值为null</li><li>非同步</li></ul></li><li><p>HashTable</p><ul><li>不允许key、value的值为null</li><li>同步；线程安全（很多方法加了synchronized锁）</li><li>由于引入了线程安全，处理效率没有HashMap高</li></ul></li><li><p>LinkedHashMap</p><ul><li>基于HashMap和双向链表，有序存放</li><li>具有很快的访问速度</li><li>最多只允许一条记录的key值为null(多条会覆盖)</li><li>允许多条记录的value为null</li><li>非同步；非线程安全</li></ul></li><li><p>ConcurrentHashMap</p><ul><li>线程安全，读写快，底层实现是一种以空间换时间的结构，创建的时候直接分了16个segment，每个segment实际上存储的还是HashTable，写入的时候先找到对应的segment，然后对segment加锁，写完，解锁。锁segment的时候其他segment还可以继续工作。</li><li>使用场景：当项目中的全局变量有多线程操作时需要用ConcurrentHashMap</li></ul></li></ul><p>下面重点介绍HashMap原理。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>JDK1.8之前，HashMap是数组+链表存储。JDK1.8及其之后，先用数组+链表，当链表长度&gt;=8时，就是数组+红黑树（原链表元素组成）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>; <span class="comment">// 数组默认长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1073741824</span>; <span class="comment">// 2^30, int最大值是2^31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75F</span>; <span class="comment">// 默认负载因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 当链表长度=8时，链表转为红黑树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>; <span class="comment">// 红黑树转为链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K, V&gt;[] table; <span class="comment">// 数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">// 元素总数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">// map被修改的次数，包括put、remove操作等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> threshold; <span class="comment">// threshold=数组长度*负载因子，初始值=16*0.75=12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line">Node&lt;K, V&gt; next;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">TreeNode&lt;K, V&gt; parent;</span><br><span class="line">TreeNode&lt;K, V&gt; left;</span><br><span class="line">TreeNode&lt;K, V&gt; right;</span><br><span class="line">TreeNode&lt;K, V&gt; prev;</span><br><span class="line"><span class="keyword">boolean</span> red;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Node</code>与<code>TreeNode</code>之间的继承关系： Map.Entry&lt;K, V&gt; –&gt; HashMap.Node&lt;K, V&gt; –&gt; LinkedHashMap.Entry&lt;K, V&gt; –&gt; HashMap.TreeNode&lt;K, V&gt; 。所以<code>Node</code>是<code>TreeNode</code>的间接父类。</p><p><strong>红黑树</strong>和MySQL索引结构<strong>B+树</strong>，都属于平衡二叉树。区别在于，红黑树一个节点只含一条数据，而B+树是B树的变种，B树一个节点含多条数据，用于查找的key和数据都在节点上，B+树的非叶子节点不再保存数据，而只保存key，叶子节点保存数据，并且所有的叶子节点按顺序使用链表进行连接。</p><p><strong>相关博客</strong>：<br>红黑树的规则和原理，包括左旋右旋：<a href="https://www.cnblogs.com/LiaHon/p/11203229.html" target="_blank" rel="noopener">https://www.cnblogs.com/LiaHon/p/11203229.html</a><br>负载因子0.75的作用：<a href="http://baijiahao.baidu.com/s?id=1656137152537394906&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1656137152537394906&amp;wfr=spider&amp;for=pc</a><br>HashMap部分源码：<a href="https://itimetraveler.github.io/2017/11/25/%E3%80%90Java%E3%80%91HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88JDK1.8%EF%BC%89/#get-%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">https://itimetraveler.github.io/2017/11/25/%E3%80%90Java%E3%80%91HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88JDK1.8%EF%BC%89/#get-%E6%96%B9%E6%B3%95</a></p><h1 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h1><p>put(key,value)时，HashMap先用key的hashcode计算出一个新的hash值，再用hash值和数组长度计算出一个<strong>数组下标</strong>。如果该数组位上为空，则直接添加key-value并返回NULL。如果该数组位上已经有元素，那么就遍历该数组位上的所有元素，比较要添加的key和现有元素是否相等，若相等就覆盖旧元素，并返回旧元素的value。若没有相等的，就直接添加进去。</p><p>向链表中添加元素时，用的是“尾插法”（JDK1.7中用的是“头插法”）。</p><p>比较key是否相同时，用的是equals方法，因为equals方法默认比较的是内存地址，所以如果用自定义类的对象做key，这个类需要重写equals方法。</p><p>关于hash值和数组下标的计算可以看这篇博客：<a href="https://www.cnblogs.com/eycuii/p/12015283.html" target="_blank" rel="noopener">https://www.cnblogs.com/eycuii/p/12015283.html</a> 。理解了hash值和数组下标的原理，我们可以回答一个常见的面试题：</p><blockquote><p>HashMap数组长度为什么都是2的k次方？</p></blockquote><p>首先，对于计算机来说，使用像左移、右移、与或非这样的<strong>位运算</strong>，效率比人类习惯的加减乘除以及取模更高，所以源码里计算数组下标都是用位运算。用位运算，就要把数组长度值转为二进制，任何数都能转为二进制，为什么偏偏指定2的k次方？因为计算数组下标时，公式是<code>i = hash &amp; (length - 1)</code>，当length=2^k时，length - 1就是在低k位连续分布的1，这样在做“与”运算时，能够完全利用hash的低k位的所有值，使得多个hash的“与”结果不同，达到了分散数组位的目的。</p><blockquote><p>(2^k) - 1 = 2^(k-1) + 2^(k-2) + … + 1，这是由等比数列求和公式得到的。</p></blockquote><p>put方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K paramK, V paramV)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (V) putVal(hash(paramK), paramK, paramV, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 数组为空（第一次put）</span></span><br><span class="line">n = (tab = resize()).length; <span class="comment">// 先扩容</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 该数组位无元素</span></span><br><span class="line">tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组位上已有元素p</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p.key和要添加的key相同</span></span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">e = p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p是红黑树</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="comment">// putTreeVal()方法会判断要添加的key是否已存在，已存在就覆盖旧节点并返回旧节点，不存在就直接添加节点并返回NULL</span></span><br><span class="line">e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他情况，如p是链表</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123; <span class="comment">// 死循环，目的是遍历链表</span></span><br><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">p.next = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 尾插法</span></span><br><span class="line"><span class="comment">// 当binCount&gt;=7，即链表长度为9时，链表改为红黑树</span></span><br><span class="line"><span class="comment">// 为什么是9？因为当binCount=0时，走到这步，链表节点已经有2个了</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) </span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// e = p.next, e.key和要添加的key相同</span></span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">p = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e为key相同的旧元素，返回e.value</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">V oldValue = e.value;</span><br><span class="line"><span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">e.value = value;</span><br><span class="line">afterNodeAccess(e);</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">++modCount;  <span class="comment">// 修改次数+1</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">resize(); <span class="comment">// size+1 &gt; threshold需要扩容</span></span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RESIZE"><a href="#RESIZE" class="headerlink" title="RESIZE"></a>RESIZE</h1><p>resize()方法为私有，调用点都在HashMap内部。具体在：</p><ol><li>put(key,value)，具体见上一节源码</li><li>new HashMap(map2)或putAll(map2)，批量添加map元素</li><li>put(key,value)中链表转红黑树时treeifyBin()方法</li><li>computeIfAbsent()方法内</li><li>compute()方法内</li><li>merge()方法内</li></ol><p>resize()方法是JDK1.8和1.7的区别比较大的地方。区别在于：</p><ol><li>JDK1.8引入了红黑树的处理</li><li>重新安排链表元素时，计算新下标的方式。虽然方式不同，但结果不变</li><li>元素插入链表的方式。1.7用头插法，1.8用尾插法</li></ol><p>下面借助两个版本的resize()源码讲讲这些区别。</p><p>JDK1.7的resize方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">Entry[] oldTable = table;</span><br><span class="line"><span class="keyword">int</span> oldCapacity = oldTable.length;  </span><br><span class="line"><span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">threshold = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">return</span>;  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">transfer(newTable); <span class="comment">// 在这个方法内重新安排元素</span></span><br><span class="line">table = newTable;</span><br><span class="line">threshold = (<span class="keyword">int</span>) (newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">Entry[] src = table;</span><br><span class="line"><span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">Entry&lt;K, V&gt; e = src[j];</span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">src[j] = <span class="keyword">null</span>; <span class="comment">// 释放旧Entry数组的对象引用。for循环后，旧数组不再引用任何对象</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">Entry&lt;K, V&gt; next = e.next;  </span><br><span class="line"><span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">// 计算新数组位，和put时一致</span></span><br><span class="line">e.next = newTable[i]; <span class="comment">// 头插法</span></span><br><span class="line">newTable[i] = e;</span><br><span class="line">e = next;</span><br><span class="line">&#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> h &amp; (length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8的resize方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// MAXIMUM_CAPACITY=2^30，这里if块内代码的意思是，如果oldCap已经达到MAXIMUM_CAPACITY，就不扩容，直接把扩容阈值threshold增加到int型最大值2^31</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class="comment">// newCap = oldCap * 2</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// newThr = oldThr * 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123; <span class="comment">// e为数组位上元素</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// e是单个元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// e是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// e是链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// 拆分链表的条件</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123; <span class="comment">// 当(e.hash &amp; oldCap) == 0，元素还在原数组位上</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123; <span class="comment">// 当(e.hash &amp; oldCap) == 1，元素在原数组位+oldCap上</span></span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区别一"><a href="#区别一" class="headerlink" title="区别一"></a>区别一</h2><p>区别1：JDK1.8引入了红黑树的处理。</p><p>在TreeNode.split()方法中，会把当前树拆分成两个子链表，然后判断两个子链表的节点数，节点数&lt;=6，就按照链表存储，否则转为红黑树，即“树化”。树化时，遍历树的所有节点的时间复杂度是O(n)，插入树节点的时间复杂度是O(logn)，所以创建红黑树的总时间是O(nlogn)。</p><p>顺便一提，resize处理链表时，是一边遍历一边插入，遍历链表的时间复杂度为O(n)，插入的时间复杂度是O(1)，所以创建链表的总时间是O(n)。</p><p>附上TreeNode.split()方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 分成高位树和低位树，头尾节点先声明</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆分当前树，先用链表存储</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123; <span class="comment">// 拆分条件</span></span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD) <span class="comment">// 节点数&lt;=6，转为链表节点Node</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>)</span><br><span class="line"> <span class="comment">// 树化。在这个方法中，会先新建一个空树，遍历loHead链表元素，添加树节点，最后把这个树放入数组tab中</span></span><br><span class="line">loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考：</strong><br>HashMap内部类TreeNode主要方法源码和解释：<a href="https://www.cnblogs.com/freeorange/p/10804332.html" target="_blank" rel="noopener">https://www.cnblogs.com/freeorange/p/10804332.html</a><br>红黑树的时间复杂度O(logn)的证明：<a href="https://blog.csdn.net/l_o_s/article/details/105703296" target="_blank" rel="noopener">https://blog.csdn.net/l_o_s/article/details/105703296</a> （红黑树查找、插入和删除操作的时间复杂度都是O(logn)）</p><h2 id="区别二"><a href="#区别二" class="headerlink" title="区别二"></a>区别二</h2><p>区别2：重新安排链表元素时，计算新下标的方式。虽然方式不同，但结果不变。</p><p>在1.7中，无论什么情况，新数组位 = e.hash &amp; (newCap - 1)。在1.8中，当只有一个元素时，新数组位的计算和1.7一致；当是链表元素时，新数组位只有“原下标”和“原下标+oldCap”两种位置，而具体是哪个位置，就看(e.hash &amp; oldCap)的值是否等于0。</p><p>乍一看，在1.8中重新安排链表元素时，因为只有两种选择，似乎会加大冲突概率。但实际上，这个做法和1.7的重新计算下标的结果，是完全一致的！！</p><p>我们举例看看在1.7中计算出的新下标的规律：</p><p>设：oldCap = 16, newCap = 32, key1.hash = 107 = (0110 1011), key2.hash = 123 = (0111 1011)<br>则，key1的原下标 = (key.hash) &amp; (oldCap - 1) = (0110 1011) &amp; (0000 1111) = (0000 1011) = 11<br>扩容后，key1的新下标 = (key.hash) &amp; (newCap - 1) = (0110 1011) &amp; (0001 1111) = (0000 1011) = 11</p><p>则，key2的原下标 = (key.hash) &amp; (oldCap - 1) = (0111 1011) &amp; (0000 1111) = (0000 1011) = 11<br>扩容后，key2的新下标 = (key.hash) &amp; (newCap - 1) = (0111 1011) &amp; (0001 1111) = (0001 1011) = 27 = 16 + 11</p><p>在1.7中，即使是重新计算下标，新下标依然只有两种结果：“原下标”和“原下标+oldCap”，这是因为(newCap - 1)只是比(oldCap - 1)多了一位高位1，这个高位1的值就等于oldCap（证明如下）。而这个高位1的值是否对“与”结果起作用，就是看与此高位1对应的key.hash的位上是0还是1，是1才起作用。这就和1.8的逻辑对应上了！</p><blockquote><p>(newCap - 1) - (oldCap - 1)<br>= (2^(k+1) - 1) - (2^k - 1)<br>= (1 + … + 2^(k-1) + 2^k) - (1 + … + 2^(k-1))<br>= 2^k<br>= oldCap</p></blockquote><p>所以，1.8并没有改变新下标的结果，只是代码写得更直接了。</p><h2 id="区别三"><a href="#区别三" class="headerlink" title="区别三"></a>区别三</h2><p>区别3：元素插入链表的方式。1.7用头插法，1.8用尾插法。</p><p>1.7的头插法是HashMap线程不安全的一个原因，简单来说就是多线程会造成环形链表导致死循环。</p><p>假设原HashMap：<br>table[0]=null<br>table[1]=(3,a)-&gt;(7,b)</p><p>当在多线程进行扩容时，<br>线程A遍历到元素(3,a)-&gt;(7,b)-&gt;null停止，<br>线程B开始执行到扩容后：table[3]=(7,b)-&gt;(3,a)-&gt;null（先遍历到的是(3,a)键值对，先插入到新位置的也是(3,a)，随后遍历到(7,b)，(7,b)的新位置也在table[3]，因为使用的是头插法，所以在(3,a)前面）<br>然后线程A继续执行，计算到(3,a)新位置在table[3]，把(3,a)插入table[3]的链表，而此时table[3]=(7,b)-&gt;(3,a)-&gt;null，导致table[3]=(3,a)&lt;=&gt;(7,b)，这两个元素互相指向，在遍历table[3]位置的链表时就会进入死循环。</p><p>这篇博客：<a href="https://www.cnblogs.com/developer_chan/p/10450908.html" target="_blank" rel="noopener">https://www.cnblogs.com/developer_chan/p/10450908.html</a> 中的<code>1.1 扩容造成死循环分析过程</code>用图片讲解，可参考。</p><p>因为改用了尾插法，所以1.8避免了1.7的环形链表的问题。但是，1.8的红黑树还是会出现死循环的情况，只是没人像1.7一样给出具体的过程，仅仅做了实验，实验博客：<a href="https://blog.csdn.net/gs_albb/article/details/88091808" target="_blank" rel="noopener">https://blog.csdn.net/gs_albb/article/details/88091808</a> 。</p><h1 id="1-8的优化"><a href="#1-8的优化" class="headerlink" title="1.8的优化"></a>1.8的优化</h1><p>从源码来看，JDK1.8优化的主要是查询性能，因为1.8不会出现过长的链表（都转为红黑树了~），时间复杂度由链表的O(n)降低为红黑树的O(logn)。扩容方法resize优化了环形链表的问题，但性能看不出优化。先说简单的，计算新下标时，1.7直接用位运算得出新下标，1.8除了位运算还有加法运算，不会比1.7更快。然后，正如在<code>区别一</code>中所述，创建红黑树的时间复杂度比创建链表要大，所以1.8的resize性能肯定不会比1.7好。</p><h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><p>JDK1.7和1.8都是线程不安全的，其中一个原因是扩容时会导致死循环，另一个原因是put方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 数组为空（第一次put）</span></span><br><span class="line">n = (tab = resize()).length; <span class="comment">// 先扩容</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 两个线程同时到达这里，只有一个线程能put成功，导致另一个线程的数据丢失</span></span><br><span class="line">tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="HashTable的线程安全"><a href="#HashTable的线程安全" class="headerlink" title="HashTable的线程安全"></a>HashTable的线程安全</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean的生命周期</title>
      <link href="/2020/06/13/spring-bean-lifecycle/"/>
      <url>/2020/06/13/spring-bean-lifecycle/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文从源码（SpringBoot 2.3.0版本）入手，学习教材上所说的Bean的生命周期的4个阶段：</p><ol><li>Bean定义</li><li>Bean初始化</li><li>Bean的生存期</li><li>Bean的销毁</li></ol><p>其中，Bean初始化阶段涉及的内容较多，如依赖注入，BeanPostProcessor、Aware接口的调用，比较复杂，这里先给个结论。</p><p>Bean初始化过程中的生命周期：</p><ol><li>调用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()</li><li>Bean实例化(Instantiation)</li><li>调用InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()</li><li>完成Bean的依赖注入，如HelloController依赖注入HelloServiceImpl，注入HelloService时会触发HelloService Bean的定义、初始化，因此这是一个递归过程</li><li>调用BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</li><li>调用每个BeanPostProcessor.postProcessBeforeInitialization()，当BeanPostProcessor=ApplicationContextAwareProcessor时，调用ApplicationContextAware.setApplicationContext()</li><li>调用InitializingBean.afterPropertiesSet()</li><li>调用@Bean的init-method方法</li><li>调用每个BeanPostProcessor.postProcessAfterInitialization()</li></ol><h1 id="Bean定义"><a href="#Bean定义" class="headerlink" title="Bean定义"></a>Bean定义</h1><p>在SpringBoot启动时，根据<code>@ComponentScan</code>指定的包路径（默认是当前包及其子包）扫描，把Bean的定义保存到IoC容器中。</p><p>SpringBoot Web应用使用的IoC容器为<code>AnnotationConfigServletWebServerApplicationContext</code>，这个容器包含一个属性：DefaultListableBeanFactory。<code>DefaultListableBeanFactory</code>是<code>BeanFactory</code>的实现类之一，它的作用就是保存bean定义和实例化bean。</p><p>在启动类SpringApplication.run()方法中，先确定使用的IoC容器为<code>AnnotationConfigServletWebServerApplicationContext</code>，然后调用此容器的refresh()方法，对<code>DefaultListableBeanFactory</code>进行配置，将Bean定义添加到<code>DefaultListableBeanFactory</code>的<code>beanDefinitionMap</code>中。</p><p>下面是主要的一些源码展示，这些方法间的调用链可以debug查看。</p><p>SpringApplication.run()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 指定IoC容器为AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">context = createApplicationContext(); </span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line"><span class="comment">// 刷新容器，调用了AnnotationConfigServletWebServerApplicationContext.refresh()方法</span></span><br><span class="line">refreshContext(context);</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassPathBeanDefinitionScanner.doScan()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123; <span class="comment">// basePackages=启动类所在包</span></span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); <span class="comment">// 所有Bean类的定义，如HelloController、HelloServiceImpl</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">definitionHolder =</span><br><span class="line">AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">beanDefinitions.add(definitionHolder);</span><br><span class="line">registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry); <span class="comment">// 把Bean的定义添加到this.registry=DefaultListableBeanFactory中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultListableBeanFactory部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAutowireCapableBeanFactory</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ConfigurableListableBeanFactory</span>, <span class="title">BeanDefinitionRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line"><span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition); <span class="comment">//添加Bean定义到beanDefinitionMap</span></span><br><span class="line">List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">removeManualSingletonName(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Still in startup registration phase</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition); <span class="comment">//添加Bean定义到beanDefinitionMap</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">removeManualSingletonName(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步，IoC容器中只有Bean的定义，还没有Bean的实例化对象。</p><h1 id="Bean初始化"><a href="#Bean初始化" class="headerlink" title="Bean初始化"></a>Bean初始化</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Bean的初始化阶段的主要工作，就是实例化Bean再初始化Bean，初始化过程中就包含依赖注入。</p><p>默认配置的、单例且非懒加载的Bean，会在Bean定义步骤完成后立即初始化。</p><p>入口在IoC容器基类<code>AbstractApplicationContext.finishBeanFactoryInitialization()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单例且非懒加载的bean，beanFactory=DefaultListableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要工作的是<code>AbstractAutowireCapableBeanFactory.doCreateBean()</code>方法，这个类是<code>DefaultListableBeanFactory</code>的基类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// bean实例化</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 下面两行都是bean的初始化</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面介绍Bean初始化阶段的详细过程。</p><h2 id="Bean实例化-Instantiation"><a href="#Bean实例化-Instantiation" class="headerlink" title="Bean实例化(Instantiation)"></a>Bean实例化(Instantiation)</h2><p>在<code>AbstractAutowireCapableBeanFactory.doCreateBean()</code>方法中，<code>createBeanInstance()</code>方法负责Bean的实例化，实例化后的bean对象的属性还是空的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 用bean的构造器创建bean对象，放在instanceWrapper内，此时bean对象的属性还是空的</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean初始化-Initialization"><a href="#Bean初始化-Initialization" class="headerlink" title="Bean初始化(Initialization)"></a>Bean初始化(Initialization)</h2><p>在<code>AbstractAutowireCapableBeanFactory.doCreateBean()</code>方法中，<code>populateBean()</code>方法和<code>initializeBean()</code>方法完成Bean的属性赋值（包括依赖注入），和Bean的一些扩展接口的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 下面两行都是bean的初始化</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper); <span class="comment">// 属性赋值，包括依赖注入</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);<span class="comment">// 调用Bean的一些扩展接口，如BeanPostProcessor接口和Aware接口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>populateBean()</code>方法中完成依赖注入，如把personServiceImpl注入到personController中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 稍微提一下，这里的autowired是@Bean注解的autowired属性值，不是bean的依赖属性上的@Autowired注解</span></span><br><span class="line"><span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="comment">// InstantiationAwareBeanPostProcessor接口是BeanPostProcessor接口的子类，下面会介绍</span></span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 当bp=AutowiredAnnotationBeanPostProcessor时，这步会注入bean的依赖，如把personServiceImpl注入到personController中</span></span><br><span class="line"> <span class="comment">// 在初始化personServiceImpl这个bean时，会递归调用到上面的doCreateBean()方法，且会递归把personMapper注入到personServiceImpl中</span></span><br><span class="line"> <span class="comment">// 因此整个注入是一个递归调用的过程</span></span><br><span class="line">PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line">pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pvs = pvsToUse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上大致介绍了Bean的初始化阶段的主要工作，即实例化Bean再依赖注入。但在这个阶段，还涉及到<code>BeanPostProcessor</code>接口和<code>*Aware</code>接口的调用。下面介绍这两类接口的作用和调用时机。</p><h2 id="调用扩展接口"><a href="#调用扩展接口" class="headerlink" title="调用扩展接口"></a>调用扩展接口</h2><h3 id="BeanPostProcessor接口"><a href="#BeanPostProcessor接口" class="headerlink" title="BeanPostProcessor接口"></a>BeanPostProcessor接口</h3><p>BeanPostProcessor是Spring IOC容器给我们提供的一个扩展接口。接口声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在Bean的 InitializingBean.afterPropertiesSet()方法或<span class="doctag">@Bean</span>(init-method)属性定义的方法 执行前被调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在Bean的 InitializingBean.afterPropertiesSet()方法或<span class="doctag">@Bean</span>(init-method)属性定义的方法 执行后被调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了BeanPostProcessor接口的类，被扫描进IoC容器后，在所有Bean的初始化前后都会被调用，即它对所有Bean都生效，有点像AOP。它有个子接口<code>InstantiationAwareBeanPostProcessor</code>。</p><h4 id="InstantiationAwareBeanPostProcessor接口"><a href="#InstantiationAwareBeanPostProcessor接口" class="headerlink" title="InstantiationAwareBeanPostProcessor接口"></a>InstantiationAwareBeanPostProcessor接口</h4><p><code>InstantiationAwareBeanPostProcessor</code>接口继承自<code>BeanPostProcessor</code>接口，它不仅继承了<code>BeanPostProcessor</code>接口会在Bean<strong>初始化</strong>前后调用的两个方法，还增加了会在Bean<strong>实例化</strong>前后调用的两个方法。所以这两个方法也在Bean的生命周期内。具体的调用时机在下面介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bean实例化前调用</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bean实例化后调用</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Aware接口"><a href="#Aware接口" class="headerlink" title="Aware接口"></a>Aware接口</h3><p>Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源，Aware之前的名字就是可以拿到什么资源，例如BeanNameAware可以拿到BeanName，以此类推。<br>比较常见的Aware接口有BeanNameAware、BeanFactoryAware、ApplicationContextAware。</p><h4 id="ApplicationContextAware接口"><a href="#ApplicationContextAware接口" class="headerlink" title="ApplicationContextAware接口"></a>ApplicationContextAware接口</h4><p>ApplicationContextAware接口可以用来获取ApplicationContext，即IoC容器。我们已知<code>ApplicationContext</code>包含<code>BeanFactory</code>接口的getBean()方法，因此我们在服务中可以借助它直接获取Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在项目中，经常遇到要随时获取Bean的情况，这时就可以写一个工具类解决：ApplicationContextUtil。这个工具类就是使用了ApplicationContextAware接口的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.context = applicationContext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过name获取 Bean.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> context.getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过class获取Bean.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> context.getBean(clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过name,以及Clazz返回指定的Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> context.getBean(name, clazz);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们定义的这个Bean，ApplicationContextUtil，它的setApplicationContext()方法是在何时被调用的？答案在下面“调用时机”一节中。</p><h3 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h3><h4 id="BeanFactory注册BeanPostProcessor接口"><a href="#BeanFactory注册BeanPostProcessor接口" class="headerlink" title="BeanFactory注册BeanPostProcessor接口"></a>BeanFactory注册BeanPostProcessor接口</h4><p>在AnnotationConfigServletWebServerApplicationContext.refresh()方法中（在Bean定义阶段中有提到），会给要使用的BeanFactory=DefaultListableBeanFactory注册BeanPostProcessor接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">/*省略其他代码*/</span></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">// 这里会添加几个指定的BeanPostProcessor</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">// 这里会注册自定义的BeanPostProcessor</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用BeanPostProcessor和Aware接口方法"><a href="#调用BeanPostProcessor和Aware接口方法" class="headerlink" title="调用BeanPostProcessor和Aware接口方法"></a>调用BeanPostProcessor和Aware接口方法</h4><p>在Bean初始化阶段的initializeBean()方法中，顺序调用了BeanPostProcessor和Aware接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean); <span class="comment">// 调用Aware接口方法，见下方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 执行每个BeanPostProcessor的postProcessBeforeInitialization()方法</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);<span class="comment">// 调用afterPropertiesSet()和init-method方法，见下方</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 执行每个BeanPostProcessor的postProcessAfterInitialization()方法</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断bean是否实现了BeanNameAware等接口的方法，若实现就调用</span></span><br><span class="line"><span class="comment">// ApplicationContextAware接口的调用不在这里，后面介绍</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">ClassLoader bcl = getBeanClassLoader();</span><br><span class="line"><span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断bean是否实现了InitializingBean接口，若实现就调用afterPropertiesSet()，然后反射调用init-method()方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line"><span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="keyword">throw</span> pae.getException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">String initMethodName = mbd.getInitMethodName();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">!(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看到，每初始化一个Bean。就会遍历调用所有的BeanPostProcessor接口方法，即BeanPostProcessor接口方法对所有Bean都有效。而Aware接口是由Bean自己实现的，初始化某个Bean时，会调用Bean自己的Aware接口方法，因此Aware接口方法只针对一个Bean有效。</p><h4 id="ApplicationContextAware接口的调用"><a href="#ApplicationContextAware接口的调用" class="headerlink" title="ApplicationContextAware接口的调用"></a>ApplicationContextAware接口的调用</h4><p>ApplicationContextAware接口的调用点如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean); <span class="comment">// 这里没有调用ApplicationContextAware</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 这里调用了ApplicationContextAware</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在applyBeanPostProcessorsBeforeInitialization()方法中，会遍历执行BeanFactory的所有<code>BeanPostProcessor.postProcessBeforeInitialization()</code>方法，当遍历到<code>ApplicationContextAwareProcessor.postProcessBeforeInitialization()</code>方法时，它的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (acc != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">invokeAwareInterfaces(bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, acc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeAwareInterfaces(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext); <span class="comment">// 当bean实现了ApplicationContextAware，调用setApplicationContext()方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于这个<code>ApplicationContextAwareProcessor</code>是何时添加到BeanFactory的，答案在上面介绍的“BeanFactory注册BeanPostProcessor接口”的prepareBeanFactory()方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InstantiationAwareBeanPostProcessor接口的调用"><a href="#InstantiationAwareBeanPostProcessor接口的调用" class="headerlink" title="InstantiationAwareBeanPostProcessor接口的调用"></a>InstantiationAwareBeanPostProcessor接口的调用</h4><p>介绍<code>InstantiationAwareBeanPostProcessor</code>接口时，提到它扩展的两个方法：postProcessBeforeInstantiation()、postProcessAfterInstantiation()，分别在Bean<strong>实例化</strong>前后调用。具体的调用点如下。</p><p>postProcessBeforeInstantiation()的调用点在<code>AbstractAutowireCapableBeanFactory.createBean()</code>，在doCreateBean()方法之前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line"><span class="comment">// 这里是调用点，见下方</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 可以看到，它的调用点在doCreateBean()之前，说明此时还没有实例化bean</span></span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hasInstantiationAwareBeanPostProcessors=true时，执行postProcessBeforeInstantiation()方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">Object bean = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line"><span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>postProcessAfterInstantiation()的调用点，是我们熟悉的populateBean()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在populateBean()方法最前，此时bean已实例化但还未依赖注入</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line"><span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean初始化阶段总结"><a href="#Bean初始化阶段总结" class="headerlink" title="Bean初始化阶段总结"></a>Bean初始化阶段总结</h2><p>在Bean初始化过程中的生命周期是这样的：</p><ol start="0"><li>BeanFactory注册BeanPostProcessor接口</li><li>调用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()</li><li>createBeanInstance()进行Bean实例化</li><li>populateBean()<ol><li>调用InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()</li><li>调用AutowiredAnnotationBeanPostProcessor.postProcessProperties()，完成依赖注入，是一个递归过程</li></ol></li><li>initializeBean()<ol><li>调用BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</li><li>调用每个BeanPostProcessor.postProcessBeforeInitialization()，当BeanPostProcessor=ApplicationContextAwareProcessor时，调用ApplicationContextAware.setApplicationContext()</li><li>调用InitializingBean.afterPropertiesSet()</li><li>调用@Bean的init-method方法</li><li>调用每个BeanPostProcessor.postProcessAfterInitialization()</li></ol></li></ol><hr><p>可能有人会问，在Bean定义阶段使用的<code>DefaultListableBeanFactory</code>的成员变量<code>beanDefinitionMap</code>在Bean初始化阶段怎么没有出现？其实是出现了的。回顾<code>doCreateBean()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>第二个形参<code>RootBeanDefinition mbd</code>是从该方法的上上一层方法<code>AbstractBeanFactory.doGetBean()</code>传进来的：<br>【调用链是 AbstractBeanFactory.doGetBean() -&gt; AbstractAutowireCapableBeanFactory.createBean() -&gt; AbstractAutowireCapableBeanFactory.doCreateBean()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">createBean(beanName, mbd, args);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 其余略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>getMergedLocalBeanDefinition()</code>方法中，调用<code>DefaultListableBeanFactory.getBeanDefinition()</code>，从<code>beanDefinitionMap</code>中获得Bean定义信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedLocalBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">RootBeanDefinition mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; !mbd.stale) &#123;</span><br><span class="line"><span class="keyword">return</span> mbd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (bd == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"No bean named '"</span> + beanName + <span class="string">"' found in "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Bean的生存期"><a href="#Bean的生存期" class="headerlink" title="Bean的生存期"></a>Bean的生存期</h1><p>Bean的生存期就是SpringBoot程序启动后，我们使用Bean的过程，这里不介绍了。</p><h1 id="Bean的销毁"><a href="#Bean的销毁" class="headerlink" title="Bean的销毁"></a>Bean的销毁</h1><p>当 IoC 容器关闭时会对 Bean 进行销毁，此时会调用 Bean 的自定义销毁方法。</p><p><strong>注意：</strong>销毁方法内只做 Bean 销毁前要做的事，比如调用下 Bean 内成员的销毁方法，Bean 资源的释放还是由 JVM 完成。</p><h2 id="容器启动时记录定义了销毁方法的Bean"><a href="#容器启动时记录定义了销毁方法的Bean" class="headerlink" title="容器启动时记录定义了销毁方法的Bean"></a>容器启动时记录定义了销毁方法的Bean</h2><p>有以下3种方式来自定义 Bean 的销毁方法：</p><ol><li>实现 DisposableBean 接口</li><li>@Bean(destroyMethod=”xxx”)</li><li>@PreDestroy</li></ol><p>这3种方法的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"===================destroy person2 bean"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"===================destroy person bean"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person3</span> </span>&#123;</span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"===================destroy person3 bean"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它们注册为Bean的代码</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(destroyMethod = <span class="string">"destroy"</span>)</span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Person2 <span class="title">person2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Person3 <span class="title">person3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IoC容器启动时，在<code>AbstractAutowireCapableBeanFactory.doCreateBean()</code>方法中，完成当前 Bean 的初始化后（即调用完 initializeBean 方法后），会调用父类的<code>registerDisposableBeanIfNecessary</code>方法，判断当前 Bean 是否含自定义销毁方法，若有则记录在容器成员<code>Map&lt;String, Object&gt; disposableBeans</code>中。<br>这部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd); <span class="comment">// 调用父类方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDisposableBeanIfNecessary</span><span class="params">(String beanName, Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">       AccessControlContext acc = System.getSecurityManager() != <span class="keyword">null</span> ? <span class="keyword">this</span>.getAccessControlContext() : <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 当前Bean的作用域不是原型 且 this.requiresDestruction() = true</span></span><br><span class="line"><span class="comment">// 所以，作用域为原型的Bean，IoC容器不负责销毁</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isPrototype() &amp;&amp; <span class="keyword">this</span>.requiresDestruction(bean, mbd)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">// 单例Bean被包装成DisposableBeanAdapter添加到disposableBeans Map中</span></span><br><span class="line">               <span class="keyword">this</span>.registerDisposableBean(beanName, <span class="keyword">new</span> DisposableBeanAdapter(bean, beanName, mbd, <span class="keyword">this</span>.getBeanPostProcessors(), acc));</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               Scope scope = (Scope)<span class="keyword">this</span>.scopes.get(mbd.getScope());</span><br><span class="line">               <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + mbd.getScope() + <span class="string">"'"</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               scope.registerDestructionCallback(beanName, <span class="keyword">new</span> DisposableBeanAdapter(bean, beanName, mbd, <span class="keyword">this</span>.getBeanPostProcessors(), acc));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">requiresDestruction</span><span class="params">(Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> bean != <span class="keyword">null</span> &amp;&amp; (DisposableBeanAdapter.hasDestroyMethod(bean, mbd) || <span class="keyword">this</span>.hasDestructionAwareBeanPostProcessors() &amp;&amp; DisposableBeanAdapter.hasApplicableProcessors(bean, <span class="keyword">this</span>.getBeanPostProcessors()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>this.requiresDestruction() 方法就是用于判断一个 Bean 是否有自定义销毁方法，只要以下2个条件之一成立则返回 true：</p><ol><li>DisposableBeanAdapter.hasDestroyMethod() = true<ol><li>Bean 是否实现了 DisposableBean 或 AutoCloseable 接口；</li><li>若上条不符，那么是否指定 @Bean 注解的 destroyMethod 属性；</li><li>若上条不符，那么 Bean 类中是否有名为“close”或“shutdown”的方法。</li></ol></li><li>this.hasDestructionAwareBeanPostProcessors() &amp;&amp; DisposableBeanAdapter.hasApplicableProcessors() = true<br>容器中的 beanPostProcessorList 中有<code>DestructionAwareBeanPostProcessor</code>类型的 Bean，且它对当前 Bean 适用。</li></ol><p>第二个条件中的 DestructionAwareBeanPostProcessor 接口继承自 BeanPostProcessor，扩展了2个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DestructionAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用bean自定义销毁方法前要做的事</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeforeDestruction</span><span class="params">(Object var1, String var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="comment">// 对形参中的bean是否有效【这个方法返回true，才会调用上一个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">requiresDestruction</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么容器中有 DestructionAwareBeanPostProcessor 类型的 Bean 吗？有！在容器 refresh 时，添加了一个<code>ApplicationListenerDetector</code>Bean，它只对 ApplicationListener Bean 适用；还有一个 <code>CommonAnnotationBeanPostProcessor</code>，它对使用了 @PreDestroy 注解的 Bean 适用。</p><p>所以，当 Bean 使用了3种方法中的任一种（也可以同时用）自定义销毁方法，this.requiresDestruction() 方法就会返回 true，这个 Bean 会被包装成<code>DisposableBeanAdapter</code>添加到容器的 disposableBeans Map 中。</p><h2 id="容器关闭时调用Bean的销毁方法"><a href="#容器关闭时调用Bean的销毁方法" class="headerlink" title="容器关闭时调用Bean的销毁方法"></a>容器关闭时调用Bean的销毁方法</h2><p>IoC 容器关闭时会对 Bean 进行销毁，此时会通过容器中的 BeanFactory 调用 Bean 的自定义销毁方法。</p><p><code>DefaultSingletonBeanRegistry.destroySingletons()</code>方法（DefaultSingletonBeanRegistry 是 DefaultListableBeanFactory 的间接基类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingletons</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">String[] disposableBeanNames;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>.disposableBeans) &#123;</span><br><span class="line">disposableBeanNames = StringUtils.toStringArray(<span class="keyword">this</span>.disposableBeans.keySet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历disposableBeanNames，一个一个调用destroySingleton方法【相当于遍历disposableBeans Map</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = disposableBeanNames.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">this</span>.destroySingleton(disposableBeanNames[i]); <span class="comment">// 见下方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.removeSingleton(beanName);</span><br><span class="line">DisposableBean disposableBean;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>.disposableBeans) &#123;</span><br><span class="line">disposableBean = (DisposableBean)<span class="keyword">this</span>.disposableBeans.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.destroyBean(beanName, disposableBean); <span class="comment">// 见下方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyBean</span><span class="params">(String beanName, @Nullable DisposableBean bean)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Trigger destruction of dependent beans first...</span></span><br><span class="line">Set&lt;String&gt; dependencies;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;</span><br><span class="line"><span class="comment">// Within full synchronization in order to guarantee a disconnected Set</span></span><br><span class="line">dependencies = <span class="keyword">this</span>.dependentBeanMap.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dependencies != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Retrieved dependent beans for bean '"</span> + beanName + <span class="string">"': "</span> + dependencies);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String dependentBeanName : dependencies) &#123;</span><br><span class="line">destroySingleton(dependentBeanName); <span class="comment">// 销毁bean依赖的bean</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually destroy the bean now...</span></span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">bean.destroy(); <span class="comment">// 调用自定义销毁方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Destruction of bean with name '"</span> + beanName + <span class="string">"' threw an exception"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面源码说明了销毁 Bean 的过程：遍历 disposableBeans Map，分别调用这些 Bean 的 destroy 方法完成销毁。从上一小节我们知道，disposableBeans Map 保存了所有含自定义销毁方法的 Bean，且这些 Bean 是被包装成 DisposableBeanAdapter 对象保存的，所以源码中调用<code>bean.destroy()</code>其实是调用<code>DisposableBeanAdapter.destroy()</code>。</p><p>在看 DisposableBeanAdapter.destroy() 方法之前，先看一下当初 Bean 是怎么被包装成 DisposableBeanAdapter 的。DisposableBeanAdapter 构造方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DisposableBeanAdapter</span><span class="params">(Object bean, String beanName, RootBeanDefinition beanDefinition, List&lt;BeanPostProcessor&gt; postProcessors, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">Assert.notNull(bean, <span class="string">"Disposable bean must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.bean = bean;</span><br><span class="line"><span class="keyword">this</span>.beanName = beanName;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">this</span>.invokeDisposableBean = <span class="keyword">this</span>.bean <span class="keyword">instanceof</span> DisposableBean &amp;&amp; !beanDefinition.isExternallyManagedDestroyMethod(<span class="string">"destroy"</span>);</span><br><span class="line"><span class="keyword">this</span>.nonPublicAccessAllowed = beanDefinition.isNonPublicAccessAllowed();</span><br><span class="line"><span class="keyword">this</span>.acc = acc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">String destroyMethodName = <span class="keyword">this</span>.inferDestroyMethodIfNecessary(bean, beanDefinition);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">if</span> (destroyMethodName != <span class="keyword">null</span> &amp;&amp; !(<span class="keyword">this</span>.invokeDisposableBean &amp;&amp; <span class="string">"destroy"</span>.equals(destroyMethodName)) &amp;&amp;</span><br><span class="line">!beanDefinition.isExternallyManagedDestroyMethod(destroyMethodName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.destroyMethodName = destroyMethodName;</span><br><span class="line"><span class="keyword">this</span>.destroyMethod = <span class="keyword">this</span>.determineDestroyMethod();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanDefinition.isEnforceDestroyMethod()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(<span class="string">"Couldn't find a destroy method named '"</span> + destroyMethodName + <span class="string">"' on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Class&lt;?&gt;[] paramTypes = <span class="keyword">this</span>.destroyMethod.getParameterTypes();</span><br><span class="line"><span class="keyword">if</span> (paramTypes.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(<span class="string">"Method '"</span> + destroyMethodName + <span class="string">"' of bean '"</span> + beanName + <span class="string">"' has more than one parameter - not supported as destroy method"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (paramTypes.length == <span class="number">1</span> &amp;&amp; Boolean.TYPE != paramTypes[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(<span class="string">"Method '"</span> + destroyMethodName + <span class="string">"' of bean '"</span> + beanName + <span class="string">"' has a non-boolean parameter - not supported as destroy method"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">this</span>.beanPostProcessors = <span class="keyword">this</span>.filterPostProcessors(postProcessors, bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释上面源码中标注的点：</p><ol><li>判断条件中<code>beanDefinition.isExternallyManagedDestroyMethod(&quot;destroy&quot;)</code>当使用了 @PreDestroy 注解且这个注解标注的方法名为”destroy”时为 true。这一行代码含义是，当 Bean 实现了 DisposableBean 接口且 destroy 方法未标注 @PreDestroy 时，this.invokeDisposableBean = true</li><li>this.inferDestroyMethodIfNecessary()方法中，若定义了@Bean 的 destroyMethod 属性则直接返回；若实现了 DisposableBean 接口则返回 null；若有名为”close”方法或”shutdown”方法，则返回”close”或”shutdown”，否则返回 null</li><li>这里if条件成立的场景是：(destroyMethodName != null) 且 (未实现 DisposableBean 或 实现了 DisposableBean 但 destroyMethodName!=”destory”) 且 destroyMethodName 方法未标注 @PreDestroy 注解</li><li>从容器中所有 beanPostProcessor 中筛选对当前 Bean 有效的</li></ol><p>从上面这几点还可以看出：</p><ol><li>若 @Bean(destroyMethod=”xxx”) 和 DisposableBean 同时用，且前者定义的销毁方法与后者不同（后者只能是 destory 方法），则这两者分别定义的销毁方法都会被调用</li><li>若 @Bean(destroyMethod=”xxx”) 和 @PreDestroy 同时用，且前者定义的销毁方法与后者不同，则这两者分别定义的销毁方法都会被调用</li><li>若 DisposableBean 和 @PreDestroy 同时用，且前者定义的销毁方法（只能是 destory 方法）与后者不同，则这两者分别定义的销毁方法都会被调用</li><li>若只使用了 @Bean 但未定义 destroyMethod 属性，则会自动取方法名为”close”或”shutdown”的方法作为销毁方法</li></ol><blockquote><p>这里使用了“适配器模式”，DisposableBeanAdapter 适配了自定义销毁方法的3种方式。</p></blockquote><p>倒回来看 DisposableBeanAdapter.destroy() 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="comment">// DisposableBeanAdapter本身也实现了DisposableBean接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历调用所有适合这个bean的DestructionAwareBeanPostProcessor，执行销毁前要做的事</span></span><br><span class="line"><span class="comment">// 如果是用@PreDestroy注解，那么这里会通过CommonAnnotationBeanPostProcessor调用到注解标注的方法</span></span><br><span class="line"><span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.beanPostProcessors)) &#123;</span><br><span class="line"><span class="keyword">for</span> (DestructionAwareBeanPostProcessor processor : <span class="keyword">this</span>.beanPostProcessors) &#123;</span><br><span class="line">processor.postProcessBeforeDestruction(<span class="keyword">this</span>.bean, <span class="keyword">this</span>.beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是实现了DisposableBean，则调用destroy方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Invoking destroy() on bean with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">((DisposableBean) bean).destroy();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, acc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">((DisposableBean) bean).destroy();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">String msg = <span class="string">"Invocation of destroy method failed on bean with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"'"</span>;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.warn(msg, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.warn(msg + <span class="string">": "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若使用@Bean(destroyMethod="xxx")，调用指定方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">Method methodToCall = determineDestroyMethod();</span><br><span class="line"><span class="keyword">if</span> (methodToCall != <span class="keyword">null</span>) &#123;</span><br><span class="line">invokeCustomDestroyMethod(methodToCall);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，无论使用哪一种方式自定义销毁方法，这个 Bean 会在容器启动时包装成 DisposableBeanAdapter。容器关闭时，调用 BeanFactory 方法：DefaultSingletonBeanRegistry.destroySingletons()，这个方法内再通过 DisposableBeanAdapter 执行自定义销毁方法。</p><hr><p>这里简单介绍下容器关闭的原理。</p><p>容器关闭时执行的方法是：<code>AbstractApplicationContext.doClose()</code>，就是在这个方法内调用了 DefaultSingletonBeanRegistry.destroySingletons() 方法，那么它是怎么被调用的？</p><p>IoC 容器关闭有2种情况，一个是主动调用容器的 close 方法，像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(BeanConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(context.getBean(HelloWorldController<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">context.close();<span class="comment">// IoC容器关闭，会调用AbstractApplicationContext.doClose()方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在一般项目中不会有这样的代码，所以第二种情况就是让 Spring 自动完成关闭容器的操作。Spring 怎么自己知道要关闭容器？</p><p>在<code>SpringApplication.refreshContext()</code>方法源码（如下）中可以看到，程序启动时，SpringApplication 调用完容器的 refresh 方法后，紧接着调用了容器的<code>registerShutdownHook</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.refresh(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registerShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            context.registerShutdownHook();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AccessControlException var3) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerShutdownHook 方法是接口 ConfigurableApplicationContext 定义的，由 AbstractApplicationContext（所有容器类的基类）实现。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.shutdownHook = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(AbstractApplicationContext.<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">                    AbstractApplicationContext.<span class="keyword">this</span>.doClose();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">this</span>.shutdownHook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的最后调用了 JDK 的一个方法：<code>Runtime.addShutDownHook(Thread hook)</code> ，作用是：注册一个 JVM 关闭的<strong>钩子方法</strong>。此处可以看出，这个“钩子方法”是一个线程，线程内调用了 AbstractApplicationContext.doClose() 方法 ，这个线程会在JVM <strong>正常关闭</strong>时被执行。</p><blockquote><p>什么是钩子方法？</p></blockquote><p>钩子方法是设计模式中的模板模式里用到的，它是由抽象类声明并且实现，实现内容一般是空的，子类可以选择是否扩展。钩子方法为你在实现某一个抽象类的时候提供了可选项，相当于预先提供了一个默认配置。</p><blockquote><p>JVM正常关闭的条件是？</p></blockquote><p>用”kill”命令而不是”kill -9”命令，在idea编辑器里点击”exit”按钮而不是”stop”按钮。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IoC原理</title>
      <link href="/2020/05/31/spring-ioc/"/>
      <url>/2020/05/31/spring-ioc/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring IoC是一种通过<strong>描述</strong>来生成或者获取对象的技术，和我们平时在需要时直接new一个对象是不一样的，它就是通过你给的针对对象的描述，如对象的名字或者类型，来生成这个对象（若已生成，就直接取）。在Spring中，这些被管理的对象叫作<code>Bean</code>。Spring会统一管理这些Bean，包括Bean之间的依赖关系，负责管理这些Bean的是<code>IoC容器</code>。</p><blockquote><p>IoC（控制反转）的意思就是，原本是我们自己控制对象，现在变成由Spring控制，我们需要对象的时候要从容器中取。</p></blockquote><p>文中出现的Spring源码都是SpringBoot 2.3.0版本。</p><h1 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h1><p>IoC容器，在程序中就是实现了<code>BeanFactory</code>接口的类。<code>BeanFactory</code>接口中提供了用name和requiredType获取Bean的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**其他方法和属性省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationContext</code>接口间接继承了<code>BeanFactory</code>接口，它包含<code>BeanFactory</code>接口的所有方法，还提供了额外功能，Spring将它作为默认的启动容器。</p><p>当我们用<code>SpringApplication.run(XXXApplication.class, args);</code>启动时，Spring就会根据依赖的jar包来指定要使用的IoC容器，看SpringApplication类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line"><span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line"><span class="keyword">case</span> SERVLET:</span><br><span class="line">contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> REACTIVE:</span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"Unable create a default ApplicationContext, please specify an ApplicationContextClass"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webApplicationType</code>的值由依赖的jar包决定，默认值是SERVLET，所以IoC容器一般是DEFAULT_SERVLET_WEB_CONTEXT_CLASS=<code>AnnotationConfigServletWebServerApplicationContext</code>，这个类间接实现了<code>ApplicationContext</code>接口。</p><h1 id="用注解装配Bean"><a href="#用注解装配Bean" class="headerlink" title="用注解装配Bean"></a>用注解装配Bean</h1><p>SpringBoot多是用注解把Bean装配到IoC容器中，但也可以使用XML配置文件来装配，这里只介绍注解的方式。</p><h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"><span class="comment">// 内容省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlMultipleDemoApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(MysqlMultipleDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类加上@Component注解后，在SpringBoot启动时，它就会被扫描进IoC容器，原因就是SpringBoot启动类的注解<code>@SpringBootApplication</code>里面包含了<code>@ComponentScan</code>注解，而<code>@ComponentScan</code>的作用就是扫描类当前包及其子包下的被<code>@Component</code>修饰的类。<code>@ComponentScan</code>也可以指定要扫描的包路径。<br>顺便一提，我们熟悉的@Controller、@Service，以及下面说到的@Configuration都包含了@Component注解，所以这些注解修饰的类都会被装配到IoC容器中。</p><h2 id="Configuration和-Bean组合"><a href="#Configuration和-Bean组合" class="headerlink" title="@Configuration和@Bean组合"></a>@Configuration和@Bean组合</h2><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">ApplicationContextUtil <span class="title">applicationContextUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ApplicationContextUtil();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就在IoC容器中生成了一个叫”applicationContextUtil”的Bean。Bean的名字可以在@Bean注解中指定，不指定就为方法名。在一个@Configuration类中，可以写多个@Bean。</p><p>另外，这样的组合可以控制Bean的加载顺序，控制方法见这篇博客： <a href="https://blog.csdn.net/qianshangding0708/article/details/107373538" target="_blank" rel="noopener">https://blog.csdn.net/qianshangding0708/article/details/107373538</a></p><blockquote><p>PS: 因为@Configuration包含了@Component注解，所以换成 @Component + @Bean 组合也是可以的，效果一样。</p></blockquote><h2 id="上面两种方法的区别"><a href="#上面两种方法的区别" class="headerlink" title="上面两种方法的区别"></a>上面两种方法的区别</h2><p>从效果上来说没有区别，都可以装配Bean。但后者有一个专门的使用场景，就是装配依赖jar包中的Bean。如上面的示例代码，若<code>ApplicationContextUtil</code>是依赖包中的类，不在自己程序中，就只能用@Configuration和@Bean装配。</p><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>类之间免不了有依赖关系，如我们经常在Service类中这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">personMapper.insertPerson(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就说明PersonServiceImpl类依赖PersonMapper类，但这个PersonMapper的实例对象不是我们自己new的，是通过@Autowired注解，让IoC容器为我们注入的，因此称之为<strong>“依赖注入”</strong>。</p><blockquote><p>这里有个疑问，PersonMapper一般是接口，无实现类，也没有@Component修饰，为什么会被装配到IoC容器中？<br>答案是，Mybatis为每个Mapper接口实现了一个动态代理类（即Mapper接口的实现类），这些动态代理类会被<code>MapperFactoryBean</code>保存起来。<code>MapperFactoryBean</code>作为接口类型被添加到IoC容器中，当需要依赖注入Mapper接口的Bean时，调用<code>MapperFactoryBean</code>的getObject()方法得到Mapper的代理类。<br>这其中的原理足够再写一篇文章，这里就不展开介绍，具体内容可以上网搜索“mapper接口依赖注入”。</p></blockquote><h2 id="Autowired和-Resource"><a href="#Autowired和-Resource" class="headerlink" title="@Autowired和@Resource"></a>@Autowired和@Resource</h2><p>@Autowired和@Resource两个注解的作用都是找到对应的Bean注入到依赖它的类中。区别是：</p><ol><li>@Autowired是Spring注解，@Resource是JDK注解</li><li>@Autowired先按类型注入，找不到再按名称注入，@Resource相反</li></ol><h2 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h2><h3 id="设值注入（set注入）"><a href="#设值注入（set注入）" class="headerlink" title="设值注入（set注入）"></a>设值注入（set注入）</h3><p>设值注入是指IoC容器通过set方法来注入被依赖对象。这种注入方式简单、直观。<br>把上面的PersonServiceImpl代码改为这样就是设值注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersonMapper</span><span class="params">(PersonMapper personMapper)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.personMapper = personMapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">personMapper.insertPerson(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><p>利用构造器来设置依赖对象的方式，被称为构造注入。通俗来说，就是驱动Spring在底层以反射方式执行带指定参数的构造器，当执行带参数的构造器时，就可利用构造器参数对成员变量执行初始化。<br>PersonServiceImpl代码改为这样就是构造注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PersonServiceImpl</span><span class="params">(@Autowired PersonMapper personMapper)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.personMapper = personMapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">personMapper.insertPerson(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Primary和-Quelifier"><a href="#Primary和-Quelifier" class="headerlink" title="@Primary和@Quelifier"></a>@Primary和@Quelifier</h2><p>这两个注解解决了一个问题：当@Autowired按类型寻找Bean，找到了多个符合条件的Bean时，应该注入哪一个？<br>举个例子，SpringBoot的官方给出的“在项目中配置多个数据源”的示例代码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.first"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">firstDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.first.configuration"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">firstDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstDataSourceProperties().initializeDataSourceBuilder().type(HikariDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.second"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">secondDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.second.configuration"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">secondDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> secondDataSourceProperties().initializeDataSourceBuilder().type(BasicDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了两个名字不同但类型相同的DataSourceProperties Bean，当有个Bean不指定名字地要求注入它依赖的DataSourceProperties对象，IoC容器就会优先注入被<code>@Primary</code>修饰的那个DataSourceProperties Bean。</p><p>当然我们更希望由自己决定注入哪一个Bean，这样更准确。这时就用<code>@Quelifier</code>注解指定要注入的Bean的名字。使用方法类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">ds1TransactionManager</span><span class="params">(@Qualifier(<span class="string">"firstDataSource"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h1><p>用<code>@Scope</code>注解可以指定Bean的作用域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig1</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="function">MyBean1 <span class="title">myBean1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyBean1 myBean1 = <span class="keyword">new</span> MyBean1();</span><br><span class="line">myBean1.setName(<span class="string">"hello1"</span>);</span><br><span class="line"><span class="keyword">return</span> myBean1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>@Scope</code>注解源码，可以看到它支持的作用域定义在<code>ConfigurableBeanFactory</code>和<code>WebApplicationContext</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scope &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"scopeName"</span>)</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specifies the name of the scope to use for the annotated component/bean.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Defaults to an empty string (&#123;<span class="doctag">@code</span> ""&#125;) which implies</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConfigurableBeanFactory#SCOPE_SINGLETON SCOPE_SINGLETON&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableBeanFactory#SCOPE_PROTOTYPE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableBeanFactory#SCOPE_SINGLETON</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.WebApplicationContext#SCOPE_SESSION</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line"><span class="function">String <span class="title">scopeName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ScopedProxyMode <span class="title">proxyMode</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ConfigurableBeanFactory</code>接口中，有两个作用域：单例和原型，它们在所有Spring IoC容器都可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableBeanFactory</span> <span class="keyword">extends</span> <span class="title">HierarchicalBeanFactory</span>, <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for the standard singleton scope: &#123;<span class="doctag">@value</span>&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Custom scopes can be added via &#123;<span class="doctag">@code</span> registerScope&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerScope</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_SINGLETON = <span class="string">"singleton"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for the standard prototype scope: &#123;<span class="doctag">@value</span>&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Custom scopes can be added via &#123;<span class="doctag">@code</span> registerScope&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerScope</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_PROTOTYPE = <span class="string">"prototype"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其他属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>WebApplicationContext</code>接口中，有三个作用域：request、session、application。它们只在实现了<code>WebApplicationContext</code>接口的容器中可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for request scope: "request".</span></span><br><span class="line"><span class="comment"> * Supported in addition to the standard scopes "singleton" and "prototype".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_REQUEST = <span class="string">"request"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for session scope: "session".</span></span><br><span class="line"><span class="comment"> * Supported in addition to the standard scopes "singleton" and "prototype".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_SESSION = <span class="string">"session"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scope identifier for the global web application scope: "application".</span></span><br><span class="line"><span class="comment"> * Supported in addition to the standard scopes "singleton" and "prototype".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_APPLICATION = <span class="string">"application"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其他属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="request-session-application"><a href="#request-session-application" class="headerlink" title="request session application"></a>request session application</h2><p>单例和原型的含义大家都熟悉，这里先介绍下另外三个作用域。</p><ol><li>request: 在一次HTTP请求中，bean是单例的，再来一个HTTP请求就再实例化一个bean（容器中有保留一份bean定义，用bean定义实例化bean）。不同的HTTP请求的bean实例不同，自然也不会互相影响。HTTP请求结束bean实例就销毁</li><li>session: 和request作用于类似，但是范围是一次HTTP session</li><li>application: 在一个ServletContext中，bean是单例的。和singleton的区别是，singleton是指在一个IoC容器中bean是单例的。</li></ol><blockquote><p>ServletContext是什么？<br>一个Java Web应用都有一个ServletContext，这个应用里的所有servlet都可通过ServletContext获取初始化参数（web.xml中的<context-param>节点定义的配置）、文件路径等等，同时servlet之间还可通过ServletContext.set/getAttribute()修改和访问共有的属性。ServletContext是servlet之间，以及项目容器（如Tomcat）和WEB项目之间的桥梁。</p></blockquote><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式是一个很出名的设计模式，常见的是懒汉式和饿汉式，但Spring采用的是登记式，且Spring允许你设置是否用懒加载（默认不用）。<br>饿汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式（线程安全）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登记式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放beanName和bean实例的map，就像bean的登记表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; registry = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Object object = registry.get(<span class="string">"singleton"</span>);</span><br><span class="line"><span class="keyword">if</span>(object == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registry.put(<span class="string">"singleton"</span>, <span class="keyword">new</span> Singleton());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">object = registry.get(<span class="string">"singleton"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (Singleton) object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这种方式的好处在于，不要求单例类的构造方法是private。因此尽管我们的controller、service未声明private构造方法，在Spring中依然可以是单例。</p><h3 id="Spring单例模式的实现"><a href="#Spring单例模式的实现" class="headerlink" title="Spring单例模式的实现"></a>Spring单例模式的实现</h3><p>Spring中的单例的概念是，在一个IoC容器中，一个Bean定义只有一个实例。上面说到Spring的单例模式是登记式，有一个bean的“登记表”，保存beanName和bean实例，当登记表中不存在bean实例，就立即创建一个并“登记”，若已有bean实例就直接返回。</p><p>“登记表”的接口<code>SingletonBeanRegistry</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the given existing object as singleton in the bean registry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the (raw) singleton object registered under the given name.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Object <span class="title">getSingleton</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其他方法，没有属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“登记表”的接口实现类<code>DefaultSingletonBeanRegistry</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面3个Map都是用于缓存</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登记表</span></span><br><span class="line"><span class="comment">/** Set of registered singletons, containing the bean names in registration order. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">Assert.notNull(singletonObject, <span class="string">"Singleton object must not be null"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">Object oldObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (oldObject != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not register object ["</span> + singletonObject +</span><br><span class="line"><span class="string">"] under bean name '"</span> + beanName + <span class="string">"': there is already object ["</span> + oldObject + <span class="string">"] bound"</span>);</span><br><span class="line">&#125;</span><br><span class="line">addSingleton(beanName, singletonObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);<span class="comment">// 加入缓存</span></span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.registeredSingletons.add(beanName); <span class="comment">// 登记</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getSingleton方法1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);<span class="comment">// 从缓存中取</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject(); <span class="comment">// 有工厂就用工厂实例化</span></span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);<span class="comment">// 加入缓存</span></span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getSingleton方法2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName); <span class="comment">// 从缓存中取</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line"><span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line"><span class="string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">beforeSingletonCreation(beanName);</span><br><span class="line"><span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject(); <span class="comment">// 从第二个参数取</span></span><br><span class="line">newSingleton = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line"><span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">ex.addRelatedCause(suppressedException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">afterSingletonCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">addSingleton(beanName, singletonObject); <span class="comment">// 加入缓存并登记</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 其他属性和方法省略 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，bean实例是何时被注册的？在IoC容器启动，和程序中使用ApplicationContext.getBean()方法时。</p><p>IoC容器启动时，调用入口在IoC容器基类<code>AbstractApplicationContext.finishBeanFactoryInitialization()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单例且非懒加载的bean，beanFactory=DefaultListableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中使用ApplicationContext.getBean()方法时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">assertBeanFactoryActive();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个调用点，都会进入到AbstractBeanFactory.doGetBean()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName); <span class="comment">//调用getSingleton方法1</span></span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">//调用getSingleton方法2，后一个参数是createBean()方法返回的bean实例（且已初始化）</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可对比看下原型作用域，就是一次getBean就会调用createBean()方法返回bean实例（且已初始化）</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring为什么默认单例模式"><a href="#Spring为什么默认单例模式" class="headerlink" title="Spring为什么默认单例模式"></a>Spring为什么默认单例模式</h3><p><strong>单例bean的优势：</strong></p><ol><li>减少了新生成实例的消耗。新生成实例消耗包括两方面，第一spring会通过反射或者cglib来生成bean实例，这都是耗性能的操作，第二给对象分配内存也会涉及复杂算法</li><li>减少jvm垃圾回收。由于不会给每个请求都新生成bean实例，所以自然回收的对象少了</li><li>可以快速获取到bean。因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的，所以很快</li></ol><p><strong>单例bean的劣势：</strong><br>单例的bean一个很大的劣势就是他不能做到线程安全。下面详细说明。</p><h3 id="单例模式的线程安全问题"><a href="#单例模式的线程安全问题" class="headerlink" title="单例模式的线程安全问题"></a>单例模式的线程安全问题</h3><ol><li>线程安全问题都是由单例bean的成员变量及静态变量引起的</li><li>若每个线程中对成员变量、静态变量只有读操作，而无写操作，那么不存在线程安全问题；若有写操作，就存在线程安全问题</li><li>成员变量、静态变量的线程安全问题是因为成员变量在堆中，静态变量在方法区中，堆和方法区是线程共享的（局部变量在栈中，是线程私有的）</li><li>当多个线程调用方法时会不会出现线程安全问题呢？答案是不会，方法存在虚拟机栈中，是线程私有的</li></ol><p>这也是为什么我们声明的bean，如controller、service，基本上不含除了依赖bean以外的成员变量，也不会去修改成员变量值。</p><p>如果一定要在单例bean中使用会被修改的成员变量，可以在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中。</p><blockquote><p>ThreadLocal是线程局部变量，所谓的线程局部变量，就是仅仅只能被本线程访问，不能在线程之间进行共享访问的变量。</p></blockquote><p>举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法只能访问本线程内的sqlSession</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</span><br><span class="line">Session s = (Session) threadSession.get();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">s = getSessionFactory().openSession();</span><br><span class="line">threadSession.set(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上ThreadLocal的普通用法。在一个线程中，controller经常要传参给service，如果固定要传某个参数，方法形参的声明会很臃肿，所以可以把一些必须要传的参数写到ThreadLocal中。<br>举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusiUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal_logindex = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLogIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> threadLocal_logindex.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLogIndex</span><span class="params">(String logIndex)</span> </span>&#123;</span><br><span class="line">threadLocal_logindex.set(logIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeLogIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">threadLocal_logindex.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在controller中调用BusiUtil.setLogIndex("123456789")</span></span><br><span class="line"><span class="comment">// 在service中调用BusiUtil.getLogIndex()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot配置数据源</title>
      <link href="/2020/05/30/springboot-datasource-config/"/>
      <url>/2020/05/30/springboot-datasource-config/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为工作项目的新需求涉及到在SpringBoot中配置多个MySQL数据库，为了理解如何配置，学习了SpringBoot自动配置数据源的原理，在此记录。这篇文章先介绍SpringBoot配置单个数据源的原理，再介绍多个数据源的配置方法。</p><h1 id="SpringBoot配置单个数据源"><a href="#SpringBoot配置单个数据源" class="headerlink" title="SpringBoot配置单个数据源"></a>SpringBoot配置单个数据源</h1><h2 id="未指定spring-datasource-type时，SpringBoot的默认数据源"><a href="#未指定spring-datasource-type时，SpringBoot的默认数据源" class="headerlink" title="未指定spring.datasource.type时，SpringBoot的默认数据源"></a>未指定spring.datasource.type时，SpringBoot的默认数据源</h2><p>以下面application.yml为例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server.port:</span> <span class="number">18081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span> </span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>执行Junit Test看下SpringBoot使用的默认数据源是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MysqlDemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dataSource: "</span> + dataSource.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在未指定spring.datasource.type的情况下，SpringBoot会使用默认数据源，在1.X版本中，默认数据源是org.apache.tomcat.jdbc.pool.DataSource；在2.X版本中，默认数据源是com.zaxxer.hikari.HikariDataSource。</p><blockquote><p>以下源码版本都是SpringBoot 2.3.0</p></blockquote><p>SpringBoot是怎么指定数据源的？道理在<code>DataSourceConfiguration</code>这个类，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createDataSource</span><span class="params">(DataSourceProperties properties, Class&lt;? extends DataSource&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (T) properties.initializeDataSourceBuilder().type(type).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tomcat Pool DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(org.apache.tomcat.jdbc.pool.DataSource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">DataSource</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.type"</span>, havingValue = <span class="string">"org.apache.tomcat.jdbc.pool.DataSource"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.tomcat"</span>)</span><br><span class="line">org.apache.tomcat.jdbc.pool.<span class="function">DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">org.apache.tomcat.jdbc.pool.DataSource dataSource = createDataSource(properties,</span><br><span class="line">org.apache.tomcat.jdbc.pool.DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">DatabaseDriver databaseDriver = DatabaseDriver.fromJdbcUrl(properties.determineUrl());</span><br><span class="line">String validationQuery = databaseDriver.getValidationQuery();</span><br><span class="line"><span class="keyword">if</span> (validationQuery != <span class="keyword">null</span>) &#123;</span><br><span class="line">dataSource.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">dataSource.setValidationQuery(validationQuery);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hikari DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(HikariDataSource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">DataSource</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.type"</span>, havingValue = <span class="string">"com.zaxxer.hikari.HikariDataSource"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hikari</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.hikari"</span>)</span><br><span class="line"><span class="function">HikariDataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">HikariDataSource dataSource = createDataSource(properties, HikariDataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(properties.getName())) &#123;</span><br><span class="line">dataSource.setPoolName(properties.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DBCP DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(org.apache.commons.dbcp2.BasicDataSource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">DataSource</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.type"</span>, havingValue = <span class="string">"org.apache.commons.dbcp2.BasicDataSource"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dbcp2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.dbcp2"</span>)</span><br><span class="line">org.apache.commons.dbcp2.<span class="function">BasicDataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> createDataSource(properties, org.apache.commons.dbcp2.BasicDataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generic DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(DataSource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.type"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前三个内部类Tomcat、Hikari、Dbcp2上的注解：</p><ol><li>@Configuration(proxyBeanMethods = false)：会装配Bean的配置类</li><li>@ConditionalOnClass(XXX.class)：给定的XXX.class在系统中存在时，就实例化当前Bean</li><li>@ConditionalOnMissingBean(DataSource.class)：若IOC容器中还不存在DataSource这个Bean，就在IOC容器中实例化DataSource Bean</li><li>@ConditionalOnProperty(name = “spring.datasource.type”, havingValue = “XXX”,matchIfMissing = true)：配置中，是否有<code>spring.datasource.type=XXX</code>的配置。<code>matchIfMissing = true</code>表示，即使没有指定配置，该配置类也生效</li></ol><blockquote><p>@ConditionalOnProperty 注解中若没有配置 havingValue 属性，则处理方式为：若指定配置项值=false，则当前注解修饰的配置类不生效，否则生效。若没有配置 matchIfMissing 属性，则默认 matchIfMissing=true。</p></blockquote><p>因此，以Tomcat类为例，这些注解表示，若系统存在<code>org.apache.tomcat.jdbc.pool.DataSource.class</code>，即使没有配置<code>spring.datasource.type=org.apache.tomcat.jdbc.pool.DataSource</code>，也是使用<code>org.apache.tomcat.jdbc.pool.DataSource</code>作为数据源。</p><p>当我们指定了spring.datasource.type时，就使最后一个类Generic生效，它会初始化spring.datasource.type配置项指定的数据源。</p><blockquote><p>PS：为什么1.X和2.X两个版本默认的数据源不同？<br>因为在<code>spring-boot-start-jdbc 1.X</code>中，默认引入依赖<code>tomcat-jdbc</code>；而在<code>spring-boot-start-jdbc 2.X</code>中，默认引入依赖<code>HikariCP</code></p></blockquote><h2 id="指定spring-datasource-type，使用Druid数据源"><a href="#指定spring-datasource-type，使用Druid数据源" class="headerlink" title="指定spring.datasource.type，使用Druid数据源"></a>指定spring.datasource.type，使用Druid数据源</h2><p>application.yml更新为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server.port:</span> <span class="number">18081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span> </span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>再执行上面的Junit Test，可以看到dataSource换成了com.alibaba.druid.pool.DruidDataSource。这个就是由上面的<code>DataSourceConfiguration</code>类下的<code>Generic</code>初始化的。</p><h2 id="配置Druid数据库连接池参数并使其生效"><a href="#配置Druid数据库连接池参数并使其生效" class="headerlink" title="配置Druid数据库连接池参数并使其生效"></a>配置Druid数据库连接池参数并使其生效</h2><p>application.yml更新为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">filters:</span> <span class="string">stat</span></span><br><span class="line">    <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">initialSize:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">minIdle:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">    <span class="attr">validationQuery:</span> <span class="string">select</span> <span class="string">'x'</span></span><br><span class="line">    <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">maxOpenPreparedStatements:</span> <span class="number">20</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">server.port:</span> <span class="number">18081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span> </span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>但是，通过运行下面的Junit Test，我们可以看到，数据库连接池的属性如maxActive并没有生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MysqlDemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DataSource dataSource;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"dataSource: "</span> + dataSource.getClass());</span><br><span class="line">Connection connection = dataSource.getConnection();</span><br><span class="line">System.out.println(<span class="string">"connection: "</span> + connection);</span><br><span class="line"><span class="keyword">if</span>(dataSource <span class="keyword">instanceof</span> DruidDataSource) &#123;</span><br><span class="line">DruidDataSource dDataSource = (DruidDataSource) dataSource;</span><br><span class="line">System.out.println(<span class="string">"maxActive: "</span> + dDataSource.getMaxActive());</span><br><span class="line">System.out.println(<span class="string">"minIdle: "</span> + dDataSource.getMinIdle());</span><br><span class="line">&#125;</span><br><span class="line">connection.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们配置的是maxActive=20，minIdle=1，打印出来的是maxActive=8，minIdle=0。<br>什么原因呢？我们先看上面那个<code>DataSourceConfiguration</code>类下的<code>Generic</code>的方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>DataSourceProperties</code>类的源码，它用注解<code>@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</code>把”spring.datasource”下的属性映射到自己的同名属性中了，但在这个类中，和我们配置项同名的只有url、username、password、driver-class-name、type这5个属性，并没有maxActive这样的数据库连接池属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProperties</span> <span class="keyword">implements</span> <span class="title">BeanClassLoaderAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fully qualified name of the connection pool implementation to use. By default, it</span></span><br><span class="line"><span class="comment"> * is auto-detected from the classpath.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? extends DataSource&gt; type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String driverClassName;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC URL of the database.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Login username of the database.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Login password of the database.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*省略其他属性*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize a &#123;<span class="doctag">@link</span> DataSourceBuilder&#125; with the state of this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> DataSourceBuilder&#125; initialized with the customizations defined on</span></span><br><span class="line"><span class="comment"> * this instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> DataSourceBuilder&lt;?&gt; initializeDataSourceBuilder() &#123;</span><br><span class="line"><span class="keyword">return</span> DataSourceBuilder.create(getClassLoader()).type(getType()).driverClassName(determineDriverClassName())</span><br><span class="line">.url(determineUrl()).username(determineUsername()).password(determinePassword());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*省略其他方法*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@ConfigurationProperties(prefix=”spring.datasource”)注解表示把”spring.datasource”下的属性映射到实体类的同名属性上。它的用法有：标注在类声明上，然后用其他注解如 @Component 或 @Bean 注入这个 Bean 即可生效；另一个是不标注在类声明上，而是用 @Bean 注入这个类的 Bean 时，标注在 @Bean 修饰的方法上也可生效。</p></blockquote><p>再查看<code>DataSourceBuilder</code>类build()方法源码，可以看到这里只是反射调用DruidDataSource()构造函数，建立DruidDataSource对象，没有给这个对象属性赋值。DruidDataSource中的maxActive属性是有默认值的，这个默认值就是我们打印出的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Class&lt;? extends DataSource&gt; type = getType();</span><br><span class="line">DataSource result = BeanUtils.instantiateClass(type);</span><br><span class="line">maybeGetDriverClassName();</span><br><span class="line">bind(result);</span><br><span class="line"><span class="keyword">return</span> (T) result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么怎样让我们的配置生效呢？SpringBoot的官方文档给了我们三种方法。<br>新建一个配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  第一种</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  第二种</span></span><br><span class="line"><span class="comment">//@Bean</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties("spring.datasource")</span></span><br><span class="line"><span class="comment">//public DataSource dataSource() &#123;</span></span><br><span class="line"><span class="comment">//    return DataSourceBuilder.create().type(DruidDataSource.class).build();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  第三种</span></span><br><span class="line"><span class="comment">//@Bean</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties(prefix = "spring.datasource")</span></span><br><span class="line"><span class="comment">//public DataSource dataSource(</span></span><br><span class="line"><span class="comment">//DataSourceProperties properties) &#123;</span></span><br><span class="line"><span class="comment">//return properties.initializeDataSourceBuilder().type(DruidDataSource.class).build();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种方法都能使我们的配置生效。第二种和第三种方法的里面就是反射调用DruidDataSource()构造函数。因为<code>@ConfigurationProperties</code>注解的作用，我们的配置属性被映射到了DruidDataSource对象属性上，即使DruidDataSource是通过反射建立的也会生效。</p><p>关于第三种方法，若我们的url、username、password、driver-class-name、type五个配置和别的数据库连接池配置是分开的，例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">druid:</span> </span><br><span class="line">  <span class="attr">filters:</span> <span class="string">stat</span></span><br><span class="line">  <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">initialSize:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxWait:</span> <span class="number">60000</span></span><br></pre></td></tr></table></figure><p>第三种方法就应该这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">dataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"druid"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> properties.initializeDataSourceBuilder().type(DruidDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因就是，”spring.datasource.*“属性只映射到<code>DataSourceProperties</code>对象，properties反射创建DruidDataSource对象后，”druid.*“属性才映射到DruidDataSource对象。</p><h1 id="SpringBoot-Mybatis配置多个数据源"><a href="#SpringBoot-Mybatis配置多个数据源" class="headerlink" title="SpringBoot+Mybatis配置多个数据源"></a>SpringBoot+Mybatis配置多个数据源</h1><p>这里指的是配置多个Mysql数据源。<br>配置文件application.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">db1:</span> </span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">db2:</span> </span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test2?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">filters:</span> <span class="string">stat</span></span><br><span class="line">    <span class="attr">minIdle:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">initialSize:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span>  </span><br><span class="line">    <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">3000000</span></span><br><span class="line">    <span class="attr">validationQuery:</span> <span class="string">select</span> <span class="string">'x'</span>  </span><br><span class="line">    <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">maxOpenPreparedStatements:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>理解了配置单个数据源的方法后，很容易写出多个数据源的配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.db1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">ds1DataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">ds1DataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ds1DataSourceProperties().initializeDataSourceBuilder().type(DruidDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.db2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">ds2DataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">ds2DataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ds2DataSourceProperties().initializeDataSourceBuilder().type(DruidDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用Junit Test验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MysqlMultipleDemoApplicationTests</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Object ds1DataSource = ApplicationContextUtil.getBean(<span class="string">"ds1DataSource"</span>);</span><br><span class="line"><span class="keyword">if</span>(ds1DataSource <span class="keyword">instanceof</span> DruidDataSource) &#123;</span><br><span class="line">DruidDataSource ds = (DruidDataSource) ds1DataSource;</span><br><span class="line">System.out.println(ds.getUrl());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object ds2DataSource = ApplicationContextUtil.getBean(<span class="string">"ds2DataSource"</span>);</span><br><span class="line"><span class="keyword">if</span>(ds2DataSource <span class="keyword">instanceof</span> DruidDataSource) &#123;</span><br><span class="line">DruidDataSource ds = (DruidDataSource) ds2DataSource;</span><br><span class="line">System.out.println(ds.getUrl());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的内容与我们的配置相对应。</p><p>如果是用JdbcTemplate，给不同的JdbcTemplate指定不同的数据源即可。但现在项目多是用Mybatis，有多个数据源存在时，需要把mapper.xml和mapper.java文件与数据源对应起来。<br>新建两个数据库的Mybatis配置类：<br>1.MybatisConfigDB1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// basePackages为要扫描的mapper.java所在包</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages =<span class="string">"com.example.demo.mysql.multiple.dao.test"</span>, sqlSessionTemplateRef  = <span class="string">"ds1SqlSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfigDB1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主数据源 ds1数据源</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"ds1SqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">ds1SqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"ds1DataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSessionFactoryBean sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactory.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactory.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().</span><br><span class="line">                        getResources(<span class="string">"classpath:mapper/test/*.xml"</span>));<span class="comment">// mapper.xml目录</span></span><br><span class="line">        sqlSessionFactory.setTypeAliasesPackage(<span class="string">"com.example.demo.mysql.multiple.domain.test"</span>);<span class="comment">//实体类所在包，用于生成实体类别名</span></span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ds1TransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">ds1TransactionManager</span><span class="params">(@Qualifier(<span class="string">"ds1DataSource"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ds1SqlSessionTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">ds1SqlSessionTemplate</span><span class="params">(@Qualifier(<span class="string">"ds1SqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.MybatisConfigDB2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages =<span class="string">"com.example.demo.mysql.multiple.dao.test2"</span>, sqlSessionTemplateRef  = <span class="string">"ds2SqlSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfigDB2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ds2数据源</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"ds2SqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">ds1SqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"ds2DataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSessionFactoryBean sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactory.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactory.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().</span><br><span class="line">                        getResources(<span class="string">"classpath:mapper/test2/*.xml"</span>));  </span><br><span class="line">        sqlSessionFactory.setTypeAliasesPackage(<span class="string">"com.example.demo.mysql.multiple.domain.test2"</span>);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ds2TransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">ds1TransactionManager</span><span class="params">(@Qualifier(<span class="string">"ds2DataSource"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ds2SqlSessionTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">ds1SqlSessionTemplate</span><span class="params">(@Qualifier(<span class="string">"ds2SqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以自己写个Junit Test验证，看每个数据源下的mapper.java和mapper.xml是否有效。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> 实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL笔记</title>
      <link href="/2020/05/16/mysql-note/"/>
      <url>/2020/05/16/mysql-note/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是关系型和非关系型"><a href="#什么是关系型和非关系型" class="headerlink" title="什么是关系型和非关系型"></a>什么是关系型和非关系型</h1><p>关系型数据库，是指采用了关系模型来组织数据的数据库，关系模型可以简单理解为二维表格模型，其以行和列的形式存储数据，这一系列的行和列被称为表，一组表组成了数据库。一个关系型数据库就是由一组二维表及它们之间的关系组成的一个数据组织。典型的 MySQL、Oracle 都支持事务。<br>例子：MySQL、Oracle</p><p>非关系型数据库（NoSQL），严格上不是一种数据库，是一种数据结构化存储方法的集合，可以是文档或者键值对等。分类；键值对数据库（是NoSQL中最简单的类型）、文档型数据库（也叫面向文档的数据库）、列存储数据库、图形数据库。NoSQL 都不支持事务。<br>例子：Redis（键值对数据库）、MongoDB（文档型数据库）、Elasticsearch（文档型数据库）</p><blockquote><p>文档型数据库<br>一个文档就是文档型数据库中的一条记录。文档通常存储关于一个对象及其任何相关元数据的信息。文档中是以键值对的形式存储数据。值的类型和结构可以有多种，包括字符串、数字、日期、数组等。文档存储的格式可以是JSON,BSON（二进制形式的JSON）和XML。文档中的键值对可以嵌套。<br>文档数据库介绍：<a href="https://blog.csdn.net/miaoyibo12/article/details/121084366" target="_blank" rel="noopener">https://blog.csdn.net/miaoyibo12/article/details/121084366</a></p></blockquote><blockquote><p>列存储数据库<br>简单地说，行存储就是数据在“页”中是按原本数据表的一行一行数据存储的，例如 MySQL、Oracle。列存储中数据是按原本数据表的一列一列存储的。行存储适用于OLTP场景，列存储适用于OLAP场景。<br>行存储：<a href="https://blog.csdn.net/li1325169021/article/details/121044179" target="_blank" rel="noopener">https://blog.csdn.net/li1325169021/article/details/121044179</a><br>列存储：<a href="https://www.jianshu.com/p/d1114dd4f77a" target="_blank" rel="noopener">https://www.jianshu.com/p/d1114dd4f77a</a></p></blockquote><h1 id="CHAR和VARCHAR的区别"><a href="#CHAR和VARCHAR的区别" class="headerlink" title="CHAR和VARCHAR的区别"></a>CHAR和VARCHAR的区别</h1><ol><li>CHAR(m)所占字节数都是m个字节，这表示CHAR(m)是固定长度；VARCHAR(m)所占字节数是实际长度+1个字节</li><li>VARCHAR多出的一个字节是用来保存实际长度值</li><li>因为CHAR无论存储的数据长度本身是多少，都会占用固定的长度，因此存储空间会有一定的浪费；VARCHAR由于是可变长度，更节约存储空间</li><li>VARCHAR的缺点是影响性能，若UPDATE后VARCHAR列的字符串长度变长了，就需要重新分配存储空间</li><li>对于InnoDB引擎，VARCHAR的性能影响可以忽略，具体见下面存储引擎的介绍 ———</li></ol><h1 id="DATETIME和TIMESTAMP的区别"><a href="#DATETIME和TIMESTAMP的区别" class="headerlink" title="DATETIME和TIMESTAMP的区别"></a>DATETIME和TIMESTAMP的区别</h1><ol><li>TIMESTAMP类型的字段在insert和update时可指定更新为当前时间</li><li>TIMESTAMP类型显示的时间与系统时间所处的时区有关。例如，系统时间设为东八区时，显示的值为’2018-05-24 14:59:59’；系统时间设为东九区时，显示的值为’2018-05-24 15:59:59’<br>DATETIME类型只显示插入时的时间，即显示的时间不考虑时区变化</li><li>TIMESTAMP表示的日期范围比DATETIME要短得多</li></ol><h1 id="时间类型DATETIME直接相减的结果"><a href="#时间类型DATETIME直接相减的结果" class="headerlink" title="时间类型DATETIME直接相减的结果"></a>时间类型DATETIME直接相减的结果</h1><p>如语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  create_time, update_time, update_time-create_time <span class="keyword">as</span> pay_time <span class="keyword">from</span> t_order;</span><br></pre></td></tr></table></figure><p>这样写是错的！<br>因为，mysql在时间相减时，做了个转换，但不是UNIX_TIMESTAMP(create_time)这样的转换，而是把DATETIME直接转成了整数，如create_time=’2020-05-15 08:55:25’转成了20200515085525，因此得到的是两个无意义的整数相减的结果。<br>因此，对于时间类型的相减，正确处理应该是 UNIX_TIMESTAMP(update_time)-UNIX_TIMESTAMP(create_time)</p><h2 id="HAVING和WHERE的不同使用场景"><a href="#HAVING和WHERE的不同使用场景" class="headerlink" title="HAVING和WHERE的不同使用场景"></a>HAVING和WHERE的不同使用场景</h2><p>WHERE 就用在普通的SELECT语句作为查询条件，而 HAVING 用在聚合函数的字段上。如语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> currency_type, <span class="keyword">sum</span>(amount) <span class="keyword">as</span> total_amount <span class="keyword">from</span> t_order <span class="keyword">where</span> merchant_id=<span class="string">'123456'</span> <span class="keyword">group</span> <span class="keyword">by</span> currency_type <span class="keyword">having</span> total_amount&gt;<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h1><ul><li><p>UNIX_TIMESTAMP() 返回秒数，也可以带上时间。示例：<br>SELECT UNIX_TIMESTAMP(‘2020-06-16’); == 1592265600<br>SELECT UNIX_TIMESTAMP(‘2020-06-16 02:00:00’); == 1592272800</p></li><li><p>FROM_UNIXTIME() 输入秒数返回日期字符串，日期格式可指定<br>SELECT FROM_UNIXTIME(1592265600); == 2020-06-16 00:00:00<br>SELECT FROM_UNIXTIME(1592265600, ‘%Y-%m-%d’); == 2020-06-16</p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务四要素ACID、隔离级别、并发问题等见博客《隔离级别与脏读等并发问题》。</p><p>MySQL对事务的处理默认是“自动提交模式”。当你用<code>SHOW GLOBAL VARIABLES LIKE &#39;%autocommit%&#39;</code>可以查看autocommit开关是否打开，默认是打开的。这意味着，MySQL会在每条SQL执行完后自动提交事务，即一条SQL就是一个事务。</p><p>当你需要让多条SQL在一个事务中，需要先把autocommit开关关闭，再用SQL关键字：BEGIN、COMMIT、ROLLBACK手动开始、提交、回滚事务。需要注意，只有InnoDB引擎的表才支持事务，即在事务中只能操作InnoDB表。</p><p>菜鸟教程，手动处理事务的SQL：<a href="https://www.runoob.com/mysql/mysql-transaction.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-transaction.html</a></p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>关系数据库表是用于存储和组织信息的数据结构。我们在实际开发过程中，可能需要各种各样的表，如查询快且少更新的表、经常更新的表。表的用途上的区别，就是对数据处理上的区别。对于MySQL来说，它提供了很多种类型的存储引擎，我们可以根据对数据处理的需求，选择不同的存储引擎，从而最大限度的利用MySQL强大的功能。</p><p>MySQL存储引擎包括：InnoDB、CSV、MyISAM、MEMORY等等。使用<code>SHOW ENGINES</code>命令可以查看你的Mysql支持的所有存储引擎。</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>特点：</p><ul><li>支持行级锁（也支持表级锁）</li><li>支持事务</li><li>支持外键（MySQL支持事务和外键的存储引擎只有InnoDB）</li><li>支持AUTO_INCREMENT列</li><li>数据和索引放在同一个文件<br>创建InnoDB表时，在”MYSQL_HOME/data/db_name”文件夹下，新增2个文件：<br>table_name.frm -&gt; 存储表定义<br>table_name.ibd -&gt; 存储数据和索引</li><li>使用聚集索引，因此表中一定有主键ID。若用户未指定，InnoDB会自动指定。聚集索引在“索引”一节介绍</li></ul><p>应用场景：</p><ul><li>要求事务安全</li></ul><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>特点：</p><ul><li>只支持表级锁</li><li>不支持事务和外键</li><li>支持AUTO_INCREMENT列</li><li>数据和索引分开放在两个文件<br>创建MyISAM表时，在”MYSQL_HOME/data/db_name”文件夹下，新增3个文件：<br>table_name.frm -&gt; 存储表定义<br>table_name.MYD -&gt; 存储数据<br>table_name.MYI -&gt; 存储索引</li><li>支持3种表：静态表、动态表、压缩表<ul><li>静态表：记录都是固定长度，存储非常迅速，容易缓存，出现故障容易恢复；但是占用的空间比较多。PS：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。</li><li>动态表：记录不是固定长度的，占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能</li><li>压缩表：因为每个记录是被单独压缩的，所以只有非常小的访问开支</li></ul></li><li>不使用聚集索引，因此表中可以没有主键ID</li></ul><p>应用场景：</p><ul><li>不要求事务安全</li><li>不经常UPDATE的表。这与“MyISAM的锁机制”有关</li></ul><blockquote><p>要对比两者的SELECT、INSERT效率，需要先了解它们在锁机制和索引上的区别。</p></blockquote><h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><p>锁的分类：</p><ul><li>表级锁：保证同一时刻只有一个线程操作<strong>该表</strong>，避免冲突<ul><li>读锁：也叫共享锁（S锁）。不拒绝其他对<strong>同张表</strong>的读请求，会拒绝对<strong>同张表</strong>的写请求。持有该锁的线程只能进行读操作</li><li>写锁：也叫排它锁（X锁）。拒绝对<strong>同张表</strong>的所有请求。持有该锁的线程可以进行读、写操作</li></ul></li><li>行级锁：保证同一时刻只有一个线程操作<strong>该记录</strong>，避免冲突<ul><li>读锁：也叫共享锁（S锁）。不拒绝其他对<strong>同条记录</strong>的读请求，会拒绝对<strong>同条记录</strong>的写请求。持有该锁的线程只能进行读操作</li><li>写锁：也叫排它锁（X锁）。拒绝对<strong>同条记录</strong>的所有请求。持有该锁的线程可以进行读、写操作</li></ul></li></ul><p>总之，在同一级中，读锁与写锁互斥，不能同时存在。写锁与其他写锁互斥，读锁与其他读锁兼容。读锁不阻碍读请求，阻碍写请求。写锁阻碍所有读写请求。</p><p>其他分类：</p><ul><li>临时锁与持续锁：指的是锁的时效性，临时锁-当前语句结束就释放锁，持续锁-当前事务结束才释放锁</li><li>乐观锁与悲观锁<ul><li>悲观锁：假定当前事务操纵数据资源时，肯定会有其他事务同时访问该数据资源，为了避免当前事务的操作受到干扰，先锁定资源。悲观锁需使用数据库的锁机制实现，如使用行级排他锁或表级排它锁。可以解决丢失更新和不可重复读，但影响并发性能</li><li>乐观锁：假定当前事务操纵数据资源时，不会有其他事务同时访问该数据资源，因此不在数据库层次上的做锁定，而使用由程序逻辑控制的技术来避免可能出现的并发问题。唯一能够同时保持高并发和高可伸缩性的方法就是使用带版本检查的乐观锁。不能解决脏读的问题，因此仍需要数据库至少启用“读已提交”的事务隔离级别。</li></ul></li></ul><h2 id="MyISAM的锁机制"><a href="#MyISAM的锁机制" class="headerlink" title="MyISAM的锁机制"></a>MyISAM的锁机制</h2><p>MyISAM只支持表级锁。</p><p>什么时候锁：</p><ul><li>执行SELECT前，会自动给所有涉及到的表加读锁</li><li>执行INSERT、UPDATE、DELETE前，会自动给所有涉及到的表加写锁</li></ul><p>锁调度：</p><ul><li>线程到来时，该表已经被锁的话，锁会放入锁等待队列中</li><li>写锁优先。同时有两个线程对同一张表分别请求读锁与写锁，先加写锁。在锁等待队列中，即使读锁请求时间更早，写锁也会放到读锁之前（用户可以修改这个规则）</li></ul><blockquote><p>因为经常性的UPDATE会不断请求表写锁，写锁优先，会导致SELECT操作阻塞，所以MyISAM表不适合经常UPDATE。</p></blockquote><p>MyISAM不会出现死锁，原因：因为MyISAM总是一次性获得所需的全部锁，例如SELECT两张表时要求一次性获得这两张表的读锁，不能全部获得就等待，直到可以全部获得为止。（可对比下面的“InnoDB为什么会出现死锁”）</p><h2 id="InnoDB的锁机制"><a href="#InnoDB的锁机制" class="headerlink" title="InnoDB的锁机制"></a>InnoDB的锁机制</h2><p>InnoDB支持行级锁、表级锁。但InnoDB的表级锁属于<strong>意向锁</strong>，和MyISAM的表级锁有点不同。</p><p>什么时候锁：</p><ul><li>行读锁：SELECT语句显式加行读锁(SELECT … LOCK IN SHARE MODE)（普通SELECT语句不会加任何锁）</li><li>行写锁：执行INSERT、UPDATE、DELETE前，会自动给所有涉及到的行加行写锁；SELECT语句显式加行写锁(SELECT … FOR UPDATE)</li><li>表读锁：也叫意向共享锁（IS锁）。给行加行读锁前，先加表读锁</li><li>表写锁：也叫意向排他锁（IX锁）。给行加行写锁前，先加表写锁</li></ul><p>总之，一个事务要查询某一行，不需要任何锁；一个事务要修改某一行，需要行写锁+表写锁。</p><p>InnoDB 的行锁比较特殊，它不是加在某个数据行上，而是加在索引上的。这意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁（非意向锁）！【InnoDB 也支持非意向的表级锁</p><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>意向锁的含义是，MySQL察觉到事务有意向对表中的某条记录加读锁/写锁，就给整张表加个表锁。但这个表锁的兼容性和MyISAM的表级锁不同。</p><h3 id="意向锁的兼容性"><a href="#意向锁的兼容性" class="headerlink" title="意向锁的兼容性"></a>意向锁的兼容性</h3><ol><li>意向锁之间：<ol><li>IS和IS兼容</li><li>IS和IX兼容</li><li>IX和IX兼容</li></ol></li><li>意向锁IX、IS和<strong>行级</strong>S锁、X锁之间：全部互相兼容！</li><li>意向锁IX、IS和<strong>表级</strong>S锁、X锁之间：<ol><li>IS和S兼容</li><li>IS和X互斥</li><li>IX和S互斥</li><li>IX和X互斥</li></ol></li></ol><p>这里所说的不同种类的锁兼容的含义是，一张表可以同时加上这些互相兼容的锁。例如“IS和IX兼容”是指，一张表中可以同时存在多个IS锁和多个IX锁。</p><h3 id="意向锁的作用"><a href="#意向锁的作用" class="headerlink" title="意向锁的作用"></a>意向锁的作用</h3><p>第一，在没有意向锁存在的情况下，当事务A准备给t_order表加表读锁（非意向锁）时，需要确认：</p><ol><li>当前表没有被加表写锁</li><li>当前表中没有记录被加行写锁</li></ol><p>为了确认第2点，事务A需要检查每一行记录的锁，效率很低。有了意向锁之后，事务A准备给t_order表加表读锁（非意向锁）时，只需要确认：</p><ol><li>当前表没有被加IX锁</li></ol><p>若确认当前表存在IX锁，事务A就能得知当前表中一定存在行写锁，就不需要检查每行记录，只需等待IX锁释放就行。</p><p>第二，意向锁之间的互相兼容，可以提高并发性能，也能保证并发环境下的事务隔离。举个例子，<br>事务A执行SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>此时t_order表存在两把锁：表上的IX锁、id=1的记录上的X锁。</p><p>事务B执行SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>因为IX锁可以兼容，所以事务B也可以给t_order表加上IX锁，再因为id=10的记录上不存在X锁，所以事务B不需要等事务A释放锁。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>InnoDB为什么会发生死锁？</p><p>在InnoDB中，锁是<strong>逐步获得</strong>的，这就决定了在InnoDB中发生死锁是可能的。</p><p>举例，下面这句SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> score = <span class="number">100</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>这一条SQL就是一个事务，这条SQL会更新满足条件的多条记录。找到第一条记录时，会给第一条记录上锁，第一条记录更新完成后，找到第二条记录并加锁，第二条更新完成再给第三条加锁，以此类推。</p><p>若这句SQL和上面那句同时开始：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> score = <span class="number">100</span> <span class="keyword">where</span> age &gt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>假设第一条SQL的加锁顺序：id = 15 -&gt; 18 -&gt; 20，第二条SQL的加锁顺序（age为普通索引，所以会用行锁）：(age, id) = (24, 18) -&gt; (24, 20) -&gt; (25, 15) -&gt; (25, 49)。其中，对 id 的加锁顺序为 id = 18 -&gt; 20 -&gt; 15 -&gt; 49。可以看到事务A先锁15，再锁18，而事务B先锁18，再锁15，从而形成死锁。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引就好比一本书的目录，它会让你更快的找到内容。但目录（索引）并不是越多越好，假如这本书1000页，有500页是目录，它当然效率低，目录是要占纸张的，而索引是要占磁盘空间的。</p><p>索引用于快速找出在某个列中有一特定值的行。如果不使用索引，MySQL必须从第1条记录开始然后读完整个表直到找出相关的行。表越大，花费的时间越多。如果表中查询的列有一个索引，MySQL能快速到达一个位置去搜寻数据文件的中间，没有必要看所有数据。（这里的原理见下面B+TREE索引的介绍）</p><p>索引是帮助MySQL高效获取数据的<strong>数据结构</strong>。</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul><li>普通索引：最基本的索引，没有任何限制</li><li>唯一索引（约束）：与”普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。可指定多个列构成一个唯一索引</li><li>主键索引（约束）：它是一种特殊的唯一索引，不允许有空值</li><li>全文索引：仅可用于MyISAM表，针对较大的数据，生成全文索引很耗时间和空间</li><li>组合索引：遵循“最左”原则。创建组合索引时应该将最常用作查询条件的列放在最左边，依次递减</li></ul><h2 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h2><p><strong>单列索引：</strong><br>    SELECT UPDATE DELETE语句中WHERE条件带上索引列<br>    SELECT语句的ORDER BY/GROUP BY带上索引列</p><p><strong>组合索引：</strong><br>    SELECT UPDATE DELETE语句中WHERE条件中一定要包含最左边的索引列</p><p><strong>注意：</strong></p><ol><li>若where条件中用到索引，则order by不会再用索引</li><li>order by不使用普通索引和组合索引</li><li>模糊查询中，若查询条件这样写：… where name like ‘%cai%’，则不会用到索引（原因是%放在最前）</li><li>mysql认为全文扫描比使用索引快时，即使where条件有索引也不会用索引，例如：在一张共100条记录的表中select前90条记录<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_order <span class="keyword">where</span> <span class="keyword">id</span>&lt;=<span class="number">90</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h2><p>B+Tree是BTree的变种，MySQL的BTree索引就使用它来作为数据结构。MyISAM表、InnoDB表的索引就是用B+Tree存储，一个索引就是一个B+Tree。在B+Tree中，非叶子节点只保存key与指针，叶子节点的两个域分别是key与data。</p><h3 id="MyISAM的B-Tree索引"><a href="#MyISAM的B-Tree索引" class="headerlink" title="MyISAM的B+Tree索引"></a>MyISAM的B+Tree索引</h3><p>在MyISAM的B+Tree中，叶子节点的data域存放的是<strong>数据记录的地址</strong>，这是因为MyISAM的索引和数据是分两个文件存放的。</p><p>下面是MyISAM索引的原理图。</p><p>主键索引（key为主键列值）：</p><img src="/2020/05/16/mysql-note/myisam_primary_key.png" class="" title="MyISAM主键索引"><p>普通索引（key为普通索引列值）：</p><img src="/2020/05/16/mysql-note/myisam_key.png" class="" title="MyISAM普通索引"><p>MyISAM的主键索引和普通索引在结构上没有任何区别，只是主键索引要求key是唯一的，而普通索引的key可以重复。<br>因此，MyISAM中索引检索的算法是：首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><h3 id="InnoDB的B-Tree索引"><a href="#InnoDB的B-Tree索引" class="headerlink" title="InnoDB的B+Tree索引"></a>InnoDB的B+Tree索引</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p>第一，MyISAM的data域仅保存数据记录的地址。而InnoDB的数据和索引存放在一个文件里，数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了<strong>完整的数据记录</strong>，key是主键列值。</p><img src="/2020/05/16/mysql-note/innodb_primary_key.png" class="" title="InnoDB主键索引"><p>这种索引就叫<strong>聚集索引</strong>，即数据和主键聚在一起。正因为InnoDB的数据文件要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>第二，InnoDB的普通索引data域存储相应记录主键的值而不是地址</p><img src="/2020/05/16/mysql-note/innodb_key.png" class="" title="InnoDB普通索引"><p>这样导致使用普通索引搜索需要检索两遍索引：首先检索普通索引获得主键，然后用主键到主索引中检索获得记录。</p><p>知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整（如主键最大是id=500，现在要插入id=400），十分低效，而使用自增字段作为主键则是一个很好的选择。另外，若使用int型字段做主键，InnoDB也会强制要求该字段设置AUTO_INCREMENT。</p><h1 id="MyISAN和InnoDB的对比"><a href="#MyISAN和InnoDB的对比" class="headerlink" title="MyISAN和InnoDB的对比"></a>MyISAN和InnoDB的对比</h1><p>在介绍MyISAM时说了它的INSERT效率高，一个原因是它不像InnoDB要检查外键约束，还要维护事务，减少了一部分开销。另一个原因是，B+Tree结构在插入新记录时要分裂调整，但MyISAM的data域存的是数据的物理地址，和InnoDB的data域就是记录相比，内容较小，分裂调整的速度更快。但是，MyISAM的INSERT效率不一定就比InnoDB高，一个是因为MyISAM的表锁，一个是因为InnoDB如果使用自增主键，B+Tree的调整就不会那么麻烦。</p><blockquote><p>什么是页？<br>“页”是指存储引擎从磁盘读取数据时，每次可以读取多少数据。换个说法，存储引擎每次从磁盘中读取一整页的数据，这“一整页的数据”有多少。为什么一次读取可以读到多条数据？这是因为B+Tree的一个叶子节点上就有多条数据，所以当查找到这个叶子节点时，就可以把这个叶子节点上的所有数据一次性读出来。<br>MySQL 页的理解：<a href="https://blog.csdn.net/li1325169021/article/details/121044179" target="_blank" rel="noopener">https://blog.csdn.net/li1325169021/article/details/121044179</a></p></blockquote><blockquote><p>InnoDB插入数据会进行什么分裂调整？<br>因为InnoDB的数据位置是按照主键的顺序安排的，主键相近的，数据会在一个叶子节点上。若主键不是规律自增的，就会在插入时要B+Tree重新调整主键位置，即调整了数据的位置，原本靠在一起的数据也许会被分开。靠在一起的数据在一个叶子节点上，即在一个“页”上，所以这就导致了“页”的分裂。而如果主键自增，那么每次插入都是在B+Tree的最后新增数据，不会改变前面数据的位置，不用进行页分裂。</p></blockquote><p>另外，在查询效率上，也不能确定MyISAM和InnoDB谁更高，只能说各自都有优势。MyISAM的主键索引和普通索引的data域都是数据的物理地址，而InnoDB用普通索引检索时要搜两遍索引。但是，MyISAM和InnoDB的缓存机制不同（见下一节缓存池），MyISAM只缓存索引，InnoDB缓存索引和数据。因此，MyISAM每次查找就要从磁盘里拿数据，而InnoDB首先从内存里获取数据，如果没有再到磁盘里拿。InnoDB内存里的数据不是一下子就缓存。InnoDB在一次IO读取中，就会把这个节点上的所有数据缓存，若下次查找的数据还在这个节点上，就可以直接从缓存中取了。如果InnoDB内存足够大，查询足够多，InnoDB速率可能会超过MyISAM。</p><p>再者，如果InnoDB用主键进行范围查找，效率是很高的，因为它相近的数据都因为主键的原因在一个“页”上，这就是聚集索引，而MyISAM的主键不是聚集索引，数据的物理地址并不会靠在一起。</p><p>但是，需要注意的是，InnoDB查找时用到了索引，才会加行锁，否则是加表锁。</p><h1 id="MyISAN和InnoDB的缓存池"><a href="#MyISAN和InnoDB的缓存池" class="headerlink" title="MyISAN和InnoDB的缓存池"></a>MyISAN和InnoDB的缓存池</h1><p>MyISAN 的缓存池叫“Key Cache”，它只缓存索引，不缓存数据，所以 MyISAM 取数据要从磁盘中取。</p><p>InnoDB 的缓存池叫“Buffer Pool”，中文名叫“缓存池”“缓冲池”，它缓存索引，也缓存数据。</p><p>缓存池的缓存算法都是 LRU（最近最少使用算法），都占用系统内存空间。</p><h1 id="推荐博客"><a href="#推荐博客" class="headerlink" title="推荐博客"></a>推荐博客</h1><p>常见的锁类型，还介绍了索引结构：<a href="https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html" target="_blank" rel="noopener">https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html</a></p><p>意向锁的作用：<a href="https://juejin.im/post/5b85124f5188253010326360" target="_blank" rel="noopener">https://juejin.im/post/5b85124f5188253010326360</a></p><p>介绍了 MYSQL 中的几乎所有名词概念，和简单原理：<a href="https://zhuanlan.zhihu.com/p/406861878" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/406861878</a></p><p>MySQL中MyISAM引擎及InnoDB引擎的缓存优化设计：<a href="https://www.cnblogs.com/iamsupercp/p/3682502.html" target="_blank" rel="noopener">https://www.cnblogs.com/iamsupercp/p/3682502.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法谜题》笔记</title>
      <link href="/2020/05/16/algorithmic-puzzles-note/"/>
      <url>/2020/05/16/algorithmic-puzzles-note/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　《算法谜题》中的题目，主要目的在于训练一种思维方式。这篇博客就是整理这本书中一些我认为有意思的题目。</p><h1 id="三阶幻方"><a href="#三阶幻方" class="headerlink" title="三阶幻方"></a>三阶幻方</h1><p>将1~9这9个不同的数字填入3x3的幻方，使得每行、每列、每条对角线的和相等。</p><h2 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h2><p>第一个格子可填9个数，第二个格子可填8个数，第三个格子可填7个数，以此类推，产生的可能解有9!（9的阶乘）个。对于n阶幻方，可能解数量是 (n^2)! 个。</p><h2 id="缩小范围的解法"><a href="#缩小范围的解法" class="headerlink" title="缩小范围的解法"></a>缩小范围的解法</h2><p>按以下步骤进行：</p><ol><li>这个每行、每列、每条对角线的和（称为幻和）等于15：1加到9的总和为45，3行，每行和为15</li><li>中间格子应该填5：经过中间格子的有4条线（横竖2条，斜的2条），这4条线上数字总和=15*4=45+中间格*3=15*3+中间格*3，即15=中间格*3，因此中间格=5</li><li>4组数字对(1,9) (2,8) (3,7) (4,6)，2条对角线上应该填偶数对(2,8) (4,6)：因为幻和15为奇数，所以在不经过中间格的4条线上的数字组合必须为2个偶数+1个奇数（2奇+1偶=偶），只有当对角线上都是偶数时才满足这个条件</li></ol><p>按照以上步骤，就可以得到三阶幻方的一种答案，其他答案就是由这个答案镜面翻转得到（三阶幻方一共有8个答案）。</p><h2 id="楼梯法"><a href="#楼梯法" class="headerlink" title="楼梯法"></a>楼梯法</h2><p>世界上已经有很多构造奇数阶幻方的方法了，如楼梯法、杨辉法，其中楼梯法比较适合写程序（楼梯法的介绍可以上网查）。<br>下面是实现构造k阶奇数幻方的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSquareOdd</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[][] sq = <span class="keyword">new</span> <span class="keyword">int</span>[k][k];</span><br><span class="line"><span class="comment">// 第一个数填在第一行中间</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>; <span class="comment">// 行</span></span><br><span class="line"><span class="keyword">int</span> y = k / <span class="number">2</span>; <span class="comment">// 列</span></span><br><span class="line"><span class="keyword">int</span> total = k * k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= total; i++) &#123; <span class="comment">// 按照顺序填数</span></span><br><span class="line">sq[x][y] = i;</span><br><span class="line"><span class="comment">// 下一个数填在当前位置的右上格子</span></span><br><span class="line"><span class="keyword">int</span> nextX = (x - <span class="number">1</span> + k) % k; <span class="comment">// 行-1</span></span><br><span class="line"><span class="keyword">int</span> nextY = (y + <span class="number">1</span>) % k; <span class="comment">// 列+1</span></span><br><span class="line"><span class="keyword">if</span> (sq[nextX][nextY] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 右上格子已经有数字，则填在当前位置的下一格（行+1，列不变）</span></span><br><span class="line">x = (x + <span class="number">1</span>) % k;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x = nextX;</span><br><span class="line">y = nextY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; k; n++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">System.out.print(sq[n][m] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h1><p>将n个皇后放置在n*n的国际象棋棋盘上，其中没有任何两个皇后处于同一行、同一列、同一对角线上。</p><h2 id="穷举法-1"><a href="#穷举法-1" class="headerlink" title="穷举法"></a>穷举法</h2><p>组合公式，从n个对象中选k个对象，不考虑k个对象的排列顺序：C(n,k)<br>穷举法要考虑的所有可能解的个数，即从n*n个格子中选出n个格子的组合个数C(n^2,n)。当n=4时，C(16,4)=1820，因此用穷举法解4皇后问题需要遍历1820个组合。</p><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>回溯法是对穷举法的一种改进，它采用走一步添加一个组件的方式，同时评估这一步中添加的组件是否符合题目要求，若不符合就返回上一步（回溯），从上一步重新开始考虑其他走法，若上一步往下的所有路都走不通，则再往上回溯；若符合就从这一步继续往下走，直到得出答案。<br>因此，回溯法需要遍历的可能解的数量会比穷举法少，当n=4时，考虑皇后必须放置在不同行和不同列，即第1个皇后有4种放法，第2个有3种，以此类推，可能解的数量为4!=24。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">// 存储每行放置的列的位置，如 result[0]=1 表示放在第一行第二列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">findColumn(r); <span class="comment">// 递归方法，因为要回溯，所以想到用递归实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 因为是按照每行来填，所以检查时只考虑前几行的放置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line"><span class="comment">// 和当前位置同列 || 和当前位置同一对角线</span></span><br><span class="line"><span class="keyword">if</span> ((result[i] == c) || (Math.abs(r - i) == Math.abs(c - result[i]))) &#123;</span><br><span class="line">System.out.println(<span class="string">"当前坐标：("</span> + r + <span class="string">","</span> + c + <span class="string">")和已有位置("</span> + i + <span class="string">","</span> + result[i] + <span class="string">")冲突"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findColumn</span><span class="params">(<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r == n) &#123; <span class="comment">// 每行都放完了，打印这条路的解,这条路结束</span></span><br><span class="line"><span class="comment">// print</span></span><br><span class="line">System.out.println(<span class="string">"result: "</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">System.out.println(result[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"----------------------"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++) &#123; <span class="comment">// 列</span></span><br><span class="line">System.out.println(<span class="string">"当前坐标：("</span> + r + <span class="string">","</span> + c + <span class="string">")"</span>);</span><br><span class="line"><span class="keyword">if</span> (isValid(r, c)) &#123;</span><br><span class="line">System.out.println(<span class="string">"当前坐标：("</span> + r + <span class="string">","</span> + c + <span class="string">")填1"</span>);</span><br><span class="line">result[r] = c;</span><br><span class="line">findColumn(r + <span class="number">1</span>);<span class="comment">// 寻找下一行的列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码时间复杂度为O(n^n)，即n的n次方，因为有n次递归，每次递归中遍历n列。空间复杂度为O(n)，因为用到了result[n]数组。</p><h3 id="位运算改进版实现"><a href="#位运算改进版实现" class="headerlink" title="位运算改进版实现"></a>位运算改进版实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">4</span>; <span class="comment">// n皇后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 解的总数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">find(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> row</span></span><br><span class="line"><span class="comment"> *            标记每列已占用的位置，已占用为1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ld</span></span><br><span class="line"><span class="comment"> *            标记左对角线上不能放的位置，不能放为1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rd</span></span><br><span class="line"><span class="comment"> *            标记右对角线上不能放的位置，不能放为1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> ld, <span class="keyword">int</span> rd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos, p;</span><br><span class="line"><span class="keyword">int</span> all1 = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; <span class="comment">// 1左移n位再减0001，得到n个1组成的二进制数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (row != all1) &#123;</span><br><span class="line"><span class="comment">// row，ld，rd进行“或”运算，求得所有可以放置皇后的列,对应位为0</span></span><br><span class="line"><span class="comment">// 然后取反后“与”上全1的数，来求得当前所有可以放置皇后的位置，对应列改为1</span></span><br><span class="line">pos = all1 &amp; (~(row | ld | rd));</span><br><span class="line">System.out.println(<span class="string">"可放的位置："</span> + Integer.toBinaryString(pos));</span><br><span class="line"><span class="keyword">while</span> (pos != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// pos取反+1 &amp; pos 得到pos中最右边的1</span></span><br><span class="line">p = pos &amp; (~pos + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// pos去掉最右列（最右列已占用）</span></span><br><span class="line">pos = pos - p;</span><br><span class="line"><span class="comment">// rowp 下一行已占用的列</span></span><br><span class="line"><span class="comment">// (ld|p)&lt;&lt;1 下一行不能放的列（因为左对角线被占用）</span></span><br><span class="line"><span class="comment">// (rd|p)&gt;&gt;1 下一行不能放的列（因为右对角线被占用）</span></span><br><span class="line">find(row | p, (ld | p) &lt;&lt; <span class="number">1</span>, (rd | p) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 每列都放了</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="n-gt-3时的通用解法"><a href="#n-gt-3时的通用解法" class="headerlink" title="n&gt;3时的通用解法"></a>n&gt;3时的通用解法</h2><p>因为n=1有一个解，n=2和n=3无解，所以只研究n&gt;3的通用解法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot AOP 实践与原理</title>
      <link href="/2020/03/02/springboot-aop/"/>
      <url>/2020/03/02/springboot-aop/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客先从AOP的代码编写讲起，接着介绍AOP的实现原理，其中包括动态代理的概念，最后介绍Spring中可以直接用的AOP注解。</p><h1 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h1><h2 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建切面类"><a href="#创建切面类" class="headerlink" title="创建切面类"></a>创建切面类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//声明这是一个组件</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//声明这是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义切入点"><a href="#定义切入点" class="headerlink" title="定义切入点"></a>定义切入点</h2><p>切入点就是你要在哪个包下的哪个类的哪个方法执行切面逻辑，或者说指定切入哪里。<strong>Spring AOP的切入点只能是方法。</strong><br>可以在一个切面类中定义多个切入点，再给每个切入点指定不同的Advice方法（Advice方法介绍见下一节）。<br>定义切入点有两种方式：</p><ol><li>用execution表达式定义切入点</li><li>用自定义注解定义切入点</li></ol><h3 id="用execution表达式定义切入点"><a href="#用execution表达式定义切入点" class="headerlink" title="用execution表达式定义切入点"></a>用execution表达式定义切入点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.sample.service.impl..*.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例表示在com.sample.service.impl包（含子包）下的所有类的所有方法切入。下面把这个示例拆解看看execution表达式的格式。</p><table><thead><tr><th align="left">符号</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">第一个”*”符号</td><td align="left">表示返回值的类型任意</td></tr><tr><td align="left">com.sample.service.impl</td><td align="left">要切入的类所在包名</td></tr><tr><td align="left">包名后面的”..”</td><td align="left">表示当前包及子包</td></tr><tr><td align="left">第二个”*“符号</td><td align="left">表示类名，*即任意类，也可指定具体的类，或带前后缀的类，如 *Service</td></tr><tr><td align="left">.*(..)</td><td align="left">表示任何方法名，括号表示参数，两个点表示任何参数类型</td></tr></tbody></table><p>如何使用这个切入点？示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)<span class="comment">// 这个注解以及它所修饰的方法的介绍见下一节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要同时指定<strong>多个切入点</strong>，用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut1() || pointcut2()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用自定义注解定义切入点"><a href="#用自定义注解定义切入点" class="headerlink" title="用自定义注解定义切入点"></a>用自定义注解定义切入点</h3><p>假设已有自定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME )</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义切入点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.example.demo.aop.Log)"</span>) <span class="comment">// 自定义注解的限定类名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例表示切入所有加了<code>@Log</code>属性的方法，比如下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"><span class="meta">@Log</span>(<span class="string">"添加用户操作"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user/add"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"add"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个切入点的方法和用“execution表达式”定义的切入点没有区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)<span class="comment">// 这个注解以及它所修饰的方法的介绍见下一节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这只是“自定义注解”定义的切入点的其中一种使用方式，这种使用方式的一个缺点是不能访问自定义注解<code>@Log</code>的value属性。<br>另一种使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(log)"</span>) <span class="comment">// 括号里的名字和注解参数名必须相同</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint, Log log)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 方法逻辑...</span></span><br><span class="line">     System.out.println(log.value()); <span class="comment">// 可以访问注解属性值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种使用方式的区别就是，切入点直接写在<code>@Before</code>注解中，不需要再用pointcut()方法定义切入点</p><p>和execution表达式相比，用自定义注解定义切入点，可以灵活安排切入的方法（想切哪里注解就加在哪里），且通过自定义注解的属性，在切面类中也能了解到被切方法的业务逻辑，若要在切面类中统一打印被切方法的日志，这点很好用。</p><h2 id="根据业务逻辑编写Advice方法"><a href="#根据业务逻辑编写Advice方法" class="headerlink" title="根据业务逻辑编写Advice方法"></a>根据业务逻辑编写Advice方法</h2><p>Advice，有翻译为“增强处理”，也有翻译为“通知”，本质含义就是要执行的切面逻辑，如要在每个方法开始前打印入参日志，就可以编写Before类型的Advice方法，如要在每个方法抛出异常后统一处理，就可以编写AfterThrowing类型的Advice方法。Advice一共有五种类型：</p><ul><li>Before</li><li>After</li><li>AfterReturning</li><li>AfterThrowing</li><li>Around</li></ul><p>这些类型的共同特点：</p><ul><li>所有类型的注解都有两个属性：value、argNames。value属性用于指定切入点，argNames属性可以用来访问目标方法的入参</li><li>除<code>Around</code>之外，其他四种类型的方法的连接点参数都只能是JoinPoint，不能是ProceedingJoinPoint（ProceedingJoinPoint是JoinPoint的子类）</li><li>只有<code>Around</code>方法能改变目标方法的入参和返回值</li></ul><p>下面分别介绍这五种类型的特点和使用方法。</p><h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><p>在目标方法执行前织入，不能访问目标方法的返回值，可选参数有JoinPoint。<br><code>@Before</code>注解属性：value、argNames</p><blockquote><p>JoinPoint简单介绍：<br>JoinPoint参数不必须，但需要时必须作为第一个参数！<br>常用方法有：<br>Object[] getArgs：返回目标方法的参数<br>Signature getSignature：返回目标方法的签名(含方法名和参数表)</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"============before============"</span>);</span><br><span class="line">    System.out.println(<span class="string">"目标方法名为:"</span> + joinPoint.getSignature().getName()); <span class="comment">// 打印方法名add</span></span><br><span class="line">    System.out.println(<span class="string">"目标方法所属类的类名:"</span> + joinPoint.getSignature().getDeclaringTypeName());<span class="comment">// 打印全限定类名com.example.demo.controller.UserController</span></span><br><span class="line">    <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"第"</span> + (i+<span class="number">1</span>) + <span class="string">"个参数为:"</span> + args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><p>在目标方法结束后织入，不管目标方法如何结束（正常还是异常），它都会被织入，可选参数有JoinPoint。<br><code>@After</code>注解和<code>@Before</code>注解属性相同：value、argNames<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"============after============"</span>);</span><br><span class="line">    <span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AfterReturning"><a href="#AfterReturning" class="headerlink" title="AfterReturning"></a>AfterReturning</h3><p>在目标方法正常完成后被织入，抛出异常了不织入，可选参数有JoinPoint和Object（目标方法的返回值）。<br><code>@AfterReturning</code>注解除了value、argNames这两个属性外，还有一个属性：</p><ul><li>returning：指定一个返回值形参名，可以通过该形参名来访问目标方法的返回值，但不可修改目标方法的返回值</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(pointcut = <span class="string">"pointcut()"</span>, returning = <span class="string">"returnObject"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(JoinPoint joinPoint, Object returnObject)</span> </span>&#123; <span class="comment">// 返回值的形参名与注解中的保持一致</span></span><br><span class="line">    System.out.println(<span class="string">"============afterReturning============"</span>);</span><br><span class="line">    <span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line">    <span class="comment">// 访问目标方法的返回值</span></span><br><span class="line">    System.out.println(<span class="string">"返回值："</span> + returnObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AfterThrowing"><a href="#AfterThrowing" class="headerlink" title="AfterThrowing"></a>AfterThrowing</h3><p>在目标方法抛出异常时织入，正常完成不织入，可选参数有JoinPoint和Throwable（目标方法抛出的异常）。<br><code>@AfterThrowing</code>注解除了value、argNames这两个属性外，还有一个属性：</p><ul><li>throwing：指定一个异常形参名，形参可用于访问目标方法抛出的异常</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(throwing = <span class="string">"e"</span>, pointcut = <span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable e)</span> </span>&#123; <span class="comment">// 异常的形参名与注解中的保持一致</span></span><br><span class="line">System.out.println(<span class="string">"============afterThrowing============"</span>);</span><br><span class="line"><span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line"><span class="comment">// 打印异常</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这个AfterThrowing只能用在打印异常信息，不能对抛出的异常做更多处理，也不能针对异常来改变目标方法的返回值。<br>想要根据异常信息修改目标方法返回值，只能用下面讲的Around。</p><h3 id="Around"><a href="#Around" class="headerlink" title="Around"></a>Around</h3><ul><li>可以在执行目标方法前织入，也可以在执行后织入</li><li>可以决定目标方法在什么时候执行，如何执行，可以完全阻止目标方法的执行</li><li>可以修改目标方法的参数值，也可以修改目标方法的返回值</li><li>至少包含一个参数，且第一个参数必须是ProceedingJoinPoint</li><li>在方法体内，调用ProceedingJoinPoint的proceed()方法才会执行目标方法。如果方法体内没有调用这个proceed()方法，则目标方法不会执行</li><li>最后必须把获得的目标方法的返回值，作为@Around方法的返回值return回去(因为如果无返回值的话，将不会继续执行目标方法)</li></ul><p><code>@Around</code>注解属性：value、argNames</p><p>第一个示例，没修改目标方法入参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">          <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">          Object[] args = joinPoint.getArgs();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">              System.out.println(<span class="string">"第"</span> + (i+<span class="number">1</span>) + <span class="string">"个参数为:"</span> + args[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 返回值</span></span><br><span class="line">          Object re = joinPoint.proceed();</span><br><span class="line">          <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第二个示例，修改了目标方法入参（入参为基本类型和String）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">        <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 修改参数值</span></span><br><span class="line">            args[i] += <span class="string">"updated"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        Object re = joinPoint.proceed(args); <span class="comment">// 这里要把修改后的args作为proceed方法的参数</span></span><br><span class="line">        <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个示例，修改了目标方法入参（入参为对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">        <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        Object param = args[<span class="number">0</span>];</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">if</span>(param <span class="keyword">instanceof</span> Person)</span><br><span class="line">        person = (Person) param;</span><br><span class="line">        person.setAddress(<span class="string">"address"</span>); <span class="comment">// 修改参数对象属性</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        Object re = joinPoint.proceed(); <span class="comment">// 这里不用再把修改后的args作为proceed方法的参数</span></span><br><span class="line">        <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，关于Around中的异常捕获：</p><ol><li>只有从目标方法中抛出的异常才会被捕获，若目标方法内自己try-catch异常了没有抛出，就不会触发Around的异常捕获</li><li>Around中处理异常，返回的响应类型必须和目标方法声明的一致，即必须是目标方法的返回类及其子类，否则会出现强制转换报错</li></ol><h1 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h1><p>AOP的全称是Aspect Oriented Programming，面向切面编程，它是通过动态代理技术，将Aspect方法中的逻辑完整织入到切入点中。下面开始先介绍静态代理（即设计模式中的代理模式），再介绍动态代理，最后再说说Spring是怎么用动态代理实现AOP的。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在设计模式中，常用到代理模式，它一般由一个接口和这个接口的两个实现类组成。<br>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"message: "</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProxy</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Service service; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceProxy</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">doBefore();</span><br><span class="line"><span class="keyword">this</span>.service.printMessage(msg);</span><br><span class="line">doAfter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行代理方法前的处理（前置处理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========proxy start========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行完代理方法后的处理（后置处理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========proxy end========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代理类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">ServiceProxy proxy = <span class="keyword">new</span> ServiceProxy(service);</span><br><span class="line">proxy.printMessage(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，静态代理需要我们自己编写代理类ServiceProxy，在它的printMessage方法中加上前置处理和后置处理。而动态代理，就不用我们自己写代理类，就能把我们指定的前置后置处理方法加到被代理方法的前后流程中。下面介绍动态代理的实现。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理，简单地说，就是不用自己写代理类，而是在<strong>运行时</strong>自动生成代理类和代理类对象。<br>接口Service和实现类ServiceImpl代码同上，不再赘述。</p><p>动态代理类：<br>作用：在运行时生成被代理类对象，规定执行被代理对象的目标方法的流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object _obj = <span class="keyword">null</span>; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object _obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>._obj = _obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   proxy 代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   method 被代理对象的目标方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   args 被代理对象的目标方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  被代理对象的目标方法的执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// 此处可以编写前置处理...</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(_obj, args); <span class="comment">// 反射执行被代理对象的目标方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用动态代理类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(service); <span class="comment">// 放入被代理对象</span></span><br><span class="line"><span class="comment">// 使用JDK中的Proxy类生成Service类的代理对象</span></span><br><span class="line">Service proxy = (Service) Proxy.newProxyInstance(service.getClass().getClassLoader(),</span><br><span class="line">service.getClass().getInterfaces(), dynamicProxy); </span><br><span class="line">proxy.printMessage(<span class="string">"hello"</span>); <span class="comment">// 这一步其实就是执行dynamicProxy.invoke方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码很简单地实现了动态代理：自己不用写Service类的代理类，运行时才生成Service类的代理类和代理对象。</p><blockquote><p>Proxy.newProxyInstance 生成代理类的原理在这篇博客： <a href="https://blog.csdn.net/weixin_45505313/article/details/106399906" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45505313/article/details/106399906</a><br>大致的原理就是，代理类由代理类工厂 ProxyClassFactory 调用 native 方法生成代理类的 .class 文件，放入内存，这样不需要重复生成。生成的代理类的名字是‘包名+$Proxy+id’</p></blockquote><p>当然AOP的实现没有这么简单，它还需要把切面类织入到切入点中。</p><h2 id="AOP的动态代理"><a href="#AOP的动态代理" class="headerlink" title="AOP的动态代理"></a>AOP的动态代理</h2><p>以下代码可以简单实现AOP逻辑。<br>接口Service和实现类ServiceImpl代码同上，不再赘述。</p><p>切面接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aspect</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">useAround</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectImpl</span> <span class="keyword">implements</span> <span class="title">Aspect</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doBefore========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAfter========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAfterReturning========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAfterThrowing========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"========doAround Start========"</span>);</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">System.out.println(<span class="string">"========doAround End========"</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">useAround</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object _obj = <span class="keyword">null</span>; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Aspect _aspect; <span class="comment">// 切面类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object _obj, Aspect _aspect)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>._obj = _obj;</span><br><span class="line"><span class="keyword">this</span>._aspect = _aspect;</span><br><span class="line">Object proxy = Proxy.newProxyInstance(_obj.getClass().getClassLoader(), _obj.getClass().getInterfaces(), <span class="keyword">this</span>); <span class="comment">// 代理对象</span></span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment"> *            代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> *            被代理对象的目标方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> *            被代理对象的目标方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被代理对象的目标方法的执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">Object result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">_aspect.doBefore();</span><br><span class="line"><span class="keyword">if</span> (_aspect.useAround()) &#123;</span><br><span class="line">result = _aspect.doAround(_obj, method, args);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = method.invoke(_obj, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">hasException = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_aspect.doAfter();</span><br><span class="line"><span class="keyword">if</span> (hasException) &#123;</span><br><span class="line">_aspect.doAfterThrowing();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">_aspect.doAfterReturning();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用动态代理类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy();</span><br><span class="line">Service proxy = (Service) dynamicProxy.getProxy(service, <span class="keyword">new</span> AspectImpl());</span><br><span class="line">proxy.printMessage(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doBefore&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAround Start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">message: hello</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAround End&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAfter&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAfterReturning&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>可以看出，以上代码成功把切面类AspectImpl的逻辑织入到了被代理对象的目标方法中。因此，Spring AOP的原理就是，Spring中有一个类似于动态代理类DynamicProxy的类，帮我们把切面类织入到切入点了。</p><h1 id="Spring中已实现的AOP"><a href="#Spring中已实现的AOP" class="headerlink" title="Spring中已实现的AOP"></a>Spring中已实现的AOP</h1><p>Spring中有一些已经写好的切面逻辑，可以直接拿来用。</p><h2 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h2><p>用<code>@ControllerAdvice</code>注解修饰的类，可以对Controller中用<code>@RequestMapping</code>修饰的方法做切面处理，最常用的是统一处理Controller方法抛出的异常。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span> <span class="comment">// 响应体是json格式就必须加这个注解</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>) // 指定抛出的异常类型</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">JSONObject</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123; <span class="comment">// 在这个方法中写抛出异常后的处理</span></span><br><span class="line">System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">json.put(<span class="string">"code"</span>, <span class="string">"9999"</span>);</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"System Error"</span>);</span><br><span class="line"><span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例是指，当Conrtroller方法中抛出异常时，统一返回<strong>{“msg”:”System Error”,”code”:”9999”}</strong>响应体。<br>若需要统一跳到某个页面，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>) // 指定抛出的异常类型</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ModelAndView</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123; <span class="comment">// 在这个方法中写抛出异常后的处理</span></span><br><span class="line">    System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">//指定错误页面的模板页</span></span><br><span class="line">        mav.setViewName(<span class="string">"error"</span>);</span><br><span class="line">        mav.addObject(<span class="string">"code"</span>, ex.getCode());</span><br><span class="line">        mav.addObject(<span class="string">"msg"</span>, ex.getMsg());</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：当AOP切面和@ControllerAdvice同时存在，且AOP切面里也会统一处理Controller抛出的异常，@ControllerAdvice就不一定会执行。请看下面的例子。<br>AOP切面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(log)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint, Log log)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">            <span class="comment">// 返回值</span></span><br><span class="line">            Object re = joinPoint.proceed();</span><br><span class="line">            <span class="keyword">if</span>(re <span class="keyword">instanceof</span> JSONObject)</span><br><span class="line">            result = (JSONObject) re;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            result.put(<span class="string">"code"</span>, <span class="string">"9998"</span>);</span><br><span class="line">            result.put(<span class="string">"msg"</span>, <span class="string">"error"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ControllerAdvice的修饰类同上，不再赘述。<br>运行时发现，目标方法抛出异常时，会统一返回<strong>{“msg”:”error”,”code”:”9998”}</strong>，而不会返回@ControllerAdvice中的<strong>{“msg”:”System Error”,”code”:”9999”}</strong>。原因就是AOP中已经处理好异常了。<br>若仍然想把异常交给@ControllerAdvice处理，AOP切面可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(log)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint, Log log)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">            <span class="comment">// 返回值</span></span><br><span class="line">            Object re = joinPoint.proceed();</span><br><span class="line">            <span class="keyword">if</span>(re <span class="keyword">instanceof</span> JSONObject)</span><br><span class="line">            result = (JSONObject) re;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e; <span class="comment">// 把异常抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，目标方法抛出异常时，会统一返回@ControllerAdvice中的<strong>{“msg”:”System Error”,”code”:”9999”}</strong>。原因就是AOP中把异常抛出了。</p><h3 id="404异常处理"><a href="#404异常处理" class="headerlink" title="404异常处理"></a>404异常处理</h3><p>没有什么特殊配置的情况下，Spring Boot遇到404就会自动跳到Spring Boot的error页面。若想要自己处理404异常，可以使用@ControllerAdvice。顺便一提，由于接口不存在，所以404异常肯定不会被AOP切面处理。<br>要处理404异常，必须在配置文件中加上：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出现错误时, 直接抛出异常</span></span><br><span class="line"><span class="attr">spring.mvc.throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 不要为我们工程中的资源文件建立映射</span></span><br><span class="line"><span class="attr">spring.resources.add-mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这个配置一定要加，否则Spring Boot总是会帮我们处理404异常，而不会进入我们定义的方法中。<br>然后就是在@ControllerAdvice中处理404，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">JSONObject</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line"><span class="keyword">if</span>(ex <span class="keyword">instanceof</span> NoHandlerFoundException) &#123; <span class="comment">// 404异常</span></span><br><span class="line">json.put(<span class="string">"code"</span>, <span class="string">"9997"</span>);</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"No Found"</span>);</span><br><span class="line"><span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line">json.put(<span class="string">"code"</span>, <span class="string">"9999"</span>);</span><br><span class="line">json.put(<span class="string">"msg"</span>, <span class="string">"System Error"</span>);</span><br><span class="line"><span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以发现，访问不存在的URI时，会统一返回<strong>{“msg”:”No Found”,”code”:”9997”}</strong>。</p><h2 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h2><p>这个注解帮你实现了数据库事务逻辑，尤其是事务回滚。<br>举个例子，删除用户时，要把用户关联的权限一起删除，当删除用户成功但删除权限不成功时，应该把删除用户的操作回滚，使得数据一致。<br>服务层示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaintainService</span> <span class="keyword">implements</span> <span class="title">IMaintainService</span></span>&#123;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">// 事务回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，当deletePersonPrivilege方法抛出异常时，deleteById方法会被回滚，即数据库中用户和用户权限依然存在，说明回滚成功。另外，回滚成功后，依然会进入AOP切面中的异常捕获。<br>下面介绍<code>@Transactional</code>注解使用的注意点。</p><h3 id="Transactional只能用在public方法上"><a href="#Transactional只能用在public方法上" class="headerlink" title="@Transactional只能用在public方法上"></a>@Transactional只能用在public方法上</h3><p>Spring在回滚前会检查方法修饰符是不是public，是才回滚。</p><h3 id="Transactional的rollbackFor属性"><a href="#Transactional的rollbackFor属性" class="headerlink" title="@Transactional的rollbackFor属性"></a>@Transactional的<strong>rollbackFor</strong>属性</h3><p>默认情况下，只有抛出Error类，或RuntimeException类及其子类的异常，Spring才会回滚。其他类型的异常不会回滚。<br>若需要在抛出其他异常时回滚，可以指定<strong>rollbackFor</strong>属性，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor=Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">deletePerson</span>(<span class="title">int</span> <span class="title">personId</span>) </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，只有抛出Exception类及其子类的异常，Spring才会回滚。</p><h3 id="自调用问题"><a href="#自调用问题" class="headerlink" title="自调用问题"></a>自调用问题</h3><p>上面的示例，<code>@Transactional</code>注解修饰的方法会直接被Controller层接口调用，这种情况下都能回滚成功。但也有一些特殊情况。<br>情况1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，<code>@Transactional</code>不会生效。应改为下面这样才能生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 异步调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 异步调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">personMapper.deleteById(personId);</span><br><span class="line">personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种有异步线程存在的情况下，<code>@Transactional</code>无论加在哪个方法都不会生效。<br>因此，只有把<code>@Transactional</code>注解加在直接被外部调用的方法才能生效。</p><h1 id="Spring-AOP和AspectJ的关系"><a href="#Spring-AOP和AspectJ的关系" class="headerlink" title="Spring AOP和AspectJ的关系"></a>Spring AOP和AspectJ的关系</h1><p>AspectJ是一个独立的AOP框架，它有自己的一套语法用来实现AOP，用它的语法写的代码文件是.aj文件，还有自己的编译器ajc（Java编译器是javac），负责把.aj编译为.class文件。AspectJ在编译时就生成了代理类，所以它是静态代理。Spring的切入点只能是方法，但AspectJ可以用于字段、类等等，它的实现比Spring AOP要复杂的多。</p><p>在我们上面的实践中，都是用注解来编写切面类，这些注解是AspectJ的jar包提供的，但对于AOP功能的实现，用的是JDK或CGLIB的动态代理。因此，Spring AOP和AspectJ的关系就是，Spring用到了AspectJ的注解，但没有用它的语法和编译器，也没有用AspectJ的静态代理来实现功能。</p><h1 id="JDK和CGLIB"><a href="#JDK和CGLIB" class="headerlink" title="JDK和CGLIB"></a>JDK和CGLIB</h1><ol><li>JDK动态代理。只能代理实现了接口的类。上面代码所展现的就是这个机制。它是用Proxy.newProxyInstance()方法生成代理类，用InvocationHandler向代理类织入AOP逻辑</li><li>CGLIB动态代理。不要求被代理类必须实现接口，但不能代理final类。它是用Enhancer类创建<em>被代理类的子类</em>作为代理类，底层是用字节码创建子类，用MethodInterceptor向子类织入AOP逻辑</li></ol><p>在SpringBoot2.0之前，Spring默认用JDK动态代理，只有当被代理类没有实现接口时，Spring才用CGLIB动态代理。在SpringBoot2.0之后，无论被代理类是否实现接口，Spring默认都用CGLIB动态代理。</p><blockquote><p>想要自行实现CGLIB动态代理，看这篇博客：<a href="https://www.jianshu.com/p/13fa41aa18d8" target="_blank" rel="noopener">https://www.jianshu.com/p/13fa41aa18d8</a></p></blockquote><blockquote><p>JDK为什么只能代理实现了接口的类？</p></blockquote><p>JDK用Proxy.newProxyInstance()方法生成的代理类类似于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">HelloService</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>因为既要继承Proxy，又要继承接口，所以另一个只能是接口。</p><blockquote><p>SpringBoot2.0之后，为什么默认用CGLIB动态代理？</p></blockquote><p>官方的回答是，We’ve generally found cglib proxies less likely to cause unexpected cast exceptions.他们认为使用cglib更不容易出现转换错误。<br>如果我们的代码写成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserServiceImpl userService;</span><br></pre></td></tr></table></figure><p>这个时候，如果是JDK动态代理，那在启动时就会报错：因为JDK动态代理是基于接口的，代理生成的对象只能赋值给接口类型。CGLIB就不会报错<br>如果想设置默认使用JDK动态代理，可以加上配置项spring.aop.proxy-target-class=false。</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><ol><li>JDK和CGLIB都是在运行期生成代理类的字节码。区别在于，JDK是直接写Class字节码，CGLIB使用ASM框架写Class字节码，CGLIB代理实现更复杂，生成代理类的效率比JDK低。</li><li>JDK调用代理方法，是通过反射机制调用。CGLIB是通过FastClass机制直接调用方法，CGLIB执行效率更高。但，在JDK1.8后，Java的反射调用效率有所改善，整体的动态代理速度已经可以和CGLIB媲美了。</li></ol><blockquote><p>什么是FastClass机制？</p></blockquote><p>FastClass机制的原理简单来说就是：为代理类和被代理类各生成一个Class，这个Class会为代理类或被代理类的方法分配一个index(int类型)。这个index当做一个入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比JDK动态代理通过反射调用高。</p><blockquote><p>JDK1.8后，Java的反射调用效率有哪些改善？</p></blockquote><p>在1.8之前，JVM把缓存放在Class的属性SoftReference<ReflectionData> reflectionData。这个属性的类型是SoftReference（软引用），所谓软引用就是在资源紧张的情况下GC会进行回收，这就可能导致缓存丢失。SoftReference的泛型是ReflectionData，ReflectionData就是缓存数据的真正格式。ReflectionData将所有的Constructor、Method、Field对象存储下来供反射进行使用。</p><p>在1.8，放弃使用ReflectionData存储，而是在Class中直接将Constructor、Method、Field数组放进软引用中作为缓存。这样就将缓存分散，当资源紧张时，缓存不会全部被GC回收。</p><h1 id="SpringBoot使用CGLIB创建代理类的原理"><a href="#SpringBoot使用CGLIB创建代理类的原理" class="headerlink" title="SpringBoot使用CGLIB创建代理类的原理"></a>SpringBoot使用CGLIB创建代理类的原理</h1><p><a href="https://blog.csdn.net/weixin_45505313/article/details/103495439" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45505313/article/details/103495439</a></p><p><a href="https://blog.csdn.net/weixin_43732955/article/details/99196229" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43732955/article/details/99196229</a></p><p>使用CGLIB实现AOP <a href="https://www.jianshu.com/p/7cc8ffe4372b" target="_blank" rel="noopener">https://www.jianshu.com/p/7cc8ffe4372b</a></p><p>一、注册 AOP 的自动配置类<code>AopAutoConfiguration</code>，该配置类中配置 Bean 时使用<code>@EnableAspectJAutoProxy</code>注解，该注解 import 类<code>AspectJAutoProxyRegistrar</code>，该类中手动注册Bean<code>AnnotationAwareAspectJAutoProxyCreator</code></p><p>二、由于 AnnotationAwareAspectJAutoProxyCreator 实现了 BeanPostProcess 接口，所以在每个 Bean 初始化后，会经过它的<code>postProcessAfterInitialization</code>方法，在这个方法中调用<code>wrapIfNecessary</code>方法。在 wrapIfNecessary 方法中为当前 Bean 创建代理类（）。</p><ol><li>扫描切面类的方法最终位于<code>BeanFactoryAspectJAdvisorsBuilder.buildAspectJAdvisors()</code>，它先扫描出项目中的几乎所有Bean，一个一个判断它是否是切面Bean（判断其是否有@Aspect注解），是就调用<code>AspectJAdvisorFactory.getAdvisors()</code>，取这个切面Bean中的所有切面方法，一个切面方法就封装成一个 Advisor。最后的结果就是，BeanFactoryAspectJAdvisorsBuilder 将所有切面Bean的所有切面方法，封装成好几个 Advisor 并返回（并且有做缓存，不会出现找到了一个bean的）</li><li>得到 BeanFactoryAspectJAdvisorsBuilder 返回的好几个 Advisor 后，会筛选出匹配当前 Bean 的几个 Advisor</li><li>调用<code>ProxyFactory.getProxy()</code>创建代理类（ProxyFactory 中已保存了前面得到的 Advisor），使用的是<code>ObjenesisCglibAopProxy</code>（调用其构造函数时，ProxyFactory 把自己作为参数传入了，所以 Advisor 也传入了），它继承自<code>CglibAopProxy</code>，所以创建代理类的方法就是<code>CglibAopProxy.getProxy</code></li></ol><h2 id="CGLIB-代理类原理简述"><a href="#CGLIB-代理类原理简述" class="headerlink" title="CGLIB 代理类原理简述"></a>CGLIB 代理类原理简述</h2><p>CGLIB 有个类<code>Enhancer</code>，它可以保存</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理描述 </tag>
            
            <tag> 实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 时间类型转换</title>
      <link href="/2020/02/25/java-date-trans/"/>
      <url>/2020/02/25/java-date-trans/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java中表示时间有三种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String dateStr = <span class="string">"2020-01-01 15:00:11"</span>; <span class="comment">// String类型</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(); <span class="comment">// Date类型</span></span><br><span class="line"><span class="keyword">long</span> time = date.getTime(); <span class="comment">// long类型</span></span><br></pre></td></tr></table></figure><p>　　这三种类型的不同在于，String类型不带时区信息，Date和long类型会带时区信息。开发项目时，接口参数的时间字段最好用long类型表示，这样发送方和接收方收到的时间会一致。用String类型也能一致，但双方可能都要做格式转换。用Date类型做接口参数时，接收方和收到的值可能与发送方的不一致，不适合验签。</p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><h3 id="Date转String"><a href="#Date转String" class="headerlink" title="Date转String"></a>Date转String</h3><p>看一下电脑上的时间，得知当前时间是8时区的2020-02-25 15:41:21（系统时区是8时区）。<br>按照<code>yyyy-MM-dd HH:mm:ss</code>的格式打印当前时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date(); <span class="comment">// 当前时间</span></span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>; <span class="comment">// 注意，月份M大写，分钟m小写</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">System.out.println(sdf.format(d)); <span class="comment">// 2020-02-25 15:41:21</span></span><br></pre></td></tr></table></figure><p>打印结果和电脑上显示的一致。</p><h4 id="转换时考虑时区"><a href="#转换时考虑时区" class="headerlink" title="转换时考虑时区"></a>转换时考虑时区</h4><p>若想知道当前时间对应的GMT0时间是多少，就要在转换时加上时区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date(); <span class="comment">// 当前时间</span></span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">String timezone = <span class="string">"GMT+0"</span>; <span class="comment">// 时区</span></span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">System.out.println(sdf.format(d)); <span class="comment">// 2020-02-25 07:41:21</span></span><br></pre></td></tr></table></figure><p>打印结果<strong>2020-02-25 07:41:21(GMT0)</strong>和当前时间<strong>2020-02-25 15:41:21(GMT8)</strong>可以对应。</p><h3 id="Date转long"><a href="#Date转long" class="headerlink" title="Date转long"></a>Date转long</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="keyword">long</span> time = date.getTime();</span><br></pre></td></tr></table></figure><h2 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h2><h3 id="long转Date"><a href="#long转Date" class="headerlink" title="long转Date"></a>long转Date</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">Date d = <span class="keyword">new</span> Date(currentTimeMillis);</span><br></pre></td></tr></table></figure><h3 id="long转String"><a href="#long转String" class="headerlink" title="long转String"></a>long转String</h3><p>先long转Date，再Date转String。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String转Date"><a href="#String转Date" class="headerlink" title="String转Date"></a>String转Date</h3><p>若已知时间字符串”2020-02-25 10:44:05”是8时区，系统也是8时区，那么转换时可以简单的写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"2020-02-25 10:44:05"</span>;</span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>; <span class="comment">// 时间字符串的格式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Tue Feb 25 10:44:05 CST 2020</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>10:44:05</strong>和时间字符串<strong>2020-02-25 10:44:05(GMT8)</strong>一致。</p><blockquote><p>CST时间：China Standard Time，中国标准时间，等于GMT8</p></blockquote><h4 id="转换时考虑时区-1"><a href="#转换时考虑时区-1" class="headerlink" title="转换时考虑时区"></a>转换时考虑时区</h4><p>但如果已知”2020-02-25 10:44:05”这个字符串是0时区，那么就要指定时区转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"2020-02-25 10:44:05"</span>;</span><br><span class="line">String format = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>; <span class="comment">// 时间字符串的格式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">String timezone = <span class="string">"GMT+0"</span>; <span class="comment">// 时间字符串的时区</span></span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Tue Feb 25 18:44:05 CST 2020</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>18:44:05</strong>和时间字符串<strong>2020-02-25 10:44:05(GMT0)</strong>一致。</p><h4 id="复杂格式的时间字符串转换"><a href="#复杂格式的时间字符串转换" class="headerlink" title="复杂格式的时间字符串转换"></a>复杂格式的时间字符串转换</h4><p>处理复杂的时间字符串，如<strong>PDT时间</strong>：</p><blockquote><p>PDT时间：Pacific Daylight Time，太平洋夏季时间，等于UTC-7，UTC=GMT0，因此PDT=GMT8-15<br>PST时间：Pacific Standard Timee，太平洋标准时间，等于PDT-1，因此PST=GMT8-16</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"03:00:14 Jun 13, 2019 PDT"</span>; <span class="comment">// pdt时间2019-06-13 03:00:14</span></span><br><span class="line">String format = <span class="string">"HH:mm:ss MMM dd, yyyy z"</span>; <span class="comment">// z表示时区</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format, Locale.ENGLISH); <span class="comment">// 当字符串中有英文单词时要加上Locale参数</span></span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Thu Jun 13 18:00:14 CST 2019</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>18:00:14</strong>和时间字符串<strong>2019-06-13 03:00:14(PDT)</strong>一致。</p><p>处理<strong>UTC时间</strong>（UTC=GMT0）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String timeStr = <span class="string">"2019-04-24T02:30:00"</span>;</span><br><span class="line">String format = <span class="string">"yyyy-MM-dd'T'HH:mm:ss"</span>; <span class="comment">// 时间格式，注意T带引号</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">String timezone = <span class="string">"GMT+0"</span>; <span class="comment">// 时间字符串的时区</span></span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">Date date = sdf.parse(timeStr);</span><br><span class="line">System.out.println(date); <span class="comment">// Wed Apr 24 10:30:00 CST 2019</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的CST时间<strong>10:30:00</strong>和时间字符串<strong>2019-04-24 02:30:00(UTC)</strong>一致。</p><h3 id="String转long"><a href="#String转long" class="headerlink" title="String转long"></a>String转long</h3><p>先String转Date，再Date转long。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《算法图解》笔记</title>
      <link href="/2020/02/23/grokking-algorithms-note/"/>
      <url>/2020/02/23/grokking-algorithms-note/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　《算法图解》这本书真的非常好懂，它结合图画，对算法基础知识讲得很透，把“每一步要怎么做”和“为什么这样做”都交代了。这些知识以前在学校也学习过，但那时候只记住算法每一步怎么做，时间复杂度也是硬背的，根本没去理解背后的原因。这样的后果就是学完就忘。这本书就很适合我这种对算法稍微懂点但又不是很懂的人，它帮我把以前的疑惑都解开了。但它有个局限性就是，只讲基础，对稍微难点的内容都是一笔带过，只能靠个人去学，真正的入门书。<br>　　因为作者就像聊天似的教算法，图画也多，所以这本书的知识点比较散，这篇博客就是将我从这本书学到的知识点记录下来。</p><h1 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h1><ul><li>大O表示法体现的是随着元素数量n的增多，操作次数的增长趋势。如O(logn)（二分查找）的增长趋势明显比0(n)（简单查找）要慢得多，因此可以说二分查找比简单查找更好</li><li>大O表示法一般是该算法在最糟情况下的速度，但算法也有平均情况（也是最优情况）下的速度。如快速排序最糟O(n^2)，平均O(nlogn)</li><li>大O表示法不含常量的原因：当元素数量很多时，常量对速度的影响可忽略不计</li><li>O(1)表示常量时间，含义是无论元素数量多少，所需时间都一样</li></ul><p><strong>注：</strong></p><ol><li>这本书里只讨论时间复杂度，没讲空间复杂度</li><li>logn就是log2n，即2的幂</li></ol><h1 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h1><ul><li>在内存方面：数组元素的内存地址是相邻的，链表元素的内存地址不用相邻，链表的每个元素中都会存放下一个元素的内存地址</li><li>在查找方面：链表只能顺序查找，而数组可以随机访问到任一元素，因此说数组的查找效率更好</li><li>在插入和删除方面：链表的插入和删除只是改变某个元素存储的下一个元素的地址，数组的插入要重新分配内存，删除时要把后面的元素往前移</li><li>链表的插入和删除都是O(1)，这不包括“查找插入/删除位置”的时间</li></ul><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ul><li>递归没有什么性能优势，只是让代码更清晰。可以用递归实现的也能用循环实现</li><li>每个递归都包含两个条件：递归条件–让函数调用自己的条件，基线条件–函数return的条件（即不再递归的条件）</li><li>每次递归调用都会加入到调用栈，占用内存，执行完就会从调用栈弹出</li></ul><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>　　在调用栈过高的情况下，可以写成尾递归的形式。尾递归就是手动把本次调用的计算结果作为递归函数的参数，这样在return时就直接return递归，而不是还要先处理递归结果再return。<br>　　下面以阶乘函数为例，展示递归和尾递归的不同写法：</p><p><strong>普通递归：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> n * fac(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尾递归：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fac2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">//第一次调用时t=1</span></span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> fac2(n - <span class="number">1</span>, n * t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　写成尾递归后，若编译器会自动帮你把尾递归代码优化就会很好用（jvm不会），否则需要你手动把尾递归代码优化了才会有节省栈内存的效果。尾递归可以优化的原因：每次递归都计算出了一个结果，上一次递归的结果就没必要保留，可以释放内存。</p><h1 id="分而治之（D-amp-C）"><a href="#分而治之（D-amp-C）" class="headerlink" title="分而治之（D&amp;C）"></a>分而治之（D&amp;C）</h1><ul><li><p>分而治之是一种递归式的问题解决方法。思路是缩小问题范围，思考解决小问题的方法，能解决小问题的方法也适用于大问题。欧几里得算法就是这个思路</p><blockquote><p>两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数</p></blockquote></li><li><p>工作过程：a.找出基线条件，这个条件必须尽可能简单；b.缩小问题的规模，使其符合基线条件</p></li><li><p>要处理的对象是数组时，基线条件一般是数组为空或只含一个元素</p></li></ul><p><strong>举例：</strong>求数组[1,2,3,4,5]的总和，基线条件为：当数组只有一个元素时数组总和就等于这个元素。做法就是：不断挑出一个元素，使数组规模变小，求(挑出的元素+数组剩余元素总和)的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span>[] aArr = <span class="keyword">new</span> <span class="keyword">int</span>[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">aArr[i - <span class="number">1</span>] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">0</span>] + sum(aArr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码只是为了说明“分而治之”的思想，一般情况下求数组总和还用不到递归。</p><p><strong>注：</strong>这本书说的“分而治之”的概念是其他一些教材说的“减而治之”。一些人把“减而治之”看作是“分而治之”的一种特殊情况，作者这样写也没错。</p><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><ul><li>由数组和散列函数组成，通过散列函数将要存储的值计算成数组索引，值就放在索引处</li><li>良好的散列函数会尽量覆盖数组的每个位置，即每个值都放在不同位置</li></ul><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><ul><li>只适用于有序数列</li><li>运行时间为O(logn)，就是把一串数字对半分，直到只剩一个数字的次数</li><li>操作过程也运用了递归思想。基线条件：数组中间元素与目标相同；递归条件：当中间的元素不对，对一半数组继续二分查找</li></ul><p><strong>循环式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> high = n.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> i = n[mid];</span><br><span class="line"><span class="keyword">if</span> (i == target)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &lt; target) &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[] n, <span class="keyword">int</span> target, <span class="keyword">int</span> high, <span class="keyword">int</span> low)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> num = n[mid];</span><br><span class="line"><span class="keyword">if</span> (num == target)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num &lt; target) &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> binarySearch2(n, target, high, low);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>在实际使用中，当数组元素值都很大时，上面求中值的算式<code>int mid = (high + low) / 2</code>会有int溢出的可能，把它替换为<code>low + (high - low) / 2</code>会更好。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><ul><li>重复从数组中挑出最大或最小的元素放入新数组，直到原数组没有元素了</li><li>运行时间为0(n^2)，从n个元素中挑最大或最小（相当于把每个元素检查一遍），要挑n次，所以是n*n</li></ul><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><ul><li>过程：选出一个基准值pivot，比基准值小的数作为一个子数组a1，比基准值大的数作为子数组a2，qsort(a1) + pivot + qsort(a2)就是结果</li><li>平均情况下运行时间是O(nlogn)，即<strong>随机选取基准值</strong>，子数组a1和a2的元素个数基本是原数组的一半，调用栈高为logn，每一层栈要处理的元素数是n，所以是n*logn</li><li>最糟情况下运行时间是O(n^2)，即<strong>选取的基准值是最大或最小数</strong>，子数组a1和a2中总有一个为空，此时调用栈高为n，每一层栈要处理的元素数是n，所以是n*n</li></ul><p><strong>附：</strong>合并排序（Merge Sort）<br>　　合并排序就是把数组对半分，再递归把子数组对半分直到只有一个元素（栈高度logn），每一次对半分好后通过比较两个子数组的元素合并为一个有序数组（操作元素数n），合并排序的平均和最糟情况都是0(nlogn)</p><h1 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h1><ul><li><p>图的结构包含：节点(V)和边(E)</p></li><li><p><strong>树</strong>是一种特殊的图：不存在子节点往父节点指的边</p></li><li><p>节点之间有严格的先后顺序的图，叫<strong>拓扑排序</strong></p></li><li><p>非加权图找最短路径：<strong>广度优先搜索</strong>（下节详细说明）</p></li><li><p>加权图（不含负权边）找最短路径（即权重之和最小）：<strong>狄克斯特拉算法</strong><br>狄克斯特拉算法的思路：</p><ol><li>从所在节点的相邻节点中，找出“最便宜”的节点，即到达此相邻节点的权重最小</li><li>到达上一步所述的“最便宜”的节点后，更新从起点到达该“最便宜”节点的相邻节点的权重和</li><li>重复这个过程，直到对图中的每个节点都这样做了</li><li>计算最终路径的权重之和</li></ol></li><li><p>加权图（含负权边）找最短路径（即权重之和最小）：贝尔曼-福德算法</p></li><li><p>狄克斯特拉算法不适合用在带环的图</p></li></ul><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>广度优先搜索就是，从起点开始，判断走一步能到达的顶点中有没有终点，若没有，就判断走两步能到达的顶点中有没有终点。。。找到终点后，走的步数就是最短路径。</p><p>广度优先搜索可以解决2个问题：</p><ol><li>是否能到达终点</li><li>到达终点的最短路径</li></ol><p>专门用于找非加权图的最短路径。</p><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>广度优先搜索的运行时间：O(V+E)。V是图的节点数，E是边数。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li>用一个<strong>散列表</strong>存图的节点和边，key为每个节点，value为这个节点的相邻节点（邻居）列表</li><li>准备一个空<strong>队列</strong></li><li>从第一个节点开始，把该节点的邻居加入空队列</li><li>遍历队列中的每个节点，判断它们是不是终点，如果是，则返回最短步数；如果不是，把该节点的邻居加入队列（尾插），并删除该节点（头删）</li><li>用一个列表保存被判断过的节点，避免同一个节点被重复判断</li></ol><h2 id="广度优先和深度优先"><a href="#广度优先和深度优先" class="headerlink" title="广度优先和深度优先"></a>广度优先和深度优先</h2><h1 id="NP完全问题（NPC）"><a href="#NP完全问题（NPC）" class="headerlink" title="NP完全问题（NPC）"></a>NP完全问题（NPC）</h1><ul><li><p>无法快速找到最优解的就是NP完全问题</p></li><li><p><em>集合覆盖问题</em> 和 <em>旅行商问题</em> 就是典型的NP完全问题。背包问题属于集合覆盖问题。</p></li><li><p>解决NP完全问题，最好使用近似算法。贪婪算法就是近似算法的一种，无法得到最优解，但也接近最优解<br>贪婪算法，就是在限制的条件内，每一步都采取最优的做法。如背包问题中，每次都放入价值最高的物品，直到放不下为止</p></li><li><p>动态规划可以帮助找到NP完全问题的最优解</p><ul><li><p>可以使用动态规划的条件有：</p><ul><li>问题可以分解为互相独立的子问题。如背包问题中，放手机和放电脑彼此是独立的，谁先放都不会影响到另一个的价值</li><li>使用动态规划，问题的对象只有两种状态，有和没有，不能考虑“有一部分”这样的情况。如背包问题中，放一袋大米，只能考虑放整袋，不能考虑把米袋拆了只拿一部分</li></ul></li><li><p>动态规划的步骤</p><ol><li>绘制网格</li><li>决定网格的坐标轴代表什么。因为每个网格都代表一个子问题，所以要考虑怎么划分子问题。如对比两个字符串中相同字母的个数（求最长公共子序列问题），子问题就是一个字母一个字母的比较，所以坐标轴就是两个字符串</li><li>决定网格内的值代表什么。一般就是要优化的值。如求最长公共子序列问题，网格内的值就是相同字母的个数</li><li>决定网格内的值的计算公式。这个要通过经验和尝试来决定</li></ol></li></ul></li></ul><ul><li>NP完全问题的特征：<ol><li>元素数越多，算出最优解的时间越长</li><li>不能使用“分而治之”，必须考虑所有情况的问题</li><li>可以转化为集合覆盖问题或旅行商问题</li></ol></li></ul><p><strong>附：</strong>数学建模中其实有四类问题：P问题、NP问题、NP完全问题（NPC）、NP难问题（NPH），概念涉及到多项式，很复杂，这里不讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建vue开发环境</title>
      <link href="/2020/02/19/vue-env-build/"/>
      <url>/2020/02/19/vue-env-build/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为自己工作是搞后台的，偶尔要写下前端的时候，发现连前端项目怎么启动都忘记了= =||甚至不知道开发环境是怎么稀里糊涂地就搭好了。所以，有必要把它记下来。╭(′▽`)╯<br>这篇博客先简单地介绍“搭建vue开发环境”的4个步骤：</p><ol><li>安装Node.js</li><li>配置npm命令</li><li>初始化一个vue项目看看效果</li><li>编辑器VSCode的安装和配置</li></ol><p>说完“搭建环境”后，再顺便说说vue项目是怎么添加依赖模块和怎么打包部署的。</p><ul><li>给vue项目安装模块</li><li>打包vue项目</li></ul><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>进入官网下载：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 。安装好之后，在任一目录打开cmd输入命令测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>有打印版本号，类似于v13.5.0，就算安装成功。</p><h2 id="配置npm命令"><a href="#配置npm命令" class="headerlink" title="配置npm命令"></a>配置npm命令</h2><h3 id="设置依赖模块下载地址"><a href="#设置依赖模块下载地址" class="headerlink" title="设置依赖模块下载地址"></a>设置依赖模块下载地址</h3><p>开发vue项目时经常要安装项目所需模块（和后台项目下载jar包差不多），默认的下载地址 <a href="https://registry.npmjs.org/" target="_blank" rel="noopener">https://registry.npmjs.org/</a> 很慢，一般使用国内镜像地址 <a href="https://registry.npm.taobao.org/" target="_blank" rel="noopener">https://registry.npm.taobao.org/</a> 。<br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>执行成功后没有任何打印。</p><h3 id="设置全局模块和缓存目录"><a href="#设置全局模块和缓存目录" class="headerlink" title="设置全局模块和缓存目录"></a>设置全局模块和缓存目录</h3><p>在node.js的安装目录下，如<code>D:\Program Files\nodejs</code>，新建文件夹<code>node_cache</code>（名字可以任意起），这个文件夹是缓存目录。<br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> cache <span class="string">"D:\Program Files\nodejs\node_cache"</span></span><br></pre></td></tr></table></figure><p>全局模块目录就和本地maven仓库差不多。在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">"D:\Program Files\nodejs"</span></span><br></pre></td></tr></table></figure><p>这两个命令执行成功后没有任何打印。</p><h3 id="检查已设置内容"><a href="#检查已设置内容" class="headerlink" title="检查已设置内容"></a>检查已设置内容</h3><p>目前要自定义设置的就是这三个配置。要查看是否设置成功有两种方法：<br><strong>第一种：</strong><br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config ls</span><br></pre></td></tr></table></figure><p>结果会展示已自定义设置的内容：</p><img src="/2020/02/19/vue-env-build/npm_config_ls_result.png" class="" title="已设置内容"><p><strong>第二种：</strong><br>进入<code>C:\Users\个人目录</code>下，查看<code>.npmrc</code>文件，内容就是自定义配置项。</p><h3 id="其他有用的npm-config命令"><a href="#其他有用的npm-config命令" class="headerlink" title="其他有用的npm config命令"></a>其他有用的npm config命令</h3><ul><li><p>查看npm所有配置项（包括默认配置项）： npm config ls -l</p></li><li><p>修改某一个配置项： npm config set &lt;配置项名&gt; &lt;配置项值&gt;</p></li><li><p>查看某一个配置项值：npm config get &lt;配置项名&gt;</p></li><li><p>查看npm config命令的使用帮助： npm config -h</p></li></ul><h2 id="初始化一个vue项目"><a href="#初始化一个vue项目" class="headerlink" title="初始化一个vue项目"></a>初始化一个vue项目</h2><blockquote><p><strong>如果不打算自己创建项目，而是直接用已有的项目框架来开发，这一步可以跳过</strong></p></blockquote><h3 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h3><p>vue-cli叫做vue脚手架，它可以自动生成vue+webpack的项目模板。<br>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure><p>这个命令还可以简写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g vue-cli</span><br></pre></td></tr></table></figure><p>这个命令表示<strong>全局</strong>安装vue-cli。执行过程中会打印一堆模块的名字，没看到<strong>ERROR</strong>之类的字眼就安装成功了。<br>若想验证是否安装成功，可以在cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue</span><br></pre></td></tr></table></figure><p>看到有vue命令的使用帮助就代表安装成功了。<br>另外，这个vue-cli模块安装到了刚刚执行这个命令<code>npm config set prefix &quot;...&quot;</code>时设置的目录下的<code>node_modules</code>文件夹中。<br>npm install命令的更多介绍可以看“扩展内容”-“给vue项目安装模块”部分。</p><h3 id="创建vue项目"><a href="#创建vue项目" class="headerlink" title="创建vue项目"></a>创建vue项目</h3><p>在任一目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack hello-demo</span><br></pre></td></tr></table></figure><p>这个命令表示在当前目录下创建hello-demo项目。</p><p>创建过程中，会问你一些问题，在看到<code>Install vue-router?</code>问题前都按<code>回车</code>，<code>Install vue-router?</code>这个问题输入<code>Y</code>，剩下的目前用不到就输入<code>N</code>。示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">? Project name hello-demo</span><br><span class="line">? Project description A Vue.js project</span><br><span class="line">? Author abc &lt;123456@qq.com&gt;</span><br><span class="line">? Vue build standalone</span><br><span class="line">? Install vue-router? Yes</span><br><span class="line">? Use ESLint to lint your code? No</span><br><span class="line">? Set up unit tests No</span><br><span class="line">? Setup e2e tests with Nightwatch? No</span><br><span class="line">? Should we run `npm install` <span class="keyword">for</span> you after the project has been created? (recommended) npm</span><br></pre></td></tr></table></figure><p>创建完成后有如下提示，说明创建成功。</p><img src="/2020/02/19/vue-env-build/vue_init_result.png" class="" title="创建成功"><h3 id="运行vue项目"><a href="#运行vue项目" class="headerlink" title="运行vue项目"></a>运行vue项目</h3><p>按照创建完成后给出的提示命令，在cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hello-demo</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><code>npm run dev</code>命令简单地说就是用hello-demo项目中的<code>node_modules\webpack-dev-server</code>模块启动项目，用的是开发环境的配置<code>build\webpack.dev.conf.js</code>，详细一点的解释可以在网上找得到，这里就不展开了。<br>启动成功后，访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 可以看到如下页面：</p><img src="/2020/02/19/vue-env-build/run_result.png" class="" title="项目主页"><h2 id="编辑器VSCode的安装和配置"><a href="#编辑器VSCode的安装和配置" class="headerlink" title="编辑器VSCode的安装和配置"></a>编辑器VSCode的安装和配置</h2><p>可以用来做vue开发的编辑器有vscode、webstorm等等，这里介绍的vscode，优点是免费而且轻量，缺点是使用一些必要的功能还要额外装插件。<br>在官网下载：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a> ，安装过程很普通所以不讲了。</p><h3 id="下载vetur插件实现vue代码高亮"><a href="#下载vetur插件实现vue代码高亮" class="headerlink" title="下载vetur插件实现vue代码高亮"></a>下载vetur插件实现vue代码高亮</h3><p>vscode打开vue项目时没有任何语法高亮。要下载vetur插件来实现。</p><ul><li><p>常规安装<br>在vscode界面最左侧的工具栏，如下图点击图标出现<code>Extensions</code>页面。</p><img src="/2020/02/19/vue-env-build/vscode_extensions.png" class="" title="Extensions"><p>在输入框输入vetur，点击安装，安装好后重新打开vscode即可看到vue代码已高亮。</p></li><li><p>离线安装<br>因为开发环境很有可能是不联网的，所以有时候要采取特殊手段来安装插件。<br>先在有网的环境，进入官网下载插件包：<a href="https://marketplace.visualstudio.com/vscode" target="_blank" rel="noopener">https://marketplace.visualstudio.com/vscode</a> ，搜索vetur，点击图中的下载按钮下载。</p><img src="/2020/02/19/vue-env-build/vetur_download.png" class="" title="vetur"><p>下载后的插件包是<code>.vsix</code>后缀的。<br>然后把这个<code>.vsix</code>文件放到vscode的安装目录的bin目录下。<br>接着在bin目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code --install-extension octref.vetur-0.23.0.vsix</span><br></pre></td></tr></table></figure><p>离线安装其他插件也是用这样的方法。</p></li></ul><h3 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h3><p>点击File -&gt; Preference -&gt; Keyboard Shortcuts，可以查看和修改快捷键。</p><h2 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h2><p>以上步骤已经把vue开发环境搭建好了。下面扩展地讲一下vue项目依赖模块的安装和打包。</p><h3 id="给vue项目安装模块"><a href="#给vue项目安装模块" class="headerlink" title="给vue项目安装模块"></a>给vue项目安装模块</h3><h4 id="安装axios模块"><a href="#安装axios模块" class="headerlink" title="安装axios模块"></a>安装axios模块</h4><p>假设现在在开发hello-demo项目，发现需要一个axios插件，用来实现HTTP请求。<br>在项目根目录下打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save axios</span><br></pre></td></tr></table></figure><p>这个命令执行完，你会发现，此项目的<code>node_modules</code>文件夹中多了一个<code>axios</code>模块，且在项目的<code>package.json</code>文件中的<code>dependencies</code>括号内，多了<code>&quot;axios&quot;: &quot;^0.19.2&quot;</code>这一行。现在就可以在项目中使用axios了。</p><p><code>package.json</code>文件中的<code>dependencies</code>和<code>devDependencies</code>这两部分都表示项目依赖的模块，不同的是，<code>dependencies</code>代表<strong>生产环境</strong>需要依赖的模块，<code>devDependencies</code>代表<strong>开发</strong>时需要依赖的模块。</p><p>把模块添加到<code>devDependencies</code>下的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev &lt;模块名&gt;</span><br></pre></td></tr></table></figure><h4 id="常用的npm-install命令"><a href="#常用的npm-install命令" class="headerlink" title="常用的npm install命令"></a>常用的npm install命令</h4><ul><li><p>查看npm install命令的使用帮助：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -h</span><br></pre></td></tr></table></figure></li><li><p>全局安装模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g &lt;模块名&gt;</span><br></pre></td></tr></table></figure><p>安装到这个命令<code>npm config set prefix &quot;...&quot;</code>设置的目录下的<code>node_modules</code>文件夹中。</p></li><li><p>局部安装模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;模块名&gt;</span><br><span class="line">npm install --save &lt;模块名&gt;</span><br></pre></td></tr></table></figure><p>这两个命令效果一样，都是安装到当前项目下的<code>node_modules</code>文件夹中，同时添加到<code>package.json</code>文件中的<code>dependencies</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev &lt;模块名&gt;</span><br></pre></td></tr></table></figure><p>这个命令是安装到当前项目下的<code>node_modules</code>文件夹中，同时添加到<code>package.json</code>文件中的<code>devDependencies</code>。</p></li><li><p>下载项目依赖模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>这个命令会下载<code>package.json</code>文件中的<code>dependencies</code>和<code>devDependencies</code>中的所有依赖模块。<br>这个使用场景一般是git clone了项目，项目文件中通常不会包含依赖模块，依赖模块都写在<code>package.json</code>文件里，需要自己手动npm install下载一下。【和后台项目初次启动前先maven update一样</p></li><li><p>指定版本号下载模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install [-g|--save|--save-dev] &lt;模块名&gt;@&lt;版本号&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="打包vue项目"><a href="#打包vue项目" class="headerlink" title="打包vue项目"></a>打包vue项目</h3><p>进入要打包的项目目录，cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>打包完成后会打印<code>Build complete</code>。可以发现，项目目录下多出一个dist文件夹。</p><img src="/2020/02/19/vue-env-build/dist.png" class="" title="dist"><p>这个dist文件夹中就是项目的所有静态文件（做过混淆的），可以用nginx部署，nginx的配置文件基本是这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8080;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    root &#x2F;hellodemo&#x2F;dist; # dist文件所在目录</span><br><span class="line">    index index.html;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">      # 此处的 @router 实际上是引用下面的转发，否则在 Vue 路由刷新时可能会抛出 404</span><br><span class="line">      try_files $uri $uri&#x2F; @router;</span><br><span class="line">      # 请求指向的首页</span><br><span class="line">      index index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 由于路由的资源不一定是真实的路径，无法找到具体文件</span><br><span class="line">    # 所以需要将请求重写到 index.html 中，然后交给真正的 Vue 路由处理请求资源</span><br><span class="line">    location @router &#123;</span><br><span class="line">      rewrite ^.*$ &#x2F;index.html last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 这里配置后台接口地址转发，假设后台服务的IP端口是10.1.75.23:18081</span><br><span class="line">    # 比方说，前端“添加用户”的请求地址是http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;user&#x2F;add，就会被转发到 http:&#x2F;&#x2F;10.1.75.23:18081&#x2F;user&#x2F;add</span><br><span class="line">    location &#x2F;api&#x2F; &#123;</span><br><span class="line">          # 后端的真实接口</span><br><span class="line">          proxy_pass http:&#x2F;&#x2F;10.1.75.23:18081&#x2F;;</span><br><span class="line">          proxy_redirect off;</span><br><span class="line">          proxy_set_header Host $host;</span><br><span class="line">          proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">          proxy_set_header   Cookie $http_cookie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署完后浏览器输入localhost:8080就能跳到项目主页了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天依激励法</title>
      <link href="/2020/02/18/tianyi-fight/"/>
      <url>/2020/02/18/tianyi-fight/</url>
      
        <content type="html"><![CDATA[<p>爱天依就更要好好学习！</p><img src="/2020/02/18/tianyi-fight/tianyi_fight.jpg" class="" title="天依激励法">]]></content>
      
      
      
        <tags>
            
            <tag> 洛天依 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/12/hello-world/"/>
      <url>/2020/02/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
