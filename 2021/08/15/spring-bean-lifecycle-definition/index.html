<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spring Bean的生命周期——Bean定义"><meta name="keywords" content=""><meta name="author" content="yunnight"><meta name="copyright" content="yunnight"><title>Spring Bean的生命周期——Bean定义 | yunnight</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#容器刷新前的准备"><span class="toc-number">2.</span> <span class="toc-text">容器刷新前的准备</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#容器刷新"><span class="toc-number">3.</span> <span class="toc-text">容器刷新</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#附录1：PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors"><span class="toc-number">4.</span> <span class="toc-text">附录1：PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/yunnight/pics/master/blog_avatar.jpg"></div><div class="author-info__name text-center">yunnight</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">30</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">yunnight</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Spring Bean的生命周期——Bean定义</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Spring/"> Spring</a></div><div class="article-container" id="post-content"><p>Spring Bean 的生命周期有4个阶段：Bean 定义、Bean 初始化、Bean 生存期、Bean 销毁。因为“Bean 生存期”阶段就是程序启动后我们使用 Bean 的过程，所以不需要介绍。这篇博客介绍的是“Bean 定义”阶段。</p>
<blockquote>
<p>源码版本：SpringBoot 2.3.0，Spring 5.2.6</p>
</blockquote>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>“Bean定义”是 Spring Bean 的生命周期的第一个阶段，这个阶段里会根据启动类上的注解 <code>@ComponentScan</code> 指定的包路径（默认是当前包及其子包）扫描，把 Bean 定义信息保存到 IoC 容器中，待“Bean 初始化”阶段使用。</p>
<p>SpringBoot Web 应用使用的 IoC 容器为<code>AnnotationConfigServletWebServerApplicationContext</code>，这个容器包含一个属性：beanFactory = <code>DefaultListableBeanFactory</code> 。所有 Bean 定义信息就是保存到 DefaultListableBeanFactory 的成员 <code>Map&lt;String, BeanDefinition&gt; beanDefinitionMap</code> 中。<code>BeanDefinidition</code> 是用来记录 Bean 定义信息的接口，子类有 RootBeanDefinition、AnnotatedGenericBeanDefinition、ScannedGenericBeanDefinition 等。</p>
<p>真正开始注册 Bean 定义信息的时候是容器刷新的时候，即发生在 AbstractApplicationContext.refresh() 中。下面先看看容器刷新前为“Bean 定义”阶段做了哪些工作。</p>
<h1 id="容器刷新前的准备"><a href="#容器刷新前的准备" class="headerlink" title="容器刷新前的准备"></a>容器刷新前的准备</h1><p>在 SpringAppliction.run(String… args) 方法中，创建 IoC 容器 AnnotationConfigServletWebServerApplicationContext 时，反射调用该类及其父类们的无参构造方法，在父类 GenericApplicationContext 中初始化成员 beanFactory = DefaultListableBeanFactory。</p>
<p>在 IoC 容器 AnnotationConfigServletWebServerApplicationContext 自己的无参构造中，初始化成员 reader = <code>AnnotatedBeanDefinitionReader</code> 。在 AnnotatedBeanDefinitionReader 的构造函数中，调用了<code>AnnotationConfigUtils.registerAnnotationConfigProcessors()</code> 方法，这个方法内往 DefaultListableBeanFactory 中“注册”了几个指定的 Bean 定义（RootBeanDefinition 类型），其中包括 <code>ConfigurationClassPostProcessor</code> ，下面会介绍它。</p>
<blockquote>
<p> 如果有关注 AnnotatedBeanDefinitionReader 源码的话，可以看出，它的作用是手动注册某个 Bean 的定义信息。这个在容器扫描所有 Bean 定义信息之前很好用，这是因为有一些 Bean 需要在扫描前就被初始化，例如启动类的 Bean。</p>
</blockquote>
<p>回到 SpringAppliction.run(String… args) 方法，创建好容器后，调用本类的<code>prepareContext</code>方法，这个方法内最后调用<code>SpringApplication.load()</code>方法。</p>
<p>SpringApplication.load() 部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ApplicationContext context, Object[] sources)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Loading source "</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class="line">	&#125;</span><br><span class="line">	BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanNameGenerator != <span class="keyword">null</span>) &#123;</span><br><span class="line">		loader.setBeanNameGenerator(<span class="keyword">this</span>.beanNameGenerator);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">		loader.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">		loader.setEnvironment(<span class="keyword">this</span>.environment);</span><br><span class="line">	&#125;</span><br><span class="line">	loader.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法参数1 context 为已创建的容器对象，参数2 sources 只有一个元素，就是启动类 Class 对象，如”DemoApplication.class”（来源是 SpringApplication.run() 方法时的第一个参数）。在这个方法内，创建 BeanDefinitionLoader 对象，再通过 BeanDefinitionLoader 对象内成员<code>AnnotatedBeanDefinitionReader</code>（与容器内的成员不是同一个），最终向容器中注册了启动类 DemoApplication 的 Bean 定义（AnnotatedGenericBeanDefinition 类型）。</p>
<hr>
<p>这里简单介绍下启动类 DemoApplication 的 Bean 定义注册的过程。见<code>AnnotatedBeanDefinitionReader.doRegisterBean()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, @Nullable String name,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, @Nullable Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这一步判断这个bean上是否加了@Conditional注解，加了就不继续</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	abd.setInstanceSupplier(supplier);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这一步设置BeanDefinition中的scope属性="singleton"</span></span><br><span class="line">	ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">	abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取beanName用于注册，详细说明见下方</span></span><br><span class="line">	String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">	AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">	<span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Primary<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">				abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Lazy<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">				abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">			customizer.customize(abd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注册</span></span><br><span class="line">	BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">	definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">	BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处取 beanName 时，用的是<code>AnnotationBeanNameGenerator</code>，当 Bean 定义对象是 AnnotatedBeanDefinition 的子类时（AnnotatedGenericBeanDefinition 就是），用的是下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">determineBeanNameFromAnnotation</span><span class="params">(AnnotatedBeanDefinition annotatedDef)</span> </span>&#123;</span><br><span class="line">	AnnotationMetadata amd = annotatedDef.getMetadata();</span><br><span class="line">	<span class="comment">// types是类上直接标注的注解集合</span></span><br><span class="line">	Set&lt;String&gt; types = amd.getAnnotationTypes();</span><br><span class="line">	String beanName = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">for</span> (String type : types) &#123; <span class="comment">// 遍历types</span></span><br><span class="line">		<span class="comment">// attributes是注解 type 中的所有属性,k-v格式,key=属性名,value=属性值</span></span><br><span class="line">		AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);</span><br><span class="line">		<span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">		</span><br><span class="line">			<span class="comment">// 当type是个复合注解，metaTypes是这个复合注解中所包含的注解集合</span></span><br><span class="line">			Set&lt;String&gt; metaTypes = <span class="keyword">this</span>.metaAnnotationTypesCache.computeIfAbsent(type, key -&gt; &#123;</span><br><span class="line">				Set&lt;String&gt; result = amd.getMetaAnnotationTypes(key);</span><br><span class="line">				<span class="keyword">return</span> (result.isEmpty() ? Collections.emptySet() : result);</span><br><span class="line">			&#125;);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 判断type和metaType中是否包含@Component注解</span></span><br><span class="line">			<span class="keyword">if</span> (isStereotypeWithNameValue(type, metaTypes, attributes)) &#123;</span><br><span class="line">				<span class="comment">// 取@Component的value属性</span></span><br><span class="line">				Object value = attributes.get(<span class="string">"value"</span>);</span><br><span class="line">				<span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">					String strVal = (String) value;</span><br><span class="line">					<span class="comment">// 若value属性值有指定，就作为beanName返回</span></span><br><span class="line">					<span class="keyword">if</span> (StringUtils.hasLength(strVal)) &#123;</span><br><span class="line">						<span class="comment">// 但如果一个类有多个@Component注解指定了value值，会报错（如@Component和@Service同时存在且同时指定了value）</span></span><br><span class="line">						<span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; !strVal.equals(beanName)) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Stereotype annotations suggest inconsistent "</span> +</span><br><span class="line">									<span class="string">"component names: '"</span> + beanName + <span class="string">"' versus '"</span> + strVal + <span class="string">"'"</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						beanName = strVal;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复合注解举例：以 @SpringBootApplication 为例，它包含 @EnableAutoConfiguration，@EnableAutoConfiguration 下又包含 @Import 等。</p>
<p>若这个方法取不到 beanName，即 @Component 注解没有指定 value 值，就会用另一个方法：取类名，第一个字母小写。</p>
<blockquote>
<p>问题：注册 Bean 定义时，为什么加了 @Conditional注解就不继续？@Conditional只是控制一个bean在特定条件下才注入。 ？？？</p>
</blockquote>
<h1 id="容器刷新"><a href="#容器刷新" class="headerlink" title="容器刷新"></a>容器刷新</h1><p>在 AbstractApplicationContext.refresh() 方法中，调用本类中的 invokeBeanFactoryPostProcessors 方法，参数是 beanFactory = DefaultListableBeanFactory。在这个方法中，又调用了<code>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()</code>方法。</p>
<p>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors() 方法参数1是 beanFactory，参数2是容器中已添加的 BeanFactoryPostProcessor（是在上一节“容器刷新前的准备”阶段添加的， 这里不用关注有哪些）。这个方法的作用是取出容器中当前已保存的、实现了 BeanFactoryPostProcessor 接口的 Bean，并初始化这些 Bean，然后调用这些 Bean 的，以及“参数2”中的 Bean 的 postProcessBeanFactory 方法，若 Bean 实现的接口是 <code>BeanDefinitionRegistryPostProcessor</code>（该接口继承了 BeanFactoryPostProcessor），会先调用其 postProcessBeanDefinitionRegistry 方法，再调用其 postProcessBeanFactory 方法。</p>
<p>【PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors() 方法的详细解读见附录1。</p>
<p>在上一节说过，容器刚创建时就注册了 ConfigurationClassPostProcessor 的 BeanDefinidition 对象，它就是 BeanDefinitionRegistryPostProcessor 接口的实现类，所以在这个方法内会创建并实例化它的 Bean，再调用它的 postProcessBeanDefinitionRegistry 方法。</p>
<p>ConfigurationClassPostProcessor 是在“Bean 定义”阶段最关键的一个类，XXXXXXXXXXXXXXX</p>
<p>这个类做了什么？</p>
<p><strong>1、</strong>取出容器当前拥有的 BeanDefinidition 对象，判断它们是否是配置类，不是配置类的不处理，是配置类的继续处理。</p>
<p>这里判断是不是配置类的方法是<code>ConfigurationClassUtils.checkConfigurationClassCandidate</code>。简单地说，类上有这些注解之一的：@Configuration、@Component、@ComponentScan、@Import、@ImportResource，或类中方法有注解 @Bean 的，都算配置类。</p>
<p>PS: 从实际使用经验上来说，类上不标任何注解，只在方法上标注解 @Bean，是不起作用的，原因是这样的类在扫描时就扫不到，更进不到这个判断方法。</p>
<p>在这一步，本身容器中已注册的 BeanDefinidition 就不多，再经过筛选，就只剩下启动类如”DemoApplication”的 BeanDefinidition 会被继续处理了。</p>
<blockquote>
<p>@Import 注解可用于导入一个或多个 Bean，它和 @Bean 的区别就是它是标在类上。@ImportResource 类似，但它是用于导入配置文件。</p>
</blockquote>
<p><strong>2、</strong>如果筛选完有多个配置类的话，若配置类上有标<code>@Order</code>注解，会排个序，按注解value值升序排序，所以值越小的优先级越高。</p>
<p><strong>3、</strong>创建<code>ConfigurationClassParser</code>，调用这个类的 parse 方法处理筛选出的配置类 BeanDefinidition 对象（只有启动类一个），这个类最后调用到<code>doProcessConfigurationClass</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数configClass和sourceClass都是启动类Class对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>



<p>通过方法内注释可以知道，这个方法会处理被这些注解标注的配置类：@PropertySource（可以和@Value注解配合使用读取配置项）、@ComponentScan、@Import、@ImportResource，和用 @Bean 标注的方法。</p>
<p>已知，Spring 会根据启动类上的 @ComponentScan 注解，扫描启动类所在包下所有的 Bean 定义信息，保存到 beanFactory=DefaultListableBeanFactory 中。这里就来说说 ConfigurationClassParser 是怎么处理 @ComponentScan 注解的。</p>
<h1 id="附录1：PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors"><a href="#附录1：PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors" class="headerlink" title="附录1：PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()"></a>附录1：PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存已经执行过的processor的名字</span></span><br><span class="line">	Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123; <span class="comment">// 一般都走这个分支，因为 beanFactory=DefaultListableBeanFactory</span></span><br><span class="line">	</span><br><span class="line">		BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 整理参数2中的processors，把有实现BeanDefinitionRegistryPostProcessor和没实现的分开存放</span></span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">			<span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">				BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">						(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">				<span class="comment">// 保存前先执行BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">				registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">				registryProcessors.add(registryProcessor);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				regularPostProcessors.add(postProcessor);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 用来暂存当前要执行的processor，执行完即清空</span></span><br><span class="line">		List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从beanFactory中找实现了 BeanDefinitionRegistryPostProcessor 和 PriorityOrdered 接口的Bean，初始化，执行它们的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">		<span class="comment">// 这一步就会执行到 ConfigurationClassPostProcessor 的 postProcessBeanDefinitionRegistry 方法</span></span><br><span class="line">		String[] postProcessorNames =</span><br><span class="line">				beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">				currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">				processedBeans.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(currentRegistryProcessors, beanFactory); <span class="comment">// PriorityOrdered 接口可以定义执行顺序，执行前先排序</span></span><br><span class="line">		registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">		invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">		currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从beanFactory中找实现了 BeanDefinitionRegistryPostProcessor 和 Ordered 接口的Bean，初始化，执行它们的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">		postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">				currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">				processedBeans.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">		registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">		invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">		currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从beanFactory中找只实现了 BeanDefinitionRegistryPostProcessor 接口的Bean，初始化，执行它们的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">		<span class="comment">// 循环的原因：一个processor可能会添加新的 BeanDefinitionRegistryPostProcessor 接口的Bean，所以循环到找不到新的为止</span></span><br><span class="line">		<span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">			reiterate = <span class="keyword">false</span>;</span><br><span class="line">			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">			<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">					reiterate = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">			registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">			currentRegistryProcessors.clear();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历调用 registryProcessors 中的 postProcessBeanFactory 方法，registryProcessors 包含参数2中实现了 BeanDefinitionRegistryPostProcessor 的类和前面几次从 beanFactory 中找 BeanDefinitionRegistryPostProcessor 类型的Bean定义生成的Bean</span></span><br><span class="line">		invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">		<span class="comment">// 遍历调用 regularPostProcessors 中的 postProcessBeanFactory 方法，regularPostProcessors 包含参数2中未实现 BeanDefinitionRegistryPostProcessor 的类</span></span><br><span class="line">		invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="comment">// 遍历调用参数2 beanFactoryPostProcessors 中的 postProcessBeanFactory 方法</span></span><br><span class="line">		invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面这部分和上面相似，只是类型换成了 BeanFactoryPostProcessor</span></span><br><span class="line">	String[] postProcessorNames =</span><br><span class="line">			beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">	List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">		<span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">			<span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">			priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">			orderedPostProcessorNames.add(ppName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">	invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">	List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">	<span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">		orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">	invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">	List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">	<span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">		nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// beanFactory清除缓存</span></span><br><span class="line">	beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结这个方法做的事：</p>
<ol>
<li>执行 BeanDefinitionRegistryPostProcessor 类型的、实现了 PriorityOrdered 接口的 postProcessor 的 postProcessBeanDefinitionRegistry 方法 — 这里会执行到 ConfigurationClassPostProcessor</li>
<li>执行 BeanDefinitionRegistryPostProcessor 类型的、实现了 Ordered 接口的 postProcessor 的 postProcessBeanDefinitionRegistry 方法</li>
<li>执行 BeanDefinitionRegistryPostProcessor 类型的、没有实现 PriorityOrdered/Ordered 接口的 postProcessor 的 postProcessBeanDefinitionRegistry 方法</li>
<li>执行方法参数中实现了 BeanDefinitionRegistryPostProcessor 的，和前面三步的BeanDefinitionRegistryPostProcessor 类型的  postProcessor 的 postProcessBeanFactory 方法</li>
<li>执行方法参数中未实现 BeanDefinitionRegistryPostProcessor 的 postProcessor 的 postProcessBeanFactory 方法</li>
<li>执行 BeanFactoryPostProcessor 类型的、实现了 PriorityOrdered 接口的 postProcessor 的 postProcessBeanFactory 方法</li>
<li>执行 BeanFactoryPostProcessor 类型的、实现了 Ordered 接口的 postProcessor 的 postProcessBeanFactory 方法</li>
<li>执行 BeanFactoryPostProcessor 类型的 postProcessor 的 postProcessBeanFactory 方法</li>
</ol>
</div></article><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/08/18/java8-stream-api-note/"><i class="fa fa-chevron-left">  </i><span>Java8 Stream API 常用方法</span></a></div><div class="next-post pull-right"><a href="/2021/08/08/java-class-lifecycle/"><span>Java类的生命周期</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By yunnight</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>