<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="SpringShiroFilter原理"><meta name="keywords" content=""><meta name="author" content="yunnight"><meta name="copyright" content="yunnight"><title>SpringShiroFilter原理 | yunnight</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建原理"><span class="toc-number">2.</span> <span class="toc-text">创建原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FilterChainManager"><span class="toc-number">2.1.</span> <span class="toc-text">FilterChainManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">2.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#工作原理"><span class="toc-number">3.</span> <span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建Subject对象"><span class="toc-number">3.1.</span> <span class="toc-text">创建Subject对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解析session"><span class="toc-number">3.1.1.</span> <span class="toc-text">解析session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析principals"><span class="toc-number">3.1.2.</span> <span class="toc-text">解析principals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建新的subject对象并保存"><span class="toc-number">3.1.3.</span> <span class="toc-text">创建新的subject对象并保存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#subject-创建好-session-后，会把自己的-principals-和-authenticated-设置到-session-中。HttpServletSession-保存数据的方式是保存到HttpSession-javax-servlet-http-的attributes，SimpleSession-是保存到自己的Map-lt-Object-Object-gt-attributes。"><span class="toc-number">3.2.</span> <span class="toc-text">subject 创建好 session 后，会把自己的 principals 和 authenticated 设置到 session 中。HttpServletSession 保存数据的方式是保存到HttpSession(javax.servlet.http)的attributes，SimpleSession 是保存到自己的Map&lt;Object, Object&gt; attributes。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#取url对应的过滤器链"><span class="toc-number">3.3.</span> <span class="toc-text">取url对应的过滤器链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#准备"><span class="toc-number">3.3.1.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#取过滤器链并执行"><span class="toc-number">3.3.2.</span> <span class="toc-text">取过滤器链并执行</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/yunnight/pics/master/blog_avatar.jpg"></div><div class="author-info__name text-center">yunnight</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">33</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">yunnight</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">SpringShiroFilter原理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-10-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Shiro/"> Shiro</a></div><div class="article-container" id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring 或 SpringBoot 集成 Shiro 后，无论在 Shiro 配置文件中配置了多少个 Shiro 过滤器（包括 Shiro 已实现的或自定义实现的），这些过滤器在<code>ApplicationFilterChain</code>（tomcat定义的过滤器链）中只以“一个过滤器”的身份存在。这个过滤器的类型是<code>SpringShiroFilter</code>，过滤器的名字取决于我们注入这个 Bean 时设置的 BeanName。</p>
<p>这篇博客主要介绍 SpringShiroFilter 的创建和工作原理。</p>
<blockquote>
<p>以下展示源码的版本是 Shiro 1.3.2。</p>
</blockquote>
<h1 id="创建原理"><a href="#创建原理" class="headerlink" title="创建原理"></a>创建原理</h1><p>Shiro 过滤器是由<code>ShiroFilterFactoryBean</code>生成并初始化。在 Shiro 的配置文件中，我们一定会配置这个 ShiroFilterFactoryBean 的 Bean 注入。如下配置示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 配置SecurityManager</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultSecurityManager <span class="title">securityManager</span><span class="params">(CustomRealm customRealm)</span> </span>&#123; <span class="comment">// CustomRealm是自定义Realm类，securityManager所需</span></span><br><span class="line">	DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager(customRealm);</span><br><span class="line">	SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">	<span class="keyword">return</span> securityManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置ShiroFilterFactoryBean</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilter</span><span class="params">(DefaultSecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">	ShiroFilterFactoryBean factory = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">	factory.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">	factory.setLoginUrl(<span class="string">"/login"</span>); <span class="comment">// 登录页URI</span></span><br><span class="line">	factory.setUnauthorizedUrl(<span class="string">"/unauth"</span>); <span class="comment">// 403页面URI</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 添加自定义Filter</span></span><br><span class="line">	Map&lt;String, Filter&gt; filtersMap = <span class="keyword">new</span> LinkedHashMap&lt;String, Filter&gt;();</span><br><span class="line">	filtersMap.put(<span class="string">"permissionCheckFilter"</span>, <span class="keyword">new</span> PermissionCheckFilter());</span><br><span class="line">	factory.setFilters(filtersMap);</span><br><span class="line"></span><br><span class="line">	Map&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">	<span class="comment">// 匹配上的URI走对应的Filter，从上到下匹配</span></span><br><span class="line">	filterChainDefinitionMap.put(<span class="string">"/logout"</span>, <span class="string">"logout"</span>);</span><br><span class="line">	filterChainDefinitionMap.put(<span class="string">"/login"</span>, <span class="string">"anon"</span>);</span><br><span class="line">	filterChainDefinitionMap.put(<span class="string">"/login/submit"</span>, <span class="string">"anon"</span>);</span><br><span class="line">	filterChainDefinitionMap.put(<span class="string">"/getRSAKey"</span>, <span class="string">"anon"</span>);</span><br><span class="line">	filterChainDefinitionMap.put(<span class="string">"/unauth"</span>, <span class="string">"anon"</span>);</span><br><span class="line">	filterChainDefinitionMap.put(<span class="string">"/*.ico"</span>, <span class="string">"anon"</span>);</span><br><span class="line">	filterChainDefinitionMap.put(<span class="string">"/**"</span>, <span class="string">"authc"</span>);</span><br><span class="line">	System.out.println(filterChainDefinitionMap);</span><br><span class="line">	factory.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">	<span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然在配置代码中注入的 Bean 类型是”ShiroFilterFactoryBean”，但其实是”SpringShiroFilter”。这是由于 ShiroFilterFactoryBean 实现了<code>FactoryBean</code>接口，<code>FactoryBean</code>的特点是注册这个 Bean 时，注册的不是自己本类的 Bean，而是<code>getObject</code>方法返回的 Bean，且 Bean 的类型在<code>getObjectType</code>指定。</p>
<p>ShiroFilterFactoryBean 还实现了<code>BeanPostProcessor</code>接口，<code>BeanPostProcessor</code>的特点是，在“Bean 的生命周期——Bean 初始化”阶段，在调用某个 Bean 的初始化方法（afterPropertiesSet 和 init-method）前后，遍历调用所有 BeanPostProcessor 的实现类的2个方法。</p>
<p>ShiroFilterFactoryBean 实现这2个接口的部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroFilterFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = createInstance(); <span class="comment">// 下面分析</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">getObjectType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SpringShiroFilter<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// 只处理过滤器Bean</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Filter) &#123;</span><br><span class="line">            log.debug(<span class="string">"Found filter chain candidate filter '&#123;&#125;'"</span>, beanName);</span><br><span class="line">            Filter filter = (Filter) bean;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 根据过滤器的类型设置不同的URL</span></span><br><span class="line">			<span class="comment">// AccessControlFilter 类型的，设置 loginUrl</span></span><br><span class="line">			<span class="comment">// AuthenticationFilter 类型的，设置 successUrl</span></span><br><span class="line">			<span class="comment">// AuthorizationFilter 类型的，设置 unauthorizedUrl</span></span><br><span class="line">            applyGlobalPropertiesIfNecessary(filter);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 添加到成员Map&lt;String, Filter&gt; filters</span></span><br><span class="line">            getFilters().put(beanName, filter);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.trace(<span class="string">"Ignoring non-Filter bean '&#123;&#125;'"</span>, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上源码可以看出，ShiroFilterFactoryBean 调用自己的 createInstance 方法创建 SpringShiroFilter Bean，最终注入到 IoC 容器。在<code>postProcessBeforeInitialization</code>方法中搜集 IoC 容器中所有 Filter Bean（包括不是 Shiro 实现的 Filter），添加到成员<code>filters</code>中，而成员 filters 中也包含我们基于 Shiro 过滤器基类实现的 filter（如配置示例代码中的”PermissionCheckFilter”）。</p>
<blockquote>
<p>根据 postProcessBeforeInitialization 方法可以推测，自定义的 Shiro 过滤器既可以在配置代码中手动添加（配置示例就是采用这个方式），也可以直接注入 Bean，两种方式最终都会添加到 ShiroFilterFactoryBean 中。</p>
</blockquote>
<p><code>createInstance</code>方法就是负责创建 SpringShiroFilter，一共有3个步骤：</p>
<ol>
<li>创建<code>FilterChainManager</code>，实现类是<code>DefaultFilterChainManager</code></li>
<li>创建<code>PathMatchingFilterChainResolver</code>，并把上一步创建的 FilterChainManager 作为它的成员</li>
<li>创建 SpringShiroFilter，并把上一步创建的 PathMatchingFilterChainResolver 和 ShiroFilterFactoryBean 的成员 securityManager（等于配置代码中的”DefaultWebSecurityManager”）作为它的成员</li>
</ol>
<p>需要重点讲解的是第一步：创建<code>FilterChainManager</code>的过程，原因是 FilterChainManager 是 SpringShiroFilter 的间接成员，是它工作过程中的关键类之一，它保存了 url 与过滤器链的映射关系，即配置代码中的<code>filterChainDefinitionMap</code>中的内容。</p>
<h2 id="FilterChainManager"><a href="#FilterChainManager" class="headerlink" title="FilterChainManager"></a>FilterChainManager</h2><p>ShiroFilterFactoryBean 中创建 FilterChainManager 的方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> FilterChainManager <span class="title">createFilterChainManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回对象。刚创建时，这个manager内包含了DefaultFilter类中的所有过滤器</span></span><br><span class="line">	DefaultFilterChainManager manager = <span class="keyword">new</span> DefaultFilterChainManager();</span><br><span class="line">	Map&lt;String, Filter&gt; defaultFilters = manager.getFilters(); <span class="comment">// key=filterName</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 根据过滤器的类型设置不同的url，同"postProcessBeforeInitialization"方法</span></span><br><span class="line">	<span class="keyword">for</span> (Filter filter : defaultFilters.values()) &#123;</span><br><span class="line">		applyGlobalPropertiesIfNecessary(filter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取ShiroFilterFactoryBean的成员filters（包括自定义的ShiroFilter和容器中其他非Shiro的Filter）</span></span><br><span class="line">	Map&lt;String, Filter&gt; filters = getFilters();</span><br><span class="line">	<span class="keyword">if</span> (!CollectionUtils.isEmpty(filters)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, Filter&gt; entry : filters.entrySet()) &#123;</span><br><span class="line">			String name = entry.getKey();</span><br><span class="line">			Filter filter = entry.getValue();</span><br><span class="line">			applyGlobalPropertiesIfNecessary(filter);</span><br><span class="line">			<span class="keyword">if</span> (filter <span class="keyword">instanceof</span> Nameable) &#123;</span><br><span class="line">				((Nameable) filter).setName(name);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 自定义filter添加到manager中，但没有初始化（即没有调用Filter.init方法）</span></span><br><span class="line">			<span class="comment">// 此时manager内包含了defaultFilters和自定义filters</span></span><br><span class="line">			manager.addFilter(name, filter, <span class="keyword">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个chains是在ShiroFilterFactoryBean配置的filterChainDefinitionMap，如&lt;"/role", "authc,roles[admin]"&gt;</span></span><br><span class="line">	Map&lt;String, String&gt; chains = getFilterChainDefinitionMap();</span><br><span class="line">	<span class="keyword">if</span> (!CollectionUtils.isEmpty(chains)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : chains.entrySet()) &#123;</span><br><span class="line">			String url = entry.getKey();</span><br><span class="line">			String chainDefinition = entry.getValue();</span><br><span class="line">			manager.createChain(url, chainDefinition); <span class="comment">// 下面分析</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法的最后一段，遍历我们配置的<code>filterChainDefinitionMap</code>，调用<code>manager.createChain()</code>处理这个 Map 中每个键值对（key=url，value=url对应的过滤器配置如”roles[admin,user]”）。</p>
<p><code>DefaultFilterChainManager</code>的部分源码（主要关注 createChain 方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFilterChainManager</span> <span class="keyword">implements</span> <span class="title">FilterChainManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Filter&gt; filters;<span class="comment">// key=filterName, 其中包含DefaultFilter类中所有过滤器和所有自定义filters</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, NamedFilterList&gt; filterChains;<span class="comment">// key=url</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createChain</span><span class="params">(String chainName, String chainDefinition)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 2个方法形参即为filterChainDefinitionMap的key、value</span></span><br><span class="line">        <span class="comment">// 一些校验代码...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对chainDefinition的一些处理，效果如下面的注释所说</span></span><br><span class="line">        <span class="comment">// Input: "authc, roles[admin,user], perms[file:edit]"</span></span><br><span class="line">        <span class="comment">// Result: [ "authc", "roles[admin,user]", "perms[file:edit]" ]</span></span><br><span class="line">        String[] filterTokens = splitChainDefinition(chainDefinition);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历filterTokens</span></span><br><span class="line">        <span class="keyword">for</span> (String token : filterTokens) &#123;</span><br><span class="line">			<span class="comment">// 对token的一些处理，效果如下面的注释所说</span></span><br><span class="line">			<span class="comment">// Input: foo[bar, baz]</span></span><br><span class="line">			<span class="comment">// Result: returned[0] == foo returned[1] == bar, baz</span></span><br><span class="line">            String[] nameConfigPair = toNameConfigPair(token);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 见下面</span></span><br><span class="line">            addToChain(chainName, nameConfigPair[<span class="number">0</span>], nameConfigPair[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToChain</span><span class="params">(String chainName, String filterName, String chainSpecificFilterConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(chainName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"chainName cannot be null or empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Filter filter = getFilter(filterName); <span class="comment">// 从成员filters中取</span></span><br><span class="line">        <span class="keyword">if</span> (filter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"....略"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 见下方说明</span></span><br><span class="line">        applyChainConfig(chainName, filter, chainSpecificFilterConfig);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从成员filterChains中取（chainName=url），若没有就初始化一个</span></span><br><span class="line">		<span class="comment">// 把当前filter添加到URL对于的chain中</span></span><br><span class="line">        NamedFilterList chain = ensureChain(chainName);</span><br><span class="line">        chain.add(filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>applyChainConfig(chainName, filter, chainSpecificFilterConfig);</code>这行代码的内容是：当且仅当 filter 是<code>PathMatchingFilter</code>（Shiro 过滤器基类之一）的子类时，将 chainName、chainSpecificFilterConfig 设置到 PathMatchingFilter 的成员<code>Map&lt;String, Object&gt; appliedPaths</code>中。</p>
<p>整个<code>DefaultFilterChainManager.createChain()</code>方法的作用是，以&lt;”/<strong>“, “authc, roles[admin,user], perms[file:edit]”&gt;这个 filterChainDefinitionMap 中的键值对为例，执行完整个 createChain 方法后，manager 的 filterChains 成员中，key=”/</strong>“ 对应的 chain 中包含”authc”, “roles”, “perms”这3个过滤器（按定义顺序添加），这3个过滤器的配置，即”[admin,user]”, “[file:edit]”，分别被添加到了”roles”, “perms”过滤器的成员 appliedPaths 中。</p>
<p>DefaultFilterChainManager 的 filterChains 成员中，key 即 url，对应一条过滤器链。因为 filterChainDefinitionMap 类型是 LinkedHashMap，所以过滤器链中的过滤器顺序与配置的顺序一致。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，ShiroFilterFactoryBean 创建了 SpringShiroFilter Bean，并给它设置了成员 DefaultWebSecurityManager 和 PathMatchingFilterChainResolver，PathMatchingFilterChainResolver 中的成员 DefaultFilterChainManager 中保存了 url 与过滤器链的关系，这部分数据来自于配置的 filterChainDefinitionMap。</p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>前面说过，无论在 Shiro 配置文件中配置了多少个 Shiro 过滤器，这些过滤器在<code>ApplicationFilterChain</code>（tomcat定义的过滤器链）中只以<code>SpringShiroFilter</code>存在。原因就是 SpringShiroFilter 的间接成员 DefaultFilterChainManager 保存了 url 与 Shiro 过滤器链的关系。SpringShiroFilter 会根据不同的 url 取对应的过滤器链来处理请求，主要逻辑在它的 doFilterInternal 方法内（被 doFilter 方法调用）。</p>
<p>SpringShiroFilter.doFilterInternal() 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, <span class="keyword">final</span> FilterChain chain)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Throwable t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);</span><br><span class="line">		<span class="keyword">final</span> ServletResponse response = prepareServletResponse(request, servletResponse, chain);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建Subject对象</span></span><br><span class="line">		<span class="keyword">final</span> Subject subject = createSubject(request, response);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调用subject.call()方法，里面会调用此处声明的call方法</span></span><br><span class="line">		subject.execute(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				<span class="comment">// 在指定条件下，更新session中用户最近一次请求的时间</span></span><br><span class="line">				updateSessionLastAccessTime(request, response);</span><br><span class="line">				<span class="comment">// 取url对应的过滤器链并执行</span></span><br><span class="line">				executeChain(request, response, chain);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ExecutionException ex) &#123;</span><br><span class="line">		t = ex.getCause();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">		t = throwable;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的步骤如注释所述，下面分别讲解这些步骤内的原理。</p>
<h2 id="创建Subject对象"><a href="#创建Subject对象" class="headerlink" title="创建Subject对象"></a>创建Subject对象</h2><p>创建 Subject 对象的主要方法是：<code>securityManager.createSubject(subjectContext)</code>。这里的”securityManager”就是我们配置的<code>DefaultWebSecurityManager</code>，”subjectContext”的类型是<code>DefaultWebSubjectContext</code>。从 SpringShiroFilter 过来时，subjextContext 是新创建的对象，里面只保存了 servletRequest、servletResponse 以及 securityManager。</p>
<blockquote>
<p>DefaultWebSubjectContext 介绍</p>
</blockquote>
<p>DefaultWebSubjectContext 继承自<code>DefaultSubjectContext</code>，保存数据的方式是把它们保存在成员<code>Map&lt;String, Object&gt; backingMap</code>中，每种数据的 KEY 均有定义。</p>
<p>DefaultSubjectContext 实现<code>SubjectContext</code>接口，继承<code>MapContext</code>类。SubjectContext 接口继承 Map 接口并定义了额外方法，MapContext 类定义了成员<code>Map&lt;String, Object&gt; backingMap</code>并实现了 Map 接口，所以 DefaultSubjectContext 类只需实现 SubjectContext 接口中的方法。</p>
<hr>
<p>下面来看<code>securityManager.createSubject(subjectContext)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Subject <span class="title">createSubject</span><span class="params">(SubjectContext subjectContext)</span> </span>&#123;</span><br><span class="line">	SubjectContext context = copy(subjectContext); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	context = ensureSecurityManager(context); <span class="comment">// 2</span></span><br><span class="line">	</span><br><span class="line">	context = resolveSession(context); <span class="comment">// 3</span></span><br><span class="line">	</span><br><span class="line">	context = resolvePrincipals(context); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">	Subject subject = doCreateSubject(context); <span class="comment">// 5</span></span><br><span class="line">	</span><br><span class="line">	save(subject); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面注释中的序号就是创建 subject 对象的步骤：</p>
<ol>
<li>用入参复制出另一个 context 对象，下面都是对这个 context 对象操作</li>
<li>若 context 中没有设置过 securityManager，就把当前的 securityManager 设置到 context 中</li>
<li>在 context 中解析 session</li>
<li>在 context 中解析 principals</li>
<li>根据 context 创建新的 subject 对象</li>
<li>保存新创建的 subject 对象。如果用户已登录，在这步中还会将用户登录后的 sessionId 放入 servletResponse 的请求头中</li>
</ol>
<p>下面的小节会详细解释第三至第六步骤的实现原理。</p>
<h3 id="解析session"><a href="#解析session" class="headerlink" title="解析session"></a>解析session</h3><p>这节讲的是创建 subject 对象的第3步：在 context 中解析 session。</p>
<blockquote>
<p>这里解析出的”session”，接口类型就是 Session，但需要注意这个 Session 接口是 Shiro 定义的，不是 Tomcat 定义的。实现类有 SimpleSession、HttpServletSession 等。</p>
</blockquote>
<p>这一步调用的方法是<code>securityManager.resolveSession(context)</code>，这个方法里嵌套调用了别的方法，看起来有点散，我整理了相关源码，主要逻辑（去掉嵌套调用、异常处理和日志打印）如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context 是否已经保存了 session（保存在 backingMap 里），已保存则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (context.resolveSession() != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 context 中查询 sessionId（保存在 backingMap 里），构造 sessionKey</span></span><br><span class="line">SessionKey key = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (WebUtils.isWeb(context)) &#123; <span class="comment">// context=DefaultWebSubjectContext返回true</span></span><br><span class="line">	Serializable sessionId = context.getSessionId();</span><br><span class="line">	ServletRequest request = WebUtils.getRequest(context);</span><br><span class="line">	ServletResponse response = WebUtils.getResponse(context);</span><br><span class="line">	key = <span class="keyword">new</span> WebSessionKey(sessionId, request, response);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	Serializable sessionId = context.getSessionId();</span><br><span class="line">	<span class="keyword">if</span> (sessionId != <span class="keyword">null</span>) &#123;</span><br><span class="line">		key = <span class="keyword">new</span> DefaultSessionKey(sessionId);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 sessionKey 从 sessionManager 中查询 session</span></span><br><span class="line">Session session = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">	session = sessionManager.getSession(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 session 保存到 context</span></span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">	context.setSession(session);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法最后返回 context</span></span><br><span class="line"><span class="keyword">return</span> context;</span><br></pre></td></tr></table></figure>

<p>如上，若 context 中没有保存 session 对象，则先从 context 中取 sessionId 封装成<code>SessionKey</code>，再用 sessionId 从”sessionManager”中取出 session，设置到 context 中。</p>
<p>当请求从 SpringShiroFilter 过来，context 是新创建的，里面只保存了 servletRequest、servletResponse 以及 securityManager，没有保存 session 和 sessionId。所以获取 session 只能通过 sessionManager。</p>
<p>sessionManager 是当前 securityManager 的成员，类型就是<code>SessionManager</code>接口，实现类有<code>ServletContainerSessionManager</code>（默认）、<code>DefaultWebSessionManager</code>（这个类可以设置 session 过期时间）等。这2种实现类获取 session 的实现不同：</p>
<ol>
<li><code>ServletContainerSessionManager</code>获取 session 的方法是调用<code>HttpServletRequest.getSession(false)</code>，将<code>HttpSession</code>(javax.servlet.http)封装成<code>HttpServletSession</code>返回。</li>
<li><code>DefaultWebSessionManager</code>获取 session 的方法是通过它的成员<code>SessionDAO sessionDAO</code>，使用的实现类是<code>MemorySessionDAO</code>。MemorySessionDAO 是把 session 保存在 ConcurrentHashMap&lt;Serializable, Session&gt; 中（key=sessionId）。</li>
</ol>
<blockquote>
<p>DefaultWebSessionManager 在通过 sessionDAO 取 session 之前，要先从 sessionKey 中取 sessionId，若取不到，则会调用 HttpServletRequest.getCookies()，取出 name=”JSESSIONID” 的 cookie 值，若还是取不到（如用户禁用了cookie），再从 requestURL 中取。这部分代码见”DefaultWebSessionManager.getSessionId()”方法。</p>
</blockquote>
<p>综上，只要当前用户请求的 Cookie 或 URI 中带了”JSESSIONID=XXX”，这一步就可以解析出 session 对象并保存到 context 中。</p>
<h3 id="解析principals"><a href="#解析principals" class="headerlink" title="解析principals"></a>解析principals</h3><p>这节讲的是创建 subject 对象的第4步：在 context 中解析 principals。</p>
<p>解析出的 principals 对象，类型是<code>PrincipalCollection</code>。在从 context 中解析这个对象时，首先从 backingMap 中直接取，没取到则依次从<code>AuthenticationInfo</code>、<code>Subject</code>、<code>Session</code>取（这些对象也保存在 backingMap 中），只要能从其中一个对象中取到，就不再继续了，也有可能一直都没取到。</p>
<p>当未登录用户请求某个非认证接口，从 SpringShiroFilter 过来，context 都没有保存这些对象，则这一步没有解析出 principals 对象。</p>
<p>当未登录用户请求认证接口，在用户认证成功后，会进入这个方法，此时 context 中保存了用户认证对象<code>AuthenticationInfo</code>（这个对象是 Realm 返回的），在这一步中可以解析出 AuthenticationInfo 中的成员 principals。在认证接口返回响应前，这个 principals 对象会被保存到 session 中（见下一节）。</p>
<p>已登录用户的后续请求中，请求的 Cookie 或 URI 中带有”JSESSIONID=XXX”，上一节步骤就会取出当前用户的 session，到了这一步，context 就可以从 session 中解析出 principals 对象。</p>
<blockquote>
<p>在这一步中，如果从 context 中没有解析出 principals ，那么会尝试使用”RememberMe”功能取 principals 再设置到 context 中。因”RememberMe”功能不在这篇博客讨论范围内，所以忽略。</p>
</blockquote>
<p>经过这一步之后，若 context 中直接或间接保存了 principals，这个 principals 对象会保存到下一步创建的 subject 对象中，并且会更新到 session 中（详情见下一节）。</p>
<h3 id="创建新的subject对象并保存"><a href="#创建新的subject对象并保存" class="headerlink" title="创建新的subject对象并保存"></a>创建新的subject对象并保存</h3><p>这节讲的是创建 subject 对象的第5、第6步：根据 context 创建新的 subject 对象，保存新创建的 subject 对象。</p>
<p>根据 context 创建新的 subject 对象依靠 securityManager 成员<code>SubjectFactory</code>，使用的实现类是<code>DefaultWebSubjectFactory</code>，创建的 subject 对象类型是<code>WebDelegatingSubject</code>。创建出的 subject 对象内容包括 principals、session、servletRequest、servletResponse、securityManager 等，都是从 context 中取的。</p>
<p>保存新创建的 subject 对象依靠 securityManager 成员<code>SubjectDAO</code>，默认使用实现类<code>DefaultSubjectDAO</code>，这也是 Shiro 唯一的实现类。</p>
<p><code>SubjectDAO</code>接口只定义了2个方法：save 和 delete，方法参数都是 subject 对象。</p>
<p>DefaultSubjectDAO.save() 方法的实现是：首先判断是否需要保存 session（默认需要），需要才执行保存。执行保存时，如果 subject 中存在 principals，就把这个 principals 保存到 subject 中的 session 中（<strong>如果没有 session 则会新建</strong>）。如果 subject 中的 authenticated(已认证标志) 为 true，也会在 subject 中的 session 中设置这个属性。</p>
<p>从上面描述可以得知：</p>
<ol>
<li>DefaultSubjectDAO 保存和删除 subject 对象，并不是把它保存到什么位置，或从什么位置删除。保存时，是把 subject 对象中的 principals、authenticated(已认证标志) 更新到此 subject 的 session 对象中。删除时，就是从 subject 中的 session（如果有的话）中删除这两个元素。</li>
<li>当且仅当 subject 中存在 principals 或 authenticated=true 时，subject 才会在没有 session 的情况下新建一个 session 对象。</li>
</ol>
<hr>
<p>下面讲解 subject 是如何新建 session 对象的（以 WebDelegatingSubject 为例）。</p>
<p>WebDelegatingSubject 创建 session 是调用<code>securityManager.start(sessionContext)</code>方法，创建出的 session 类型是<code>StoppingAwareProxiedSession</code>。其中”sessionContext”是一个新建的空对象，类型是<code>DefaultWebSessionContext</code>。它和<code>SubjectContext</code>相似，也继承自 MapContext。</p>
<p>securityManager = DefaultWebSecurityManager，在它的 start 方法中，又调用<code>sessionManager.start(context)</code>来创建 session。如在“解析session”一节中所述，这个 sessionManager 是 securityManager 的成员，实现类是<code>ServletContainerSessionManager</code>或<code>DefaultWebSessionManager</code>。这2种实现类创建 session 的实现不同：</p>
<ol>
<li>ServletContainerSessionManager 创建 session 的方法是调用<code>HttpServletRequest.getSession()</code>，将<code>HttpSession</code>(javax.servlet.http)封装成<code>HttpServletSession</code>返回。</li>
<li>DefaultWebSessionManager 创建 session 的方法是通过它的成员<code>SessionFactory sessionFactory</code>，使用的实现类是<code>SimpleSessionFactory</code>，创建的 session 类型是<code>SimpleSession</code>（内容只有”host”）。创建好 session 后，DefaultWebSessionManager 会把它保存到成员<code>SessionDAO sessionDAO</code>，实现类是<code>MemorySessionDAO</code>。MemorySessionDAO 将创建的 session 保存到 ConcurrentHashMap&lt;Serializable, Session&gt; 中（sessionId自动生成）。保存好 session 后，DefaultWebSessionManager 会将 sessionId 写入 HttpServletResponse 的响应头”Set-Cookie:JSESSIONID=XXX”中。</li>
</ol>
<h2 id="subject-创建好-session-后，会把自己的-principals-和-authenticated-设置到-session-中。HttpServletSession-保存数据的方式是保存到HttpSession-javax-servlet-http-的attributes，SimpleSession-是保存到自己的Map-lt-Object-Object-gt-attributes。"><a href="#subject-创建好-session-后，会把自己的-principals-和-authenticated-设置到-session-中。HttpServletSession-保存数据的方式是保存到HttpSession-javax-servlet-http-的attributes，SimpleSession-是保存到自己的Map-lt-Object-Object-gt-attributes。" class="headerlink" title="subject 创建好 session 后，会把自己的 principals 和 authenticated 设置到 session 中。HttpServletSession 保存数据的方式是保存到HttpSession(javax.servlet.http)的attributes，SimpleSession 是保存到自己的Map&lt;Object, Object&gt; attributes。"></a>subject 创建好 session 后，会把自己的 principals 和 authenticated 设置到 session 中。HttpServletSession 保存数据的方式是保存到<code>HttpSession</code>(javax.servlet.http)的<code>attributes</code>，SimpleSession 是保存到自己的<code>Map&lt;Object, Object&gt; attributes</code>。</h2><p>综上，当未登录用户请求认证接口，在用户认证成功后，会进入这个方法，根据上一节所述，此时 subject 中保存了 principals 和 authenticated(已认证标志)，但没有 session。subject 会新建一个 session，如果使用的是 DefaultWebSessionManager，这个新建的 session 会保存在内存中，且 sessionId 会写入响应头”Set-Cookie:JSESSIONID=XXX”。然后，将 subject 中的 principals 和 authenticated(已认证标志) 设置到新建的 session 对象中。</p>
<p>如果未登录用户持续发请求，那么这一步 subject 不会新建 session，只有用户登录后 subject 才会新建 session。用户登录后的每次请求，都会带上”JSESSIONID”，在“解析session”的步骤中，如果使用的是 DefaultWebSessionManager，就可以从 MemorySessionDAO 中查询出用户的 session，session 里面包含了 principals 和 authenticated 元素。</p>
<h2 id="取url对应的过滤器链"><a href="#取url对应的过滤器链" class="headerlink" title="取url对应的过滤器链"></a>取url对应的过滤器链</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>经过上面的步骤，若是已登录用户的请求，创建的 subject 对象会包含 principals、session 等信息。创建后，调用<code>subject.execute()</code>方法。</p>
<p><code>subject.execute()</code>的方法参数是<code>Callable</code>，在这里可以理解为一个回调方法，这个回调方法的内容就是这两行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在指定条件下，更新session中用户最近一次请求的时间</span></span><br><span class="line">updateSessionLastAccessTime(request, response);</span><br><span class="line"><span class="comment">// 取url对应的过滤器链并执行</span></span><br><span class="line">executeChain(request, response, chain);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，Callable 一般和 FutureTask 配合，用于多线程编程。它和 Runnable 的区别在于，它的 call 方法可以获取线程执行后的返回值，而 Runnable 的 run 方法无返回值。在当前场景下，Callable 作为回调方法使用，是同步执行的。</p>
</blockquote>
<p>在<code>subject.execute()</code>方法中，先把<code>Callable</code>封装成<code>SubjectCallable</code>，再调用 SubjectCallable.call() 方法。SubjectCallable 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectCallable</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ThreadState threadState;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubjectCallable</span><span class="params">(Subject subject, Callable&lt;V&gt; delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> SubjectThreadState(subject), delegate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SubjectCallable</span><span class="params">(ThreadState threadState, Callable&lt;V&gt; delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadState == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ThreadState argument cannot be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.threadState = threadState;</span><br><span class="line">        <span class="keyword">if</span> (delegate == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Callable delegate instance cannot be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.callable = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadState.bind();</span><br><span class="line">            <span class="keyword">return</span> doCall(<span class="keyword">this</span>.callable);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadState.restore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> V <span class="title">doCall</span><span class="params">(Callable&lt;V&gt; target)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SubjectCallable 的成员”Callable callable”就是上面声明的回调方法，”ThreadState threadState”在构造方法中被赋值<code>SubjectThreadState</code>。在 call 方法中，先后调用了这两个成员的方法。</p>
<p>第一个方法<code>threadState.bind()</code>内部调用了<code>ThreadContext.bind(subject)</code>，subject 即为上个步骤创建的 subject 对象，ThreadContext 将这个对象保存在<code>ThreadLocal&lt;Map&lt;Object, Object&gt;&gt;</code>中。在这之后用<code>SecurityUtils.getSubject()</code>来获取 subject 时，就可以从 ThreadContext 中取到 subject。</p>
<p>第二个方法<code>target.call()</code>，就是执行了上面给出的回调方法的两行内容，一是更新 session 时间（当使用的 sessionManager=ServletContainerSessionManager 时才会更新），二是取 url 对应的过滤器链并执行。</p>
<p>在这两个方法执行完后，即过滤器链也执行完了，进入 finally 块，清空 ThreadContext 中的 ThreadLocal 内容。</p>
<h3 id="取过滤器链并执行"><a href="#取过滤器链并执行" class="headerlink" title="取过滤器链并执行"></a>取过滤器链并执行</h3><p>这一节讲 SpringShiroFilter 中的 executeChain 方法，也是上面回调方法中的第二个方法。在这个方法中，首先要取 url 对应的过滤器链，就是下面源码所展示的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> FilterChain <span class="title">getExecutionChain</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain origChain)</span> </span>&#123;</span><br><span class="line">	FilterChain chain = origChain;</span><br><span class="line"></span><br><span class="line">	FilterChainResolver resolver = getFilterChainResolver();</span><br><span class="line">	<span class="keyword">if</span> (resolver == <span class="keyword">null</span>) &#123;</span><br><span class="line">		log.debug(<span class="string">"No FilterChainResolver configured.  Returning original FilterChain."</span>);</span><br><span class="line">		<span class="keyword">return</span> origChain;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FilterChain resolved = resolver.getChain(request, response, origChain);</span><br><span class="line">	<span class="keyword">if</span> (resolved != <span class="keyword">null</span>) &#123;</span><br><span class="line">		log.trace(<span class="string">"Resolved a configured FilterChain for the current request."</span>);</span><br><span class="line">		chain = resolved;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.trace(<span class="string">"No FilterChain configured for the current request.  Using the default."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上源码可以看出，负责“取 url 对应的过滤器链”这项工作的是 SpringShiroFilter 的成员<code>PathMatchingFilterChainResolver</code>。如果这个成员为 Null 或没有与 url 匹配的过滤器链，那么这个方法会返回原过滤器链，即<code>ApplicationFilterChain</code>。</p>
<p>在<code>PathMatchingFilterChainResolver.getChain()</code>方法中（源码如下），遍历其成员<code>DefaultFilterChainManager</code>中的<code>Map&lt;String, NamedFilterList&gt; filterChains</code>的 key，与当前请求 url 进行匹配，若匹配上，则调用<code>DefaultFilterChainManager.proxy()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FilterChain <span class="title">getChain</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain originalChain)</span> </span>&#123;</span><br><span class="line">    FilterChainManager filterChainManager = getFilterChainManager();</span><br><span class="line">    <span class="keyword">if</span> (!filterChainManager.hasChains()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String requestURI = getPathWithinApplication(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String pathPattern : filterChainManager.getChainNames()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pathMatches(pathPattern, requestURI)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(<span class="string">"Matched path pattern ["</span> + pathPattern + <span class="string">"] for requestURI ["</span> + requestURI + <span class="string">"].  "</span> +</span><br><span class="line">                        <span class="string">"Utilizing corresponding filter chain..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> filterChainManager.proxy(originalChain, pathPattern);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DefaultFilterChainManager.proxy()</code>方法的作用是，从<code>Map&lt;String, NamedFilterList&gt; filterChains</code>中取出的过滤器链类型是<code>SimpleNamedFilterList</code>（见 ensureChain 方法），将这个过滤器链再度封装成<code>ProxiedFilterChain</code>类型。</p>
<p>所以，SpringShiroFilter 通过 PathMatchingFilterChainResolver 取出的过滤器链是<code>ProxiedFilterChain</code>类型，执行过滤器链时，就是调用<code>ProxiedFilterChain.doFilter()</code>方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.filters == <span class="keyword">null</span> || <span class="keyword">this</span>.filters.size() == <span class="keyword">this</span>.index) &#123;</span><br><span class="line">        <span class="comment">//we've reached the end of the wrapped chain, so invoke the original one:</span></span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">"Invoking original filter chain."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.orig.doFilter(request, response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">"Invoking wrapped filter at index ["</span> + <span class="keyword">this</span>.index + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.filters.get(<span class="keyword">this</span>.index++).doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是典型的过滤器链的实现，通过下标 index 自增来遍历 List<Filter> filters 中每个元素，遍历完了就执行原过滤器链，即<code>ApplicationFilterChain</code>。</p>
<p>至此，SpringShiroFilter的工作原理介绍完了。通过过滤器链，就可以进入 Shiro 的认证与授权流程了。</p>
</div></article><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/10/05/tomcat-filter-chain/"><span>Tomcat过滤器链原理</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By yunnight</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>