<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="RestTemplate负载均衡原理"><meta name="keywords" content="源码"><meta name="author" content="yunnight"><meta name="copyright" content="yunnight"><title>RestTemplate负载均衡原理 | yunnight</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#挑选服务节点"><span class="toc-number">2.</span> <span class="toc-text">挑选服务节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ILoadBalancer"><span class="toc-number">2.1.</span> <span class="toc-text">ILoadBalancer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IRule"><span class="toc-number">2.2.</span> <span class="toc-text">IRule</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#获取服务列表"><span class="toc-number">3.</span> <span class="toc-text">获取服务列表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-1"><span class="toc-number">3.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#组件的自动配置"><span class="toc-number">4.</span> <span class="toc-text">组件的自动配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LoadBalancerInterceptor的配置"><span class="toc-number">4.1.</span> <span class="toc-text">LoadBalancerInterceptor的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ILoadBalancer的配置"><span class="toc-number">4.2.</span> <span class="toc-text">ILoadBalancer的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置类的加载顺序"><span class="toc-number">4.3.</span> <span class="toc-text">配置类的加载顺序</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/yunnight/pics/master/blog_avatar.jpg"></div><div class="author-info__name text-center">yunnight</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">36</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">yunnight</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">RestTemplate负载均衡原理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/SpringCloud/"> SpringCloud</a></div><div class="article-container" id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当我们使用 RestTemplate 调用服务时，会经过以下几个过程：</p>
<ol>
<li>RestTemplate 发送的请求被 LoadBalancerInterceptor 拦截，LoadBalancerInterceptor 调用 LoadBalancerClient.execute() 方法处理请求。LoadBalancerClient 默认使用的实现类是 RibbonLoadBalancerClient</li>
<li>在 RibbonLoadBalancerClient.execute() 方法中，用 serviceId（被调方的服务名）获取一个 ILoadBalancer 对象，再调用 ILoadBalancer.chooseServer() 方法</li>
<li>在 ILoadBalancer.chooseServer() 方法中，调用 IRule.choose() 方法，从被调服务的多个节点中选出一个节点</li>
<li>选出服务节点后，把原本是服务名的请求 URI 换成这个节点的IP+端口，发送请求，得到响应</li>
</ol>
<p>下面先讲第一个重点： ILoadBalancer 和 IRule 是怎么挑选被调服务的某个节点的？</p>
<p>PS：文中的源码版本是 SpringCloud Finchley.RELEASE, SpringBoot 2.0.9.RELEASE</p>
<h1 id="挑选服务节点"><a href="#挑选服务节点" class="headerlink" title="挑选服务节点"></a>挑选服务节点</h1><p>这部分的逻辑有一丢丢复杂，我只选有关联的讲，能省则省，注意跟紧不要掉队咯~</p>
<h2 id="ILoadBalancer"><a href="#ILoadBalancer" class="headerlink" title="ILoadBalancer"></a>ILoadBalancer</h2><p>ILoadBalancer 的实现类的继承关系（从父类到子类）：ILoadBalancer -&gt; AbstractLoadBalancer -&gt; BaseLoadBalancer -&gt; DynamicServerListLoadBalancer -&gt; ZoneAwareLoadBalancer</p>
<p><code>ILoadBalancer</code>定义了挑选服务节点的基本方法：<code>chooseServer</code>。<code>AbstractLoadBalancer</code>只是给 ILoadBalancer 接口扩展了几个方法。</p>
<p><code>BaseLoadBalancer</code>定义了成员变量<code>IRule</code>，IRule 的默认值为<code>RoundRobinRule</code>，就是轮询算法。在 BaseLoadBalancer.chooseServer() 方法中，直接调用 IRule.choose() 方法挑选服务节点。</p>
<p><code>DynamicServerListLoadBalancer</code>未重写父类的 chooseServer 方法，但它实现了服务实例清单在运行期的动态更新能力（这个后面讲）。</p>
<p><code>ZoneAwareLoadBalancer</code>重写了 chooseServer 方法，它比父类方法多了一个判断：被调服务的节点存在于一个 Zone 内还是分布在多个 Zone？</p>
<p>如果是分布在多个 Zone，ZoneAwareLoadBalancer 首先使用<code>ZoneAvoidanceRule</code>计算每个 Zone 的可用性，再从可用的 Zone 中<strong>随机选一个</strong>。选出一个 Zone 后，再用 IRule 从这个 Zone 内的节点列表内挑选一个节点。</p>
<p>如果就只存在于一个 Zone 内，那就不需要选择 Zone 了，直接用 IRule 从这个 Zone 内的节点列表内挑选一个节点。</p>
<p><strong>因此，无论是哪种情况，最后都是调用成员 IRule 的 choose 方法挑选服务节点</strong>。</p>
<p>在配置类<code>RibbonClientConfiguration</code>中，配置了 ILoadBalancer 实现类是<code>ZoneAwareLoadBalancer</code>，IRule 实现类是<code>ZoneAvoidanceRule</code>。所以在默认配置下，最后负责挑选服务节点的方法是<code>ZoneAvoidanceRule.choose()</code>。</p>
<hr>
<p>不了解什么是 Zone？这里简单介绍下：</p>
<p>Zone 和 Region 是两个区域的概念。一个 Region 下可以包含多个 Zone，一个 Zone 只对应一个 Region。这两个属性的意义在于可以指定客户端的某个节点位于某个 Zone 内，这个客户端调用其他服务时，优先在自己的 Zone 内选被调服务的节点，如果没有再去别的 Zone 选服务节点，减少了远程调用的次数。</p>
<p>对于这两个属性的概念，我也参照其他博客的理解：Region 代表地区，如北京、新加坡，Zone 代表机房，如北京下有两个机房：bj-zone1 和 bj-zone2。</p>
<p>我们没有使用到这两个属性时，每个节点的注册中心地址配置都是<code>eureka.client.serviceUrl.defalutZone = xxx</code>。在这个配置下，所有节点所在的 Region =”us-east-1”，Zone = “defalutZone”，这两个默认值在<code>EurekaClientConfigBean</code>中指定。</p>
<h2 id="IRule"><a href="#IRule" class="headerlink" title="IRule"></a>IRule</h2><p>因为默认使用的是 ZoneAvoidanceRule，所以这里只介绍它和它的父类们 O(∩_∩)O</p>
<p>继承关系（从父类到子类）：IRule -&gt; AbstractLoadBalancerRule -&gt; ClientConfigEnabledRoundRobinRule -&gt; PredicateBasedRule -&gt; ZoneAvoidanceRule</p>
<p><code>IRule</code>接口和<code>AbstractLoadBalancerRule</code>抽象类定义了挑选服务节点的基本方法：choose，以及成员<code>ILoadBalancer lb</code>，ILoadBalancer 在 IRule 中的作用就是“获取服务节点列表”。【结合上面介绍的 BaseLoadBalancer，可以看出 ILoadBalancer 和 IRule 互相依赖</p>
<p><code>ClientConfigEnabledRoundRobinRule</code>实现了 choose 方法：调用 RoundRobinRule.choose() 挑选服务节点。这个类的作用是为其子类的 choose 方法提供一个备选方案。</p>
<p><code>PredicateBasedRule</code>是个抽象类，定义了获取<code>AbstractServerPredicate</code>对象的方法，交由子类实现。它的 choose 方法就是调用 AbstractServerPredicate 对象的 chooseRoundRobinAfterFiltering 方法挑选服务节点并返回。</p>
<hr>
<p>下面先介绍一下 AbstractServerPredicate.chooseRoundRobinAfterFiltering() 方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title">chooseRoundRobinAfterFiltering</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">    List&lt;Server&gt; eligible = getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">    <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.absent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(eligible.get(incrementAndGetModulo(eligible.size())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，chooseRoundRobinAfterFiltering 方法把形参 List<Server> servers（被调服务的节点列表）交给<code>getEligibleServers</code>方法进行过滤，得到过滤后的节点列表。如果返回的列表为空，则用 Optional.absent() 表示服务不存在，反之则以<strong>线性轮询</strong> 的方式从过滤后的节点列表中获取一个实例并返回。</p>
<p>getEligibleServers 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getEligibleServers</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loadBalancerKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ImmutableList.copyOf(Iterables.filter(servers, <span class="keyword">this</span>.getServerOnlyPredicate()));            </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        List&lt;Server&gt; results = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">for</span> (Server server: servers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.apply(<span class="keyword">new</span> PredicateKey(loadBalancerKey, server))) &#123;</span><br><span class="line">                results.add(server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，进入 else 分支，遍历 servers，对每个 server 执行 apply 方法，<strong>apply 方法就是服务过滤的逻辑</strong>，apply 方法返回true，就将此 server 加入要返回的列表，false就不加入。</p>
<blockquote>
<p>什么情况下不进入 else 分支？<br>很少。因为从RibbonLoadBalancerClient.execute() 方法开始一直传进来的 loadBalancerKey=”default”，所以都会进入 else 分支。</p>
</blockquote>
<p>综上，AbstractServerPredicate.chooseRoundRobinAfterFiltering() 是一个模板方法，<strong>定义了处理被调服务节点列表的模板：先过滤列表，再轮询选择。</strong>其中用于过滤服务节点列表的 apply 方法由 AbstractServerPredicate 的子类实现。</p>
<p>AbstractServerPredicate 有一个重要的子类：<code>CompositePredicate</code>。</p>
<p>CompositePredicate 成员变量包括一个主过滤条件<code>AbstractServerPredicate delegate</code>和一组次过滤条件<code>List&lt;AbstractServerPredicate&gt; fallbacks</code>。它重写了 getEligibleServers 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getEligibleServers</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">    List&lt;Server&gt; result = <span class="keyword">super</span>.getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">    Iterator&lt;AbstractServerPredicate&gt; i = fallbacks.iterator();</span><br><span class="line">    <span class="keyword">while</span> (!(result.size() &gt;= minimalFilteredServers &amp;&amp; result.size() &gt; (<span class="keyword">int</span>) (servers.size() * minimalFilteredPercentage))</span><br><span class="line">            &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">        AbstractServerPredicate predicate = i.next();</span><br><span class="line">        result = predicate.getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，它的 getEligibleServers 方法先调用了父类 AbstractServerPredicate 的同名方法，父类的这个方法又会调用子类（此处是 CompositePredicate）的 apply 方法。CompositePredicate 的 apply 方法就是使用主过滤条件 ———— delegate.apply()。</p>
<p>从父类方法返回 List<Server> result 后，对 result 列表长度进行判断，判断条件简单地写就是：”!(result.size() &gt;= 1 &amp;&amp; result.size() &gt; 0)”，即如果 result 列表长度大于1，该条件就不成立，不会进入 while 循环，直接将 result 列表返回。如果这个条件成立，就依次使用次过滤条件 fallbacks 对 servers 进行过滤，直到该条件不成立，或 fallbacks 全部使用过了，就返回最后的过滤结果。</p>
<hr>
<p>说回到 PredicateBasedRule，它的子类<code>ZoneAvoidanceRule</code>使用的 AbstractServerPredicate 对象就是 CompositePredicate 类，其中主过滤条件是<code>ZoneAvoidancePredicate</code>，次过滤条件只有<code>AvailabilityPredicate</code>。</p>
<p><code>ZoneAvoidanceRule</code>未重写父类的 choose 方法，所以它的 choose 方法的调用链为：</p>
<p>ZoneAvoidanceRule.choose() -&gt; AbstractServerPredicate.chooseRoundRobinAfterFiltering() -&gt; CompositePredicate.getEligibleServers()</p>
<p>因此，ZoneAvoidanceRule.choose() 逻辑为“先过滤列表，再轮询选择”。过滤节点列表时，先用 ZoneAvoidancePredicate 过滤一遍，如果过滤后的列表个数小于1，才会使用到次过滤条件 AvailabilityPredicate。</p>
<p>ZoneAvoidancePredicate 和 AvailabilityPredicate 的过滤逻辑，简单地说就是：<br>ZoneAvoidancePredicate 计算了列表内所有节点所在的 Zone 的可用性，只留下了在可用 Zone 内的节点；<br>AvailabilityPredicate 排除了断路器打开（说明服务可能故障）或并发请求数过多的节点。</p>
<p>因为很少使用次过滤条件，我们可以简单地说：<strong>ZoneAvoidanceRule 先筛选出在可用 Zone 内的被调服务节点列表，再用“线性轮询”的方法从中选出一个。</strong></p>
<p>至此，默认配置下的挑选服务的逻辑讲完啦~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在默认配置下，负责挑选服务节点的是 ZoneAwareLoadBalancer.chooseServer() 方法。</p>
<p>ZoneAwareLoadBalancer.chooseServer() 方法先判断：被调服务的节点存在于一个 Zone 内还是分布在多个 Zone？有多个 Zone 就先计算每个 Zone 的可用性，从可用的 Zone 中随机选一个 Zone。如果只有一个 Zone 就不需要选择了。</p>
<p>确定好 Zone 后，再调用 ZoneAvoidanceRule.choose() 挑选服务节点，此时待挑选的服务列表内的节点都是存在于这个确定好的 Zone 内。</p>
<p>ZoneAvoidanceRule 的 choose 方法就是调用其成员 CompositePredicate 的 chooseRoundRobinAfterFiltering 方法。在这个方法中，先过滤被调服务的节点列表，再用“线性轮询”的方法从过滤后的列表选出一个节点。</p>
<p>过滤列表时，先使用的是 ZoneAvoidancePredicate.apply() 方法，它计算了列表内所有节点所在的 Zone 的可用性，只留下了在可用 Zone 内的节点。</p>
<p>如果 ZoneAvoidancePredicate 过滤后的列表不为空，就用“线性轮询”的方法从这个列表里选出一个节点，结束。【考虑到此时待挑选的列表内的节点都是存在于一个 Zone 内，除非这个 Zone 变得不可用了，不然经过 ZoneAvoidancePredicate 过滤后的列表都是不为空的</p>
<p>如果 ZoneAvoidancePredicate 过滤后的列表为空，再使用 AvailabilityPredicate.apply()  方法过滤，它排除了断路器打开（说明服务可能故障）或并发请求数过多的节点。最后也是用“线性轮询”的方法从过滤后的列表里选出一个节点，结束。</p>
<blockquote>
<p>扩展内容：如果现在需要你自己实现“灰度部署”或“蓝绿部署”，是不是就有思路了？</p>
</blockquote>
<p>哎，就是先自定义一个 AbstractServerPredicate 的子类，在这个子类的 apply 方法里编写过滤服务的代码，比如在“灰度发布”阶段，灰度请求只能进入灰度节点，那么在 apply 方法里就要排除掉正常节点，只留下灰度节点。【至于如何识别正常服务还是灰度服务，可以借助<code>eureka.instance.metadata-map</code>属性，在服务的元数据里体现</p>
<p>然后还需要自定义一个 PredicateBasedRule 的子类，它使用的 AbstractServerPredicate 对象就是刚刚自定义的 AbstractServerPredicate 子类。最后要记得配置 IRule Bean 是自己创建的那个 PredicateBasedRule 子类哦~</p>
<p>Github上有一个实现蓝绿发布的工程：<a href="https://github.com/jmnarloch/ribbon-discovery-filter-spring-cloud-starter" target="_blank" rel="noopener">https://github.com/jmnarloch/ribbon-discovery-filter-spring-cloud-starter</a> 。作者就是在自定义的 AbstractServerPredicate 子类中，过滤出和调用方 flag 一样的节点，比如调用方是蓝节点，就只过滤出被调方的蓝节点。</p>
<h1 id="获取服务列表"><a href="#获取服务列表" class="headerlink" title="获取服务列表"></a>获取服务列表</h1><p>上面我们提到，ILoadBalancer 也是 IRule 的成员，它在 IRule 中的作用就是“获取服务节点列表”。那么问题来了，ILoadBalancer 是怎么获取服务节点列表的？</p>
<p>ILoadBalancer 接口定义了两个方法：<br>(1) <code>List&lt;Server&gt; getReachableServers()</code>————获取正常服务节点<br>(2) <code>List&lt;Server&gt; getAllServers()</code>————获取所有服务节点，包括正常的和停止的节点</p>
<p>IRule.choose() 方法就是先调用 ILoadBalancer 的这两个方法的其中一个，如 PredicateBasedRule 是调用 ILoadBalancer.getAllServers()，获取被调服务的节点列表，再用特定算法选出一个节点。</p>
<p>BaseLoadBalancer 实现了这两个方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有服务，包括正常和停止</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; allServerList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Server&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常服务</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; upServerList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Server&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getReachableServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Collections.unmodifiableList(upServerList);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getAllServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Collections.unmodifiableList(allServerList);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>DynamicServerListLoadBalancer 未重写这两个方法，它实现的是对这两个服务列表，allServerList 和 upServerList 的动态更新。</p>
<p>为了实现服务列表的动态更新，DynamicServerListLoadBalancer 定义了一个成员：<code>ServerList&lt;T&gt; serverListImpl</code>，默认初始化 serverListImpl = <code>DomainExtractingServerList</code>。DomainExtractingServerList 对象里又包含一个成员：<code>ServerList&lt;DiscoveryEnabledServer&gt; list</code>，默认初始化 list = <code>DiscoveryEnabledNIWSServerList</code>。<br>这个“套娃”关系展示如下：</p>
<img src="/2021/02/05/resttemplate-loadbalance/taowa.PNG" class="" title="套娃">


<p><code>ServerList</code>接口有两个方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServerList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Server</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getInitialListOfServers</span><span class="params">()</span></span>; <span class="comment">// 获取初始的服务列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getUpdatedListOfServers</span><span class="params">()</span></span>; <span class="comment">// 获取更新后的服务列表</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DynamicServerListLoadBalancer 就是依赖 ServerList 的 getUpdatedListOfServers 方法获取最新的服务列表，调用链为：</p>
<p>DynamicServerListLoadBalancer.updateListOfServers() -&gt; DomainExtractingServerList.getUpdatedListOfServers() -&gt; DiscoveryEnabledNIWSServerList.getUpdatedListOfServers() -&gt; DiscoveryEnabledNIWSServerList.obtainServersViaDiscovery()</p>
<p>这个调用链最后一环<code>DiscoveryEnabledNIWSServerList.obtainServersViaDiscovery()</code>调用了<code>DiscoveryClient.getInstancesByVipAddress()</code>方法，这个方法根据 serviceId（被调服务的名字），优先从同个 Region 中找服务节点，找到了就返回服务节点列表，同个 Region 下没有再去别的 Region 中找【<strong>DiscoveryClient 的服务列表的来源就是注册中心</strong></p>
<p>DiscoveryEnabledNIWSServerList 得到 DiscoveryClient 返回的节点列表后，从该列表选出状态为 UP 的节点，把每个服务节点包装成<code>DiscoveryEnabledServer</code>对象。</p>
<p>DomainExtractingServerList 得到 DiscoveryEnabledNIWSServerList 返回的节点列表后，再把每个节点包装成<code>DomainExtractingServer</code>对象返回给 DynamicServerListLoadBalancer，其中每个节点的 Zone 属性来源于节点的元数据配置，配置项为<code>eureka.instance.metadata-map.zone</code>。</p>
<p>上面的调用链中第一个方法<code>DynamicServerListLoadBalancer.updateListOfServers()</code>，就是负责更新 allServerList 和 upServerList 的方法。这个方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateListOfServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       List&lt;T&gt; servers = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">       <span class="keyword">if</span> (serverListImpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">           servers = serverListImpl.getUpdatedListOfServers();<span class="comment">// 调用成员serverListImpl</span></span><br><span class="line">           LOGGER.debug(<span class="string">"List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,</span><br><span class="line">                   getIdentifier(), servers);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (filter != <span class="keyword">null</span>) &#123;</span><br><span class="line">               servers = filter.getFilteredListOfServers(servers);<span class="comment">// 调用成员filter</span></span><br><span class="line">               LOGGER.debug(<span class="string">"Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,</span><br><span class="line">                       getIdentifier(), servers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       updateAllServerList(servers);<span class="comment">// 最终把列表传给另一个方法，由这个方法更新服务列表</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>如上，从 serverListImpl.getUpdatedListOfServers() 得到节点列表后，接着使用成员<code>filter</code>对这个列表进行过滤， filter 默认初始化为<code>ZonePreferenceServerListFilter</code>。</p>
<p>ZonePreferenceServerListFilter 过滤列表时，先调用父类方法。在父类方法中，判断是否启用“区域感知”功能（shouldEnableZoneAffinity），判断的依据是当前区域（Zone）是否健康（有几个指标来评估），如果当前 Zone 健康，就启用“区域感知”功能，过滤出和调用方 Zone 一致的节点并返回。如果当前 Zone 不健康，就不启用“区域感知”，返回的列表是没过滤的、分布在多个 Zone 的被调方节点列表。</p>
<p>从父类方法返回后，ZonePreferenceServerListFilter 接着判断父类是不是已经做过过滤了（过滤后的列表和过滤前是否一样）。如果已经被过滤了，就直接返回父类的结果。如果没有被过滤，则子类再从列表中过滤出和调用方 Zone 一致的节点，返回。</p>
<p>总之，经过 ZonePreferenceServerListFilter 的过滤，被调方节点列表中只留下了和调用方在同一个 Zone 内的节点。这就实现了“优先调用同个 Zone 内的节点”。但，前提是被调方在这个 Zone 内有节点，否则结果依然是没过滤的、分布在其他多个 Zone 的被调方节点列表。</p>
<p>filter 过滤完后，把过滤后的、最新的节点列表传入<code>updateAllServerList</code>方法，这个方法内接着调用<code>DynamicServerListLoadBalancer.setServersList()</code>方法。</p>
<p>DynamicServerListLoadBalancer.setServersList() 方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServersList</span><span class="params">(List lsrv)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.setServersList(lsrv); <span class="comment">// 调用父类方法</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 根据节点所在的 Zone 进行分类</span></span><br><span class="line">       List&lt;T&gt; serverList = (List&lt;T&gt;) lsrv;</span><br><span class="line">       Map&lt;String, List&lt;Server&gt;&gt; serversInZones = <span class="keyword">new</span> HashMap&lt;String, List&lt;Server&gt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (Server server : serverList) &#123;</span><br><span class="line">           <span class="comment">// make sure ServerStats is created to avoid creating them on hot</span></span><br><span class="line">           <span class="comment">// path</span></span><br><span class="line">           getLoadBalancerStats().getSingleServerStat(server);</span><br><span class="line">           String zone = server.getZone();</span><br><span class="line">           <span class="keyword">if</span> (zone != <span class="keyword">null</span>) &#123;</span><br><span class="line">               zone = zone.toLowerCase();</span><br><span class="line">               List&lt;Server&gt; servers = serversInZones.get(zone);</span><br><span class="line">               <span class="keyword">if</span> (servers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   servers = <span class="keyword">new</span> ArrayList&lt;Server&gt;();</span><br><span class="line">                   serversInZones.put(zone, servers);</span><br><span class="line">               &#125;</span><br><span class="line">               servers.add(server);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">       setServerListForZones(serversInZones); <span class="comment">// 调用子类方法</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>方法形参<code>List lsrv</code>就是过滤后的、最新的节点列表，这个方法做了3件事：</p>
<ol>
<li>调用父类 BaseLoadBalancer 的 setServersList 方法，这个方法将 allServerList 和 upServerList 都更新为 lsrv</li>
<li>整理过滤后的节点列表，根据节点所在的 Zone 进行分类，分类完后是一个 Map，key 为 Zone 的名字，value 为这个 Zone 下的节点列表</li>
<li>把分类后的 Map 传给子类方法 ZoneAwareLoadBalancer.setServerListForZones()</li>
</ol>
<p><code>ZoneAwareLoadBalancer.setServerListForZones()</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setServerListForZones</span><span class="params">(Map&lt;String, List&lt;Server&gt;&gt; zoneServersMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setServerListForZones(zoneServersMap);</span><br><span class="line">    <span class="keyword">if</span> (balancers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        balancers = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BaseLoadBalancer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Server&gt;&gt; entry: zoneServersMap.entrySet()) &#123;</span><br><span class="line">    	String zone = entry.getKey().toLowerCase();</span><br><span class="line">        getLoadBalancer(zone).setServersList(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, BaseLoadBalancer&gt; existingLBEntry: balancers.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!zoneServersMap.keySet().contains(existingLBEntry.getKey())) &#123;</span><br><span class="line">            existingLBEntry.getValue().setServersList(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function">BaseLoadBalancer <span class="title">getLoadBalancer</span><span class="params">(String zone)</span> </span>&#123;</span><br><span class="line">    zone = zone.toLowerCase();</span><br><span class="line">    BaseLoadBalancer loadBalancer = balancers.get(zone);</span><br><span class="line">    <span class="keyword">if</span> (loadBalancer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">// We need to create rule object for load balancer for each zone</span></span><br><span class="line">    	IRule rule = cloneRule(<span class="keyword">this</span>.getRule());</span><br><span class="line">        loadBalancer = <span class="keyword">new</span> BaseLoadBalancer(<span class="keyword">this</span>.getName() + <span class="string">"_"</span> + zone, rule, <span class="keyword">this</span>.getLoadBalancerStats());</span><br><span class="line">        BaseLoadBalancer prev = balancers.putIfAbsent(zone, loadBalancer);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	loadBalancer = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> loadBalancer;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法也做了3件事：</p>
<ol>
<li>调用父类 DynamicServerListLoadBalancer 的 setServerListForZones 方法，记录一下参数 Map 里拥有的 Zone</li>
<li>对每个 Zone 都初始化一个<code>BaseLoadBalancer</code>对象，然后把这个 Zone 内的节点列表赋值给这个 BaseLoadBalancer 的 allServerList 和 upServerList</li>
<li>检查成员 balancers 内是不是有过期的 Zone 信息，即参数 Map 里已经没有这个 Zone 了但 balancers 里还有，把过期的 Zone 对应的 BaseLoadBalancer 的服务列表置为空</li>
</ol>
<p>对每个 Zone 初始化 BaseLoadBalancer 对象时，初始化的这个 BaseLoadBalancer 对象的成员 IRule = ZoneAvoidanceRule（因为是从 ZoneAwareLoadBalancer 的 IRule 克隆过来的），属性 name = 服务名 + “_” + zone名。Zone 和 BaseLoadBalancer 的对应关系保存在成员<code>ConcurrentHashMap&lt;String, BaseLoadBalancer&gt; balancers</code>内。</p>
<hr>
<p>服务列表的更新过程说完了，现在我们简单提一下何时更新服务列表？</p>
<p>DynamicServerListLoadBalancer 还有这样两个成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ServerListUpdater.UpdateAction updateAction = <span class="keyword">new</span> ServerListUpdater.UpdateAction() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        updateListOfServers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> ServerListUpdater serverListUpdater;</span><br></pre></td></tr></table></figure>

<p>成员<code>serverListUpdater</code>是 PollingServerListUpdater 类，在 RibbonClientConfiguration 中配置的。这是个定时任务，它<strong>周期性（默认30秒）执行</strong><code>ServerListUpdater.UpdateAction.doUpdate()</code>方法。如上，这个 doUpdate 方法就是执行 DynamicServerListLoadBalancer.updateListOfServers() 方法。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>BaseLoadBalancer 定义了保存服务节点列表的成员：allServerList 和 upServerList。</p>
<p>DynamicServerListLoadBalancer 借助成员 ServerListUpdater，周期性（默认30秒）调用 updateListOfServers 方法更新服务节点列表。</p>
<p>在 updateListOfServers 方法中，DynamicServerListLoadBalancer 再借助成员 serverListImpl = DomainExtractingServerList 从注册中心获取被调方节点列表，优先获取同个 Region 内的节点列表，每个节点都是 UP 状态，且带有 Zone 信息。</p>
<p>接着，DynamicServerListLoadBalancer 再调用成员 filter = ZonePreferenceServerListFilter 过滤出和调用方 Zone 一致的被调方节点。若被调方在这个 Zone 内没有节点，则 filter 返回的还是没过滤的、分布在其他多个 Zone 的节点列表。</p>
<p>最后，过滤完的节点列表更新到 allServerList 和 upServerList。ZoneAwareLoadBalancer 还会根据节点所在的 Zone 对节点进行分类。每个 Zone 对应一个 BaseLoadBalancer 对象（若没有会自动初始化），这个 BaseLoadBalancer 对象保存的节点列表就是仅限于这个 Zone 内的节点，成员 IRule 也是 ZoneAvoidanceRule。</p>
<hr>
<p><strong>关于“优先调用同一个 Zone 内的节点”：</strong></p>
<p>前面说到，调用方会优先调用在同一个 Zone 内的被调方节点，原因就是待挑选的服务节点列表经过 ZonePreferenceServerListFilter 过滤后只剩下了在同一个 Zone 内的节点。调用 ZoneAwareLoadBalancer.chooseServer() 时，因为列表中的节点只存在于一个 Zone，所以使用的 IRule 就是 ZoneAwareLoadBalancer 的成员，待选的服务列表也是 ZoneAwareLoadBalancer 维护的 allServerList，内容是这同一个 Zone 内的被调方节点。</p>
<p>如果被调方在这个 Zone 内没有节点，只在另一个 Zone 内有节点，则 ZonePreferenceServerListFilter 不会做任何过滤，ZoneAwareLoadBalancer 得到的还是在另一个 Zone 内的节点列表。调用 ZoneAwareLoadBalancer.chooseServer() 时，因为列表中的节点只存在于一个 Zone，所以挑选的逻辑还是和上面一样。</p>
<p>如果被调方在这个 Zone 内没有节点，在其他多个 Zone 内有节点，则 ZonePreferenceServerListFilter 不会做任何过滤，ZoneAwareLoadBalancer 把每个 Zone 下的节点列表整理出来，保存在每个 Zone 对应的 BaseLoadBalancer 对象中。调用 ZoneAwareLoadBalancer.chooseServer() 时，因为列表中的节点分布在多个 Zone，就先选出一个 Zone，取这个 Zone 对应的 BaseLoadBalancer 对象，再调用这个 BaseLoadBalancer 的 chooseServer 方法选出服务节点。自然而然，方法内使用的 IRule 就是 BaseLoadBalancer 的成员，待选的服务列表也是这个 BaseLoadBalancer 的 allServerList，内容是仅限于这个 Zone 内的节点。</p>
<p>不管是用谁的 IRule，这个 IRule 都是 ZoneAvoidanceRule，待选的服务列表都是在一个 Zone 内的节点。只要这个 Zone 在这调用过程中保持正常不故障，ZoneAvoidanceRule 就是用“线性轮询”的方式，从这个 Zone 的节点列表内选一个节点，结束。 </p>
<h1 id="组件的自动配置"><a href="#组件的自动配置" class="headerlink" title="组件的自动配置"></a>组件的自动配置</h1><p>负载均衡中的重点已经说完了，这里是一些旁支末节，可以不用理会~我写下来是因为这部分源码中有一些实现方式蛮新鲜的，所以特地记录一下。</p>
<p>在“前言”部分已经列出了负载均衡的过程，其中前两点是：</p>
<ol>
<li>RestTemplate 发送的请求被 LoadBalancerInterceptor 拦截，LoadBalancerInterceptor 调用 LoadBalancerClient.execute() 方法处理请求。LoadBalancerClient 默认使用的实现类是 RibbonLoadBalancerClient</li>
<li>在 RibbonLoadBalancerClient.execute() 方法中，用 serviceId（被调方的服务名）获取一个 ILoadBalancer 对象，再调用 ILoadBalancer.chooseServer() 方法</li>
</ol>
<p>除了 ILoadBalancer 和 IRule，整个过程用到的组件还有拦截请求的 LoadBalancerInterceptor，具体处理请求的 RibbonLoadBalancerClient，这部分内容就介绍下这几个组件是怎么配置的。</p>
<h2 id="LoadBalancerInterceptor的配置"><a href="#LoadBalancerInterceptor的配置" class="headerlink" title="LoadBalancerInterceptor的配置"></a>LoadBalancerInterceptor的配置</h2><p>在配置类<code>LoadBalancerAutoConfiguration</code>中，首先扫描被<code>@LoadBalanced</code>修饰的 RestTemplate Bean，然后为每个 RestTemplate Bean 添加拦截器<code>LoadBalancerInterceptor</code>。添加了拦截器后，RestTemplate 发出的每个请求都会被拦截。</p>
<p>在这个配置类之前还会加载另一个配置类<code>RibbonAutoConfiguration</code>，注入<code>LoadBalancerClient</code>Bean（实现类是<code>RibbonLoadBalancerClient</code>），这个 Bean 成为了 LoadBalancerInterceptor 的成员，最终处理请求的方法就是<code>LoadBalancerClient.execute()</code>方法。</p>
<p>LoadBalancerInterceptor 配置源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RestTemplate<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnBean</span>(<span class="title">LoadBalancerClient</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">LoadBalancerRetryProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LoadBalancerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">	<span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SmartInitializingSingleton <span class="title">loadBalancedRestTemplateInitializerDeprecated</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> () -&gt; restTemplateCustomizers.ifAvailable(customizers -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (RestTemplate restTemplate : LoadBalancerAutoConfiguration.<span class="keyword">this</span>.restTemplates) &#123;</span><br><span class="line">                <span class="keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">                    customizer.customize(restTemplate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.springframework.retry.support.RetryTemplate"</span>)</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">				LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">				LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> restTemplate -&gt; &#123;</span><br><span class="line">                List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">                        restTemplate.getInterceptors());</span><br><span class="line">                list.add(loadBalancerInterceptor);</span><br><span class="line">                restTemplate.setInterceptors(list); <span class="comment">// restTemplate添加拦截器</span></span><br><span class="line">            &#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分是我第一次看到<code>@Autowired</code>的这个用法：在 @Autowired 注解上加另一个注解，就会扫描出所有加了这个注解的同类的 Bean 放到 List 内。</p>
<h2 id="ILoadBalancer的配置"><a href="#ILoadBalancer的配置" class="headerlink" title="ILoadBalancer的配置"></a>ILoadBalancer的配置</h2><p>请求被拦截后，由 RibbonLoadBalancerClient.execute() 方法处理请求，首先根据 serviceId（服务名）取 ILoadBalancer 对象，负责这件事的是 RibbonLoadBalancerClient 的成员<code>SpringClientFactory</code>。</p>
<p>SpringClientFactory 根据 serviceId 取 IloadBalancer，实际上是根据 serviceId 取 IoC 容器，再从 IoC 容器中取 IloadBalancer Bean。serviceId 和 IoC 容器的关系保存在成员<code>Map&lt;String, AnnotationConfigApplicationContext&gt; contexts</code>中。如果 serviceId 还没有对应的 IoC 容器，就先创建一个以便下次取用。因此，<strong>ILoadBalancer 和 IRule 的初始化不是在系统启动时，而是在第一次调用某个服务的时候</strong>。</p>
<p>一个分布式应用一般要调用多个服务，按照这个设计，调用方要为每个被调服务创建一个 IoC 容器，这个容器中的 ILoadBalancer、IRule 等都是调用这个服务专用的。这种做法比起用同一个 ILoadBalancer Bean 调所有服务，可以更好的维护每个服务的节点列表，使它们之间互不干扰。</p>
<p>SpringClientFactory 中创建容器的方法源码（方法参数 name 就是 serviceId）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name)</span><br><span class="line">				.getConfiguration()) &#123;</span><br><span class="line">			context.register(configuration);<span class="comment">// 1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">"default."</span>)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">				context.register(configuration); <span class="comment">// 2</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	context.register(PropertyPlaceholderAutoConfiguration<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">			<span class="title">this</span>.<span class="title">defaultConfigType</span>)</span>; <span class="comment">// 3</span></span><br><span class="line">	context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(</span><br><span class="line">			<span class="keyword">this</span>.propertySourceName,</span><br><span class="line">			Collections.&lt;String, Object&gt; singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">		context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">	&#125;</span><br><span class="line">	context.setDisplayName(generateDisplayName(name));</span><br><span class="line">	context.refresh();</span><br><span class="line">	<span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，创建的容器注册了4个东西：</p>
<ol>
<li>Map&lt;String, C&gt; configurations 中 key=serviceId 的 value 的 getConfiguration() 返回值</li>
<li>Map&lt;String, C&gt; configurations 中 以”default.”开头的 key 对应的 value 的 getConfiguration() 返回值</li>
<li>PropertyPlaceholderAutoConfiguration.class</li>
<li>defaultConfigType</li>
</ol>
<p>其中，第三个不用关注，第四个 defaultConfigType =<code>RibbonClientConfiguration.class</code>，这个属性是在构造方法<code>SpringClientFactory()</code>中设置。</p>
<p>接下来研究下 SpringClientFactory 的成员<code>Map&lt;String, C&gt; configurations</code>的内容是什么。</p>
<p>它的来源在<code>RibbonAutoConfiguration</code>配置类，对，就是注入了 RibbonLoadBalancerClient 的那个类。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">	<span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SpringClientFactory <span class="title">springClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">		factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line">		<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，Map&lt;String, C&gt; configurations 的来源是所有<code>RibbonClientSpecification</code>Bean。那么，RibbonClientSpecification Bean 又在哪注册呢？它又包含了什么内容？</p>
<p>在配置类<code>RibbonEurekaAutoConfiguration</code>中，通过<code>@RibbonClients</code>注解，import 另一个类<code>RibbonClientConfigurationRegistrar</code>。</p>
<p>RibbonEurekaAutoConfiguration 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="meta">@RibbonClients</span>(defaultConfiguration = EurekaRibbonClientConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RibbonEurekaAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RibbonClients 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="meta">@Import</span>(RibbonClientConfigurationRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">RibbonClients</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	RibbonClient[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	Class&lt;?&gt;[] defaultConfiguration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RibbonClientConfigurationRegistrar 继承自<code>ImportBeanDefinitionRegistrar</code>，它是和<code>@Import</code>注解配合的一个类：使用<code>@Import</code>，如果括号中的类是<code>ImportBeanDefinitionRegistrar</code>接口的实现类，则会调用接口方法<code>registerBeanDefinitions</code>，在这个方法里可以注入 Bean。</p>
<p>在 RibbonClientConfigurationRegistrar 类中，调用了 registerBeanDefinitions 方法后，如果 RibbonClients 的 defaultConfiguration 属性有值，就会进入<code>registerClientConfiguration</code>方法（方法源码如下），在这个方法内创建了 RibbonClientSpecification Bean并注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">		Object name, Object configuration)</span> </span>&#123;</span><br><span class="line">	BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">			.genericBeanDefinition(RibbonClientSpecification<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			</span><br><span class="line">	builder.addConstructorArgValue(name); <span class="comment">// "default." + @RibbonClients注解所在类的全限定名</span></span><br><span class="line">	</span><br><span class="line">	builder.addConstructorArgValue(configuration); <span class="comment">// @RibbonClients的defaultConfiguration属性</span></span><br><span class="line">	</span><br><span class="line">	registry.registerBeanDefinition(name + <span class="string">".RibbonClientSpecification"</span>,</span><br><span class="line">			builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，因为这个 @RibbonClients 注解是标在<code>RibbonEurekaAutoConfiguration</code>类上，结合 RibbonEurekaAutoConfiguration 类的源码，这个 RibbonClientSpecification 对象的 name = “default.org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration”，configuration = EurekaRibbonClientConfiguration.class。</p>
<p>然后，这个 RibbonClientSpecification 对象被扫描到这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>


<p>再然后，SpringClientFactory 把这个 List<RibbonClientSpecification> configurations 转为自己的成员<code>Map&lt;String, C&gt; configurations</code>，key = RibbonClientSpecification 对象的 name 属性，value = RibbonClientSpecification 对象，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurations</span><span class="params">(List&lt;C&gt; configurations)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (C client : configurations) &#123;</span><br><span class="line">		<span class="keyword">this</span>.configurations.put(client.getName(), client);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>所以，SpringClientFactory 创建容器时注册的4个东西分别是：</p>
<ol>
<li>Map&lt;String, C&gt; configurations 中 key=serviceId 的 value 的 getConfiguration() 返回值 – 没有这个 key </li>
<li>Map&lt;String, C&gt; configurations 中 以”default.”开头的 key 对应的 value 的 getConfiguration() 返回值 – RibbonClientSpecification.getConfiguration() 返回值 = EurekaRibbonClientConfiguration.class</li>
<li>PropertyPlaceholderAutoConfiguration.class</li>
<li>defaultConfigType – RibbonClientConfiguration.class</li>
</ol>
<p>综上，serviceId 对应的 IoC 容器中加载了配置类<code>EurekaRibbonClientConfiguration</code>和<code>RibbonClientConfiguration</code>。其中，RibbonClientConfiguration 注入了 ILoadBalancer = ZoneAwareLoadBalancer、IRule = ZoneAvoidanceRule。</p>
<hr>
<p>补充介绍一下 ZoneAwareLoadBalancer 的初始化过程。</p>
<p>配置 ZoneAwareLoadBalancer 的源码（在 RibbonClientConfiguration 类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">		ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">		IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer<span class="class">.<span class="keyword">class</span>, <span class="title">name</span>)) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer<span class="class">.<span class="keyword">class</span>, <span class="title">config</span>, <span class="title">name</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">			serverListFilter, serverListUpdater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ZoneAwareLoadBalancer 初始化时，先调用父类 DynamicServerListLoadBalancer 初始化， DynamicServerListLoadBalancer 再调用父类 BaseLoadBalancer 初始化。当前 BaseLoadBalancer 的 name = serviceId。</p>
<p>DynamicServerListLoadBalancer 从父类 BaseLoadBalancer 初始化返回后，再调用 restOfInit 方法，这个方法又会调用到 updateListOfServers 方法。对，这个就是 DynamicServerListLoadBalancer 更新服务列表的方法。所以，ZoneAwareLoadBalancer 初始化时，也把它的服务列表初始化好了，它的成员<code>ConcurrentHashMap&lt;String, BaseLoadBalancer&gt; balancers</code>———— Zone 和 BaseLoadBalancer 的对应关系也初始化好了。</p>
<p>在没有配置多个 Zone 的一般项目中，如果你在这个初始化过程里调试 BaseLoadBalancer 的构造方法，你就会发现 BaseLoadBalancer 的构造方法被调用了两次，第一次调用是因为 ZoneAwareLoadBalancer 初始化要调用父类构造方法，name 属性为 serviceId；第二次调用是因为 ZoneAwareLoadBalancer 要创建 defaultZone 对应的 BaseLoadBalancer 对象，name 属性为 serviceId + “_defaultzone”。</p>
<h2 id="配置类的加载顺序"><a href="#配置类的加载顺序" class="headerlink" title="配置类的加载顺序"></a>配置类的加载顺序</h2><p>系统启动时，根据<code>spring.factories</code>文件加载了配置类<code>RibbonAutoConfiguration</code>，其中注入了 RibbonLoadBalancerClient 。</p>
<p>RibbonAutoConfiguration 注入了 RibbonLoadBalancerClient Bean 后，加载<code>LoadBalancerAutoConfiguration</code>，这个类为 RestTemplate 设置了 LoadBalancerInterceptor。</p>
<p>RibbonAutoConfiguration 加载完后，加载<code>RibbonEurekaAutoConfiguration</code>，通过<code>@RibbonClients</code>注解，import RibbonClientConfigurationRegistrar 类，这个类注入了 RibbonClientSpecification ，这个对象中包含配置类<code>EurekaRibbonClientConfiguration</code>的 class 信息。</p>
<p>系统中第一次使用 RestTemplate 调用服务时，为这个服务初始化一个 IoC 容器，IoC 容器加载的配置类包括<code>EurekaRibbonClientConfiguration</code>和<code>RibbonClientConfiguration</code>。其中，RibbonClientConfiguration 注入了 ILoadBalancer = ZoneAwareLoadBalancer、IRule = ZoneAvoidanceRule。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/07/18/redis-cache/"><i class="fa fa-chevron-left">  </i><span>Redis缓存问题</span></a></div><div class="next-post pull-right"><a href="/2020/12/05/git-ssh/"><span>Git使用SSH方式</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2022 By yunnight</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>