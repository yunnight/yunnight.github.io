<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="SpringBoot AOP 实践与原理"><meta name="keywords" content="原理描述,实践"><meta name="author" content="yunnight"><meta name="copyright" content="yunnight"><title>SpringBoot AOP 实践与原理 | yunnight</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代码实践"><span class="toc-number">2.</span> <span class="toc-text">代码实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#添加依赖包"><span class="toc-number">2.1.</span> <span class="toc-text">添加依赖包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建切面类"><span class="toc-number">2.2.</span> <span class="toc-text">创建切面类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义切入点"><span class="toc-number">2.3.</span> <span class="toc-text">定义切入点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用execution表达式定义切入点"><span class="toc-number">2.3.1.</span> <span class="toc-text">用execution表达式定义切入点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用自定义注解定义切入点"><span class="toc-number">2.3.2.</span> <span class="toc-text">用自定义注解定义切入点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#根据业务逻辑编写Advice方法"><span class="toc-number">2.4.</span> <span class="toc-text">根据业务逻辑编写Advice方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Before"><span class="toc-number">2.4.1.</span> <span class="toc-text">Before</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#After"><span class="toc-number">2.4.2.</span> <span class="toc-text">After</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AfterReturning"><span class="toc-number">2.4.3.</span> <span class="toc-text">AfterReturning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AfterThrowing"><span class="toc-number">2.4.4.</span> <span class="toc-text">AfterThrowing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Around"><span class="toc-number">2.4.5.</span> <span class="toc-text">Around</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AOP原理"><span class="toc-number">3.</span> <span class="toc-text">AOP原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#静态代理"><span class="toc-number">3.1.</span> <span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态代理"><span class="toc-number">3.2.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP的动态代理"><span class="toc-number">3.3.</span> <span class="toc-text">AOP的动态代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring中已实现的AOP"><span class="toc-number">4.</span> <span class="toc-text">Spring中已实现的AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ControllerAdvice"><span class="toc-number">4.1.</span> <span class="toc-text">@ControllerAdvice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#404异常处理"><span class="toc-number">4.1.1.</span> <span class="toc-text">404异常处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transactional"><span class="toc-number">4.2.</span> <span class="toc-text">@Transactional</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Transactional只能用在public方法上"><span class="toc-number">4.2.1.</span> <span class="toc-text">@Transactional只能用在public方法上</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transactional的rollbackFor属性"><span class="toc-number">4.2.2.</span> <span class="toc-text">@Transactional的rollbackFor属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自调用问题"><span class="toc-number">4.2.3.</span> <span class="toc-text">自调用问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-AOP和AspectJ的关系"><span class="toc-number">5.</span> <span class="toc-text">Spring AOP和AspectJ的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK和CGLIB"><span class="toc-number">6.</span> <span class="toc-text">JDK和CGLIB</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#性能问题"><span class="toc-number">6.1.</span> <span class="toc-text">性能问题</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/yunnight/pics/master/blog_avatar.jpg"></div><div class="author-info__name text-center">yunnight</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">28</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">yunnight</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">SpringBoot AOP 实践与原理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Spring/"> Spring</a></div><div class="article-container" id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客先从AOP的代码编写讲起，接着介绍AOP的实现原理，其中包括动态代理的概念，最后介绍Spring中可以直接用的AOP注解。</p>
<h1 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h1><h2 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="创建切面类"><a href="#创建切面类" class="headerlink" title="创建切面类"></a>创建切面类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//声明这是一个组件</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//声明这是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义切入点"><a href="#定义切入点" class="headerlink" title="定义切入点"></a>定义切入点</h2><p>切入点就是你要在哪个包下的哪个类的哪个方法执行切面逻辑，或者说指定切入哪里。<strong>Spring AOP的切入点只能是方法。</strong><br>可以在一个切面类中定义多个切入点，再给每个切入点指定不同的Advice方法（Advice方法介绍见下一节）。<br>定义切入点有两种方式：</p>
<ol>
<li>用execution表达式定义切入点</li>
<li>用自定义注解定义切入点</li>
</ol>
<h3 id="用execution表达式定义切入点"><a href="#用execution表达式定义切入点" class="headerlink" title="用execution表达式定义切入点"></a>用execution表达式定义切入点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.sample.service.impl..*.*(..)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例表示在com.sample.service.impl包（含子包）下的所有类的所有方法切入。下面把这个示例拆解看看execution表达式的格式。</p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">第一个”*”符号</td>
<td align="left">表示返回值的类型任意</td>
</tr>
<tr>
<td align="left">com.sample.service.impl</td>
<td align="left">要切入的类所在包名</td>
</tr>
<tr>
<td align="left">包名后面的”..”</td>
<td align="left">表示当前包及子包</td>
</tr>
<tr>
<td align="left">第二个”*“符号</td>
<td align="left">表示类名，*即任意类，也可指定具体的类，或带前后缀的类，如 *Service</td>
</tr>
<tr>
<td align="left">.*(..)</td>
<td align="left">表示任何方法名，括号表示参数，两个点表示任何参数类型</td>
</tr>
</tbody></table>
<p>如何使用这个切入点？示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)<span class="comment">// 这个注解以及它所修饰的方法的介绍见下一节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要同时指定<strong>多个切入点</strong>，用这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut1() || pointcut2()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="用自定义注解定义切入点"><a href="#用自定义注解定义切入点" class="headerlink" title="用自定义注解定义切入点"></a>用自定义注解定义切入点</h3><p>假设已有自定义注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME )</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义切入点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.example.demo.aop.Log)"</span>) <span class="comment">// 自定义注解的限定类名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例表示切入所有加了<code>@Log</code>属性的方法，比如下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Log</span>(<span class="string">"添加用户操作"</span>)</span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/user/add"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"add"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这个切入点的方法和用“execution表达式”定义的切入点没有区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)<span class="comment">// 这个注解以及它所修饰的方法的介绍见下一节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这只是“自定义注解”定义的切入点的其中一种使用方式，这种使用方式的一个缺点是不能访问自定义注解<code>@Log</code>的value属性。<br>另一种使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(log)"</span>) <span class="comment">// 括号里的名字和注解参数名必须相同</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint, Log log)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 方法逻辑...</span></span><br><span class="line">     System.out.println(log.value()); <span class="comment">// 可以访问注解属性值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这种使用方式的区别就是，切入点直接写在<code>@Before</code>注解中，不需要再用pointcut()方法定义切入点</p>
<p>和execution表达式相比，用自定义注解定义切入点，可以灵活安排切入的方法（想切哪里注解就加在哪里），且通过自定义注解的属性，在切面类中也能了解到被切方法的业务逻辑，若要在切面类中统一打印被切方法的日志，这点很好用。</p>
<h2 id="根据业务逻辑编写Advice方法"><a href="#根据业务逻辑编写Advice方法" class="headerlink" title="根据业务逻辑编写Advice方法"></a>根据业务逻辑编写Advice方法</h2><p>Advice，有翻译为“增强处理”，也有翻译为“通知”，本质含义就是要执行的切面逻辑，如要在每个方法开始前打印入参日志，就可以编写Before类型的Advice方法，如要在每个方法抛出异常后统一处理，就可以编写AfterThrowing类型的Advice方法。Advice一共有五种类型：</p>
<ul>
<li>Before</li>
<li>After</li>
<li>AfterReturning</li>
<li>AfterThrowing</li>
<li>Around</li>
</ul>
<p>这些类型的共同特点：</p>
<ul>
<li>所有类型的注解都有两个属性：value、argNames。value属性用于指定切入点，argNames属性可以用来访问目标方法的入参</li>
<li>除<code>Around</code>之外，其他四种类型的方法的连接点参数都只能是JoinPoint，不能是ProceedingJoinPoint（ProceedingJoinPoint是JoinPoint的子类）</li>
<li>只有<code>Around</code>方法能改变目标方法的入参和返回值</li>
</ul>
<p>下面分别介绍这五种类型的特点和使用方法。</p>
<h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><p>在目标方法执行前织入，不能访问目标方法的返回值，可选参数有JoinPoint。<br><code>@Before</code>注解属性：value、argNames</p>
<blockquote>
<p>JoinPoint简单介绍：<br>JoinPoint参数不必须，但需要时必须作为第一个参数！<br>常用方法有：<br>Object[] getArgs：返回目标方法的参数<br>Signature getSignature：返回目标方法的签名(含方法名和参数表)</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"============before============"</span>);</span><br><span class="line">    System.out.println(<span class="string">"目标方法名为:"</span> + joinPoint.getSignature().getName()); <span class="comment">// 打印方法名add</span></span><br><span class="line">    System.out.println(<span class="string">"目标方法所属类的类名:"</span> + joinPoint.getSignature().getDeclaringTypeName());<span class="comment">// 打印全限定类名com.example.demo.controller.UserController</span></span><br><span class="line">    <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"第"</span> + (i+<span class="number">1</span>) + <span class="string">"个参数为:"</span> + args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><p>在目标方法结束后织入，不管目标方法如何结束（正常还是异常），它都会被织入，可选参数有JoinPoint。<br><code>@After</code>注解和<code>@Before</code>注解属性相同：value、argNames<br>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"============after============"</span>);</span><br><span class="line">    <span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AfterReturning"><a href="#AfterReturning" class="headerlink" title="AfterReturning"></a>AfterReturning</h3><p>在目标方法正常完成后被织入，抛出异常了不织入，可选参数有JoinPoint和Object（目标方法的返回值）。<br><code>@AfterReturning</code>注解除了value、argNames这两个属性外，还有一个属性：</p>
<ul>
<li>returning：指定一个返回值形参名，可以通过该形参名来访问目标方法的返回值，但不可修改目标方法的返回值</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(pointcut = <span class="string">"pointcut()"</span>, returning = <span class="string">"returnObject"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(JoinPoint joinPoint, Object returnObject)</span> </span>&#123; <span class="comment">// 返回值的形参名与注解中的保持一致</span></span><br><span class="line">    System.out.println(<span class="string">"============afterReturning============"</span>);</span><br><span class="line">    <span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line">    <span class="comment">// 访问目标方法的返回值</span></span><br><span class="line">    System.out.println(<span class="string">"返回值："</span> + returnObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="AfterThrowing"><a href="#AfterThrowing" class="headerlink" title="AfterThrowing"></a>AfterThrowing</h3><p>在目标方法抛出异常时织入，正常完成不织入，可选参数有JoinPoint和Throwable（目标方法抛出的异常）。<br><code>@AfterThrowing</code>注解除了value、argNames这两个属性外，还有一个属性：</p>
<ul>
<li>throwing：指定一个异常形参名，形参可用于访问目标方法抛出的异常</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(throwing = <span class="string">"e"</span>, pointcut = <span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable e)</span> </span>&#123; <span class="comment">// 异常的形参名与注解中的保持一致</span></span><br><span class="line">	System.out.println(<span class="string">"============afterThrowing============"</span>);</span><br><span class="line">	<span class="comment">// joinPoint参数的使用和Before一样，不再赘述</span></span><br><span class="line">	<span class="comment">// 打印异常</span></span><br><span class="line">	System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这个AfterThrowing只能用在打印异常信息，不能对抛出的异常做更多处理，也不能针对异常来改变目标方法的返回值。<br>想要根据异常信息修改目标方法返回值，只能用下面讲的Around。</p>
<h3 id="Around"><a href="#Around" class="headerlink" title="Around"></a>Around</h3><ul>
<li>可以在执行目标方法前织入，也可以在执行后织入</li>
<li>可以决定目标方法在什么时候执行，如何执行，可以完全阻止目标方法的执行</li>
<li>可以修改目标方法的参数值，也可以修改目标方法的返回值</li>
<li>至少包含一个参数，且第一个参数必须是ProceedingJoinPoint</li>
<li>在方法体内，调用ProceedingJoinPoint的proceed()方法才会执行目标方法。如果方法体内没有调用这个proceed()方法，则目标方法不会执行</li>
<li>最后必须把获得的目标方法的返回值，作为@Around方法的返回值return回去(因为如果无返回值的话，将不会继续执行目标方法)</li>
</ul>
<p><code>@Around</code>注解属性：value、argNames</p>
<p>第一个示例，没修改目标方法入参：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">          <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">          Object[] args = joinPoint.getArgs();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">              System.out.println(<span class="string">"第"</span> + (i+<span class="number">1</span>) + <span class="string">"个参数为:"</span> + args[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 返回值</span></span><br><span class="line">          Object re = joinPoint.proceed();</span><br><span class="line">          <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第二个示例，修改了目标方法入参（入参为基本类型和String）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">        <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 修改参数值</span></span><br><span class="line">            args[i] += <span class="string">"updated"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        Object re = joinPoint.proceed(args); <span class="comment">// 这里要把修改后的args作为proceed方法的参数</span></span><br><span class="line">        <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三个示例，修改了目标方法入参（入参为对象）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	String result = <span class="string">"success"</span>; <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">        <span class="comment">//获取传入目标方法的参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        Object param = args[<span class="number">0</span>];</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">if</span>(param <span class="keyword">instanceof</span> Person)</span><br><span class="line">        	person = (Person) param;</span><br><span class="line">        person.setAddress(<span class="string">"address"</span>); <span class="comment">// 修改参数对象属性</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        Object re = joinPoint.proceed(); <span class="comment">// 这里不用再把修改后的args作为proceed方法的参数</span></span><br><span class="line">        <span class="keyword">if</span>(re <span class="keyword">instanceof</span> String) result = (String) re;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        result = <span class="string">"fail"</span>; <span class="comment">// 返回fail响应</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，关于Around中的异常捕获：</p>
<ol>
<li>只有从目标方法中抛出的异常才会被捕获，若目标方法内自己try-catch异常了没有抛出，就不会触发Around的异常捕获</li>
<li>Around中处理异常，返回的响应类型必须和目标方法声明的一致，即必须是目标方法的返回类及其子类，否则会出现强制转换报错</li>
</ol>
<h1 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h1><p>AOP的全称是Aspect Oriented Programming，面向切面编程，它是通过动态代理技术，将Aspect方法中的逻辑完整织入到切入点中。下面开始先介绍静态代理（即设计模式中的代理模式），再介绍动态代理，最后再说说Spring是怎么用动态代理实现AOP的。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在设计模式中，常用到代理模式，它一般由一个接口和这个接口的两个实现类组成。<br>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"message: "</span> + msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProxy</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Service service; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServiceProxy</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.service = service;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		doBefore();</span><br><span class="line">		<span class="keyword">this</span>.service.printMessage(msg);</span><br><span class="line">		doAfter();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行代理方法前的处理（前置处理）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"========proxy start========"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行完代理方法后的处理（后置处理）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"========proxy end========"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用代理类是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">		ServiceProxy proxy = <span class="keyword">new</span> ServiceProxy(service);</span><br><span class="line">		proxy.printMessage(<span class="string">"hello"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，静态代理需要我们自己编写代理类ServiceProxy，在它的printMessage方法中加上前置处理和后置处理。而动态代理，就不用我们自己写代理类，就能把我们指定的前置后置处理方法加到被代理方法的前后流程中。下面介绍动态代理的实现。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理，简单地说，就是不用自己写代理类，而是在<strong>运行时</strong>自动生成代理类和代理类对象。<br>接口Service和实现类ServiceImpl代码同上，不再赘述。</p>
<p>动态代理类：<br>作用：在运行时生成被代理类对象，规定执行被代理对象的目标方法的流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Object _obj = <span class="keyword">null</span>; <span class="comment">// 被代理对象</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object _obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>._obj = _obj;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span>   proxy 代理对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span>   method 被代理对象的目标方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span>   args 被代理对象的目标方法的参数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>  被代理对象的目标方法的执行结果</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// 此处可以编写前置处理...</span></span><br><span class="line">		<span class="keyword">return</span> method.invoke(_obj, args); <span class="comment">// 反射执行被代理对象的目标方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用动态代理类是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">		DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(service); <span class="comment">// 放入被代理对象</span></span><br><span class="line">		<span class="comment">// 使用JDK中的Proxy类生成Service类的代理对象</span></span><br><span class="line">		Service proxy = (Service) Proxy.newProxyInstance(service.getClass().getClassLoader(),</span><br><span class="line">				service.getClass().getInterfaces(), dynamicProxy); </span><br><span class="line">		proxy.printMessage(<span class="string">"hello"</span>); <span class="comment">// 这一步其实就是执行dynamicProxy.invoke方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码很简单地实现了动态代理：自己不用写Service类的代理类，运行时才生成Service类的代理类和代理对象。</p>
<p>当然AOP的实现没有这么简单，它还需要把切面类织入到切入点中。</p>
<h2 id="AOP的动态代理"><a href="#AOP的动态代理" class="headerlink" title="AOP的动态代理"></a>AOP的动态代理</h2><p>以下代码可以简单实现AOP逻辑。<br>接口Service和实现类ServiceImpl代码同上，不再赘述。</p>
<p>切面接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aspect</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">useAround</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切面类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectImpl</span> <span class="keyword">implements</span> <span class="title">Aspect</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"========doBefore========"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"========doAfter========"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"========doAfterReturning========"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"========doAfterThrowing========"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"========doAround Start========"</span>);</span><br><span class="line">		Object result = method.invoke(target, args);</span><br><span class="line">		System.out.println(<span class="string">"========doAround End========"</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">useAround</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Object _obj = <span class="keyword">null</span>; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Aspect _aspect; <span class="comment">// 切面类</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object _obj, Aspect _aspect)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>._obj = _obj;</span><br><span class="line">		<span class="keyword">this</span>._aspect = _aspect;</span><br><span class="line">		Object proxy = Proxy.newProxyInstance(_obj.getClass().getClassLoader(), _obj.getClass().getInterfaces(), <span class="keyword">this</span>); <span class="comment">// 代理对象</span></span><br><span class="line">		<span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">	 *            代理对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">	 *            被代理对象的目标方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 *            被代理对象的目标方法的参数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 被代理对象的目标方法的执行结果</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">		Object result = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			_aspect.doBefore();</span><br><span class="line">			<span class="keyword">if</span> (_aspect.useAround()) &#123;</span><br><span class="line">				result = _aspect.doAround(_obj, method, args);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				result = method.invoke(_obj, args);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			hasException = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		_aspect.doAfter();</span><br><span class="line">		<span class="keyword">if</span> (hasException) &#123;</span><br><span class="line">			_aspect.doAfterThrowing();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			_aspect.doAfterReturning();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用动态代理类是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Service service = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">		DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy();</span><br><span class="line">		Service proxy = (Service) dynamicProxy.getProxy(service, <span class="keyword">new</span> AspectImpl());</span><br><span class="line">		proxy.printMessage(<span class="string">"hello"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doBefore&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAround Start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">message: hello</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAround End&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAfter&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;doAfterReturning&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<p>可以看出，以上代码成功把切面类AspectImpl的逻辑织入到了被代理对象的目标方法中。因此，Spring AOP的原理就是，Spring中有一个类似于动态代理类DynamicProxy的类，帮我们把切面类织入到切入点了。</p>
<h1 id="Spring中已实现的AOP"><a href="#Spring中已实现的AOP" class="headerlink" title="Spring中已实现的AOP"></a>Spring中已实现的AOP</h1><p>Spring中有一些已经写好的切面逻辑，可以直接拿来用。</p>
<h2 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h2><p>用<code>@ControllerAdvice</code>注解修饰的类，可以对Controller中用<code>@RequestMapping</code>修饰的方法做切面处理，最常用的是统一处理Controller方法抛出的异常。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@ResponseBody</span> <span class="comment">// 响应体是json格式就必须加这个注解</span></span><br><span class="line">	<span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>) // 指定抛出的异常类型</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">JSONObject</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123; <span class="comment">// 在这个方法中写抛出异常后的处理</span></span><br><span class="line">		System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">		JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">		json.put(<span class="string">"code"</span>, <span class="string">"9999"</span>);</span><br><span class="line">		json.put(<span class="string">"msg"</span>, <span class="string">"System Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> json;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例是指，当Conrtroller方法中抛出异常时，统一返回<strong>{“msg”:”System Error”,”code”:”9999”}</strong>响应体。<br>若需要统一跳到某个页面，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>) // 指定抛出的异常类型</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ModelAndView</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123; <span class="comment">// 在这个方法中写抛出异常后的处理</span></span><br><span class="line">    	System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">//指定错误页面的模板页</span></span><br><span class="line">        mav.setViewName(<span class="string">"error"</span>);</span><br><span class="line">        mav.addObject(<span class="string">"code"</span>, ex.getCode());</span><br><span class="line">        mav.addObject(<span class="string">"msg"</span>, ex.getMsg());</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：当AOP切面和@ControllerAdvice同时存在，且AOP切面里也会统一处理Controller抛出的异常，@ControllerAdvice就不一定会执行。请看下面的例子。<br>AOP切面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(log)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint, Log log)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    	JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">            <span class="comment">// 返回值</span></span><br><span class="line">            Object re = joinPoint.proceed();</span><br><span class="line">            <span class="keyword">if</span>(re <span class="keyword">instanceof</span> JSONObject)</span><br><span class="line">            	result = (JSONObject) re;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            result.put(<span class="string">"code"</span>, <span class="string">"9998"</span>);</span><br><span class="line">            result.put(<span class="string">"msg"</span>, <span class="string">"error"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        	System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@ControllerAdvice的修饰类同上，不再赘述。<br>运行时发现，目标方法抛出异常时，会统一返回<strong>{“msg”:”error”,”code”:”9998”}</strong>，而不会返回@ControllerAdvice中的<strong>{“msg”:”System Error”,”code”:”9999”}</strong>。原因就是AOP中已经处理好异常了。<br>若仍然想把异常交给@ControllerAdvice处理，AOP切面可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAspect</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(log)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint, Log log)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    	JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"============around start============"</span>);</span><br><span class="line">            <span class="comment">// 返回值</span></span><br><span class="line">            Object re = joinPoint.proceed();</span><br><span class="line">            <span class="keyword">if</span>(re <span class="keyword">instanceof</span> JSONObject)</span><br><span class="line">            	result = (JSONObject) re;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// 目标方法抛出异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e; <span class="comment">// 把异常抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        	System.out.println(<span class="string">"============around end============"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，目标方法抛出异常时，会统一返回@ControllerAdvice中的<strong>{“msg”:”System Error”,”code”:”9999”}</strong>。原因就是AOP中把异常抛出了。</p>
<h3 id="404异常处理"><a href="#404异常处理" class="headerlink" title="404异常处理"></a>404异常处理</h3><p>没有什么特殊配置的情况下，Spring Boot遇到404就会自动跳到Spring Boot的error页面。若想要自己处理404异常，可以使用@ControllerAdvice。顺便一提，由于接口不存在，所以404异常肯定不会被AOP切面处理。<br>要处理404异常，必须在配置文件中加上：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出现错误时, 直接抛出异常</span></span><br><span class="line"><span class="attr">spring.mvc.throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 不要为我们工程中的资源文件建立映射</span></span><br><span class="line"><span class="attr">spring.resources.add-mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>这个配置一定要加，否则Spring Boot总是会帮我们处理404异常，而不会进入我们定义的方法中。<br>然后就是在@ControllerAdvice中处理404，示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">JSONObject</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"=============ControllerExceptionHandler==============="</span>);</span><br><span class="line">		JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">		<span class="keyword">if</span>(ex <span class="keyword">instanceof</span> NoHandlerFoundException) &#123; <span class="comment">// 404异常</span></span><br><span class="line">			json.put(<span class="string">"code"</span>, <span class="string">"9997"</span>);</span><br><span class="line">			json.put(<span class="string">"msg"</span>, <span class="string">"No Found"</span>);</span><br><span class="line">			<span class="keyword">return</span> json;</span><br><span class="line">		&#125;</span><br><span class="line">		json.put(<span class="string">"code"</span>, <span class="string">"9999"</span>);</span><br><span class="line">		json.put(<span class="string">"msg"</span>, <span class="string">"System Error"</span>);</span><br><span class="line">		<span class="keyword">return</span> json;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后可以发现，访问不存在的URI时，会统一返回<strong>{“msg”:”No Found”,”code”:”9997”}</strong>。</p>
<h2 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h2><p>这个注解帮你实现了数据库事务逻辑，尤其是事务回滚。<br>举个例子，删除用户时，要把用户关联的权限一起删除，当删除用户成功但删除权限不成功时，应该把删除用户的操作回滚，使得数据一致。<br>服务层示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaintainService</span> <span class="keyword">implements</span> <span class="title">IMaintainService</span></span>&#123;</span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	<span class="keyword">private</span> PersonMapper personMapper;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Transactional</span> <span class="comment">// 事务回滚</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">		personMapper.deleteById(personId);</span><br><span class="line">		personMapper.deletePersonPrivilege(personId);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，当deletePersonPrivilege方法抛出异常时，deleteById方法会被回滚，即数据库中用户和用户权限依然存在，说明回滚成功。另外，回滚成功后，依然会进入AOP切面中的异常捕获。<br>下面介绍<code>@Transactional</code>注解使用的注意点。</p>
<h3 id="Transactional只能用在public方法上"><a href="#Transactional只能用在public方法上" class="headerlink" title="@Transactional只能用在public方法上"></a>@Transactional只能用在public方法上</h3><p>Spring在回滚前会检查方法修饰符是不是public，是才回滚。</p>
<h3 id="Transactional的rollbackFor属性"><a href="#Transactional的rollbackFor属性" class="headerlink" title="@Transactional的rollbackFor属性"></a>@Transactional的<strong>rollbackFor</strong>属性</h3><p>默认情况下，只有抛出Error类，或RuntimeException类及其子类的异常，Spring才会回滚。其他类型的异常不会回滚。<br>若需要在抛出其他异常时回滚，可以指定<strong>rollbackFor</strong>属性，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor=Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">deletePerson</span>(<span class="title">int</span> <span class="title">personId</span>) </span>&#123;</span><br><span class="line">	personMapper.deleteById(personId);</span><br><span class="line">	personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，只有抛出Exception类及其子类的异常，Spring才会回滚。</p>
<h3 id="自调用问题"><a href="#自调用问题" class="headerlink" title="自调用问题"></a>自调用问题</h3><p>上面的示例，<code>@Transactional</code>注解修饰的方法会直接被Controller层接口调用，这种情况下都能回滚成功。但也有一些特殊情况。<br>情况1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">	doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">	personMapper.deleteById(personId);</span><br><span class="line">	personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下，<code>@Transactional</code>不会生效。应改为下面这样才能生效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">	doDeletePerson(personId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">	personMapper.deleteById(personId);</span><br><span class="line">	personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 异步调用</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			doDeletePerson(personId);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">	personMapper.deleteById(personId);</span><br><span class="line">	personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 异步调用</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			doDeletePerson(personId);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDeletePerson</span><span class="params">(<span class="keyword">int</span> personId)</span> </span>&#123;</span><br><span class="line">	personMapper.deleteById(personId);</span><br><span class="line">	personMapper.deletePersonPrivilege(personId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种有异步线程存在的情况下，<code>@Transactional</code>无论加在哪个方法都不会生效。<br>因此，只有把<code>@Transactional</code>注解加在直接被外部调用的方法才能生效。</p>
<h1 id="Spring-AOP和AspectJ的关系"><a href="#Spring-AOP和AspectJ的关系" class="headerlink" title="Spring AOP和AspectJ的关系"></a>Spring AOP和AspectJ的关系</h1><p>AspectJ是一个独立的AOP框架，它有自己的一套语法用来实现AOP，用它的语法写的代码文件是.aj文件，还有自己的编译器ajc（Java编译器是javac），负责把.aj编译为.class文件。AspectJ在编译时就生成了代理类，所以它是静态代理。Spring的切入点只能是方法，但AspectJ可以用于字段、类等等，它的实现比Spring AOP要复杂的多。</p>
<p>在我们上面的实践中，都是用注解来编写切面类，这些注解是AspectJ的jar包提供的，但对于AOP功能的实现，用的是JDK或CGLIB的动态代理。因此，Spring AOP和AspectJ的关系就是，Spring用到了AspectJ的注解，但没有用它的语法和编译器，也没有用AspectJ的静态代理来实现功能。</p>
<h1 id="JDK和CGLIB"><a href="#JDK和CGLIB" class="headerlink" title="JDK和CGLIB"></a>JDK和CGLIB</h1><ol>
<li>JDK动态代理。只能代理实现了接口的类。上面代码所展现的就是这个机制。它是用Proxy.newProxyInstance()方法生成代理类，用InvocationHandler向代理类织入AOP逻辑</li>
<li>CGLIB动态代理。不要求被代理类必须实现接口，但不能代理final类。它是用Enhancer类创建<em>被代理类的子类</em>作为代理类，底层是用字节码创建子类，用MethodInterceptor向子类织入AOP逻辑</li>
</ol>
<p>在SpringBoot2.0之前，Spring默认用JDK动态代理，只有当被代理类没有实现接口时，Spring才用CGLIB动态代理。在SpringBoot2.0之后，无论被代理类是否实现接口，Spring默认都用CGLIB动态代理。</p>
<blockquote>
<p>想要自行实现CGLIB动态代理，看这篇博客：<a href="https://www.jianshu.com/p/13fa41aa18d8" target="_blank" rel="noopener">https://www.jianshu.com/p/13fa41aa18d8</a></p>
</blockquote>
<blockquote>
<p>JDK为什么只能代理实现了接口的类？</p>
</blockquote>
<p>JDK用Proxy.newProxyInstance()方法生成的代理类类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">HelloService</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>因为既要继承Proxy，又要继承接口，所以另一个只能是接口。</p>
<blockquote>
<p>SpringBoot2.0之后，为什么默认用CGLIB动态代理？</p>
</blockquote>
<p>官方的回答是，We’ve generally found cglib proxies less likely to cause unexpected cast exceptions.他们认为使用cglib更不容易出现转换错误。<br>如果我们的代码写成了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserServiceImpl userService;</span><br></pre></td></tr></table></figure>
<p>这个时候，如果是JDK动态代理，那在启动时就会报错：因为JDK动态代理是基于接口的，代理生成的对象只能赋值给接口类型。CGLIB就不会报错<br>如果想设置默认使用JDK动态代理，可以加上配置项spring.aop.proxy-target-class=false。</p>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><ol>
<li>JDK和CGLIB都是在运行期生成代理类的字节码。区别在于，JDK是直接写Class字节码，CGLIB使用ASM框架写Class字节码，CGLIB代理实现更复杂，生成代理类的效率比JDK低。</li>
<li>JDK调用代理方法，是通过反射机制调用。CGLIB是通过FastClass机制直接调用方法，CGLIB执行效率更高。但，在JDK1.8后，Java的反射调用效率有所改善，整体的动态代理速度已经可以和CGLIB媲美了。</li>
</ol>
<blockquote>
<p>什么是FastClass机制？</p>
</blockquote>
<p>FastClass机制的原理简单来说就是：为代理类和被代理类各生成一个Class，这个Class会为代理类或被代理类的方法分配一个index(int类型)。这个index当做一个入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比JDK动态代理通过反射调用高。</p>
<blockquote>
<p>JDK1.8后，Java的反射调用效率有哪些改善？</p>
</blockquote>
<p>在1.8之前，JVM把缓存放在Class的属性SoftReference<ReflectionData> reflectionData。这个属性的类型是SoftReference（软引用），所谓软引用就是在资源紧张的情况下GC会进行回收，这就可能导致缓存丢失。SoftReference的泛型是ReflectionData，ReflectionData就是缓存数据的真正格式。ReflectionData将所有的Constructor、Method、Field对象存储下来供反射进行使用。</p>
<p>在1.8，放弃使用ReflectionData存储，而是在Class中直接将Constructor、Method、Field数组放进软引用中作为缓存。这样就将缓存分散，当资源紧张时，缓存不会全部被GC回收。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8E%9F%E7%90%86%E6%8F%8F%E8%BF%B0/">原理描述</a><a class="post-meta__tags" href="/tags/%E5%AE%9E%E8%B7%B5/">实践</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/05/16/algorithmic-puzzles-note/"><i class="fa fa-chevron-left">  </i><span>《算法谜题》笔记</span></a></div><div class="next-post pull-right"><a href="/2020/02/25/java-date-trans/"><span>Java 时间类型转换</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By yunnight</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>