<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spring Security 认证与授权流程"><meta name="keywords" content=""><meta name="author" content="yunnight"><meta name="copyright" content="yunnight"><title>Spring Security 认证与授权流程 | yunnight</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#认证"><span class="toc-number">2.</span> <span class="toc-text">认证</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UserDetailsService和UserDetails"><span class="toc-number">2.1.</span> <span class="toc-text">UserDetailsService和UserDetails</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义实现思路"><span class="toc-number">2.2.</span> <span class="toc-text">自定义实现思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义实现示例"><span class="toc-number">2.3.</span> <span class="toc-text">自定义实现示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#授权"><span class="toc-number">3.</span> <span class="toc-text">授权</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AccessDecisionManager和FilterInvocationSecurityMetadataSource"><span class="toc-number">3.1.</span> <span class="toc-text">AccessDecisionManager和FilterInvocationSecurityMetadataSource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ExceptionTranslationFilter"><span class="toc-number">3.2.</span> <span class="toc-text">ExceptionTranslationFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义实现思路-1"><span class="toc-number">3.3.</span> <span class="toc-text">自定义实现思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义实现示例-1"><span class="toc-number">3.4.</span> <span class="toc-text">自定义实现示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#过滤器链"><span class="toc-number">4.</span> <span class="toc-text">过滤器链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#添加自定义过滤器"><span class="toc-number">4.1.</span> <span class="toc-text">添加自定义过滤器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#permitAll"><span class="toc-number">5.</span> <span class="toc-text">permitAll()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WebSecurity"><span class="toc-number">6.</span> <span class="toc-text">WebSecurity</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Security保存登录用户信息原理"><span class="toc-number">7.</span> <span class="toc-text">Security保存登录用户信息原理</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/yunnight/pics/master/blog_avatar.jpg"></div><div class="author-info__name text-center">yunnight</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">42</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">yunnight</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Spring Security 认证与授权流程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Spring/"> Spring</a></div><div class="article-container" id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>只要是权限校验框架，就离不开两个步骤：认证（Authentication）和授权（Authorization）。认证即“用户登录”，授权即“允许用户访问目标URI”。这篇博客介绍了Spring Security 5.0.6版本认证与授权这两个过程的执行链条，未涉及到更高级的功能（如单点登录、RememberMe）。</p>
<blockquote>
<p>官方文档（Security5.0.6）：<a href="https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/" target="_blank" rel="noopener">https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/</a></p>
</blockquote>
<h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>Spring Security的认证工作主要由<code>UsernamePasswordAuthenticationFilter</code>完成。这个Filter是默认配置的，每个请求都会被它拦截。认证成功后，会生成经过认证的用户信息对象<code>Authentication</code>。<strong>无论认证成功或失败，都不会继续走后面的Filter。</strong></p>
<p>步骤简述：</p>
<ol>
<li>请求进入<code>UsernamePasswordAuthenticationFilter.doFilter()</code>方法</li>
<li>在doFilter()方法中，先判断请求URI是否为<code>POST loginProcessingUrl</code>，是则继续，<strong>否则跳过认证，直接进入Security过滤器链中下一个Filter</strong>。loginProcessingUrl表示登录提交的URI，可自定义，默认值为”/login”</li>
<li>判断为“是”，doFilter()调用<code>AuthenticationManager.authenticate()</code>。默认调用到AuthenticationManager的实现类<code>ProviderManager</code></li>
<li>在ProviderManager.authenticate()中，调用<code>AuthenticationProvider.authenticate()</code>方法执行真正的认证逻辑。默认调用到AuthenticationProvider的实现类<code>DaoAuthenticationProvider</code></li>
<li>在AuthenticationProvider.authenticate()中，根据请求中的用户名参数”username”，调用<code>UserDetailsService.loadUserByUsername()</code>，该方法返回<code>UserDetails</code>对象，表示数据源中存储的用户信息</li>
<li>AuthenticationProvider获得UserDetails对象后，校验此UserDetails对象，校验依据是UserDetails接口的几个boolean方法，如isEnabled()。说明一下，因为此UserDetails对象是用请求中的用户名查找出的，所以校验此对象状态也就是对请求中的用户名进行<strong>认证</strong></li>
<li>若在“第5步”中<code>UserDetailsService.loadUserByUsername()</code>没有找到UserDetails，或在“第6步”中校验UserDetails对象不通过，则说明请求中的用户名有误。这两个方法会抛出<code>AuthenticationException</code>子类，说明认证失败。这个异常向上传递最终由<code>UsernamePasswordAuthenticationFilter</code>捕获处理。UsernamePasswordAuthenticationFilter捕获异常后，调用<code>AuthenticationFailureHandler.onAuthenticationFailure()</code>进行后续处理，默认调用到实现类<code>SimpleUrlAuthenticationFailureHandler</code>，作用是返回403状态码，或者在设置了failureUrl时跳转到此URL。之后不会再经过其他Filter</li>
<li>若认证成功，则AuthenticationProvider生成通过认证的<code>Authentication</code>对象（含用户名、密码、权限等），并返回到<code>AuthenticationManager.authenticate()</code>，再向上传递到<code>UsernamePasswordAuthenticationFilter.doFilter()</code></li>
<li>doFilter()获得<code>Authentication</code>对象后，调用<code>SecurityContextHolder.getContext().setAuthentication()</code>将Authentication对象赋予给当前的<code>SecurityContext</code></li>
<li>doFilter()调用<code>AuthenticationSuccessHandler.onAuthenticationSuccess()</code>进行后续处理，默认调用到实现类<code>SavedRequestAwareAuthenticationSuccessHandler</code>，作用是从request header或配置中取targetUrl并跳转。之后不会再经过其他Filter</li>
</ol>
<p>认证成功流程：</p>
<img src="/2020/08/23/spring-security-auth/authentication_success.PNG" class="" title="认证成功">


<p>认证失败流程：</p>
<img src="/2020/08/23/spring-security-auth/authentication_fail.PNG" class="" title="认证失败">


<h2 id="UserDetailsService和UserDetails"><a href="#UserDetailsService和UserDetails" class="headerlink" title="UserDetailsService和UserDetails"></a>UserDetailsService和UserDetails</h2><p>在上述“第5步”中，提到了<code>UserDetailsService.loadUserByUsername()</code>方法。该方法源码；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException, DataAccessException</span>;</span><br></pre></td></tr></table></figure>

<p>该方法的作用就是查找数据源中的用户信息，<code>AuthenticationProvider.authenticate()</code>就是以此为依据对当前请求进行认证。根据UserDetailsService的已有实现类推测，数据源可以是JDBC数据库、内存。</p>
<p>该方法的返回对象<code>UserDetails</code>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的4个boolean方法，就是<code>DaoAuthenticationProvider</code>对请求进行认证的依据。Spring默认使用的实现类是<code>User</code>。</p>
<p><code>getAuthorities()</code>方法返回一个<code>Collection&lt;GrantedAuthority&gt;</code>对象，GrantedAuthority是个接口，一般使用它的实现类<code>SimpleGrantedAuthority</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GrantedAuthority</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回表示权限的String</span></span><br><span class="line">	<span class="function">String <span class="title">getAuthority</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义实现思路"><a href="#自定义实现思路" class="headerlink" title="自定义实现思路"></a>自定义实现思路</h2><ol>
<li>自定义<code>AuthenticationProvider.authenticate()</code>，实现自己的认证逻辑，如校验密码是否正确</li>
<li>自定义<code>UserDetailsService.loadUserByUsername()</code>，实现自己的查找原用户信息的方式，如从数据库查找</li>
<li>自定义<code>UserDetails</code>，这是原用户信息对象，也是认证成功后被保存在<code>SecurityContext</code>的对象，可以自定义需要的属性，如用户所在组、岗位等</li>
<li>自定义会进入认证逻辑的<code>POST loginProcessingUrl</code>，如果你的登录表单action不是”/login”就需要设置</li>
<li>自定义登录页地址</li>
<li>自定义认证成功和失败后的处理，<code>AuthenticationSuccessHandler</code>和<code>AuthenticationFailureHandler</code></li>
</ol>
<p>以上自定义可以实现基本的认证需求，更高级的如RememberMe、单点登录等这里没有列出，需要查阅其他资料。</p>
<h2 id="自定义实现示例"><a href="#自定义实现示例" class="headerlink" title="自定义实现示例"></a>自定义实现示例</h2><p>配置示例（只写出与认证有关的部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	CustomAuthenticationProvider customAuthenticationProvider;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		http</span><br><span class="line">			.formLogin() <span class="comment">// 这行下面的语句都是在设置UsernamePasswordAuthenticationFilter的属性</span></span><br><span class="line">				.loginPage(<span class="string">"/login"</span>) <span class="comment">// 登录页</span></span><br><span class="line">				.loginProcessingUrl(<span class="string">"/login/submit"</span>) <span class="comment">// 登录提交URI，访问此URI的请求会进入认证逻辑</span></span><br><span class="line">				.successHandler(<span class="keyword">new</span> LoginSuccessHandler()) <span class="comment">// 自定义AuthenticationSuccessHandler</span></span><br><span class="line">				.failureHandler(<span class="keyword">new</span> LoginFailureHandler()) <span class="comment">// 自定义AuthenticationFailureHandler</span></span><br><span class="line">				.and()</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">			;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	    <span class="comment">// 给AuthenticationManager设置自定义AuthenticationProvider</span></span><br><span class="line">		auth.authenticationProvider(customAuthenticationProvider);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义AuthenticationProvider示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="meta">@Qualifier</span>(<span class="string">"securityUserService"</span>)</span><br><span class="line">	UserDetailsService userDetailsService; <span class="comment">// 自定义UserDetailsService</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">		String username = authentication.getName();</span><br><span class="line">		Object password = (String) authentication.getCredentials();</span><br><span class="line">		<span class="comment">// SecurityUser是自定义的UserDetails</span></span><br><span class="line">		SecurityUser userDetails = (SecurityUser) userDetailsService.loadUserByUsername(username);</span><br><span class="line">		<span class="keyword">if</span> (userDetails == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="string">"账号不存在"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!userDetails.getPassword().equals(password)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="string">"账号密码错误"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userDetails, password, userDetails.getAuthorities());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><p>在认证流程中，只有当请求URI是设置的登录提交URI loginProcessingUrl时，才会进入<code>UsernamePasswordAuthenticationFilter</code>的认证逻辑，且不论认证结果如何都会直接返回，不会进入授权流程。<strong>是其他URI时，就会跳过认证，直接进入授权流程</strong>。</p>
<p>Spring Security的授权工作主要由<code>FilterSecurityInterceptor</code>完成，它也是个Filter实现类。它是Security过滤器链中位置倒数第二的Filter，若进入了它的授权逻辑，授权成功则走出Security过滤器链，进入下一步；授权失败则请求结束，返回响应体或跳转页面。</p>
<ol>
<li>请求进入<code>FilterSecurityInterceptor</code>拦截器，调用其父类方法<code>super.beforeInvocation(fi)</code>，继续调用<code>FilterInvocationSecurityMetadataSource.getAttributes()</code>获取被拦截URI所需的权限字符串集合。Security内置了一些权限字符串，如“permitAll”</li>
<li>若<code>FilterInvocationSecurityMetadataSource.getAttributes()</code>方法返回NULL，则FilterSecurityInterceptor执行完毕，<strong>请求走出Security过滤器链</strong>。因此可以认为返回NULL的URI是无需权限访问的</li>
<li>被拦截URI的权限不为NULL，则FilterSecurityInterceptor通过<code>SecurityContext.getAuthentication()</code>取得当前用户的权限信息，再调用授权管理器<code>AccessDecisionManager.decide()</code>方法决定是否允许用户访问此URI。这个方法由AccessDecisionManager子类实现，Spring已实现的decide策略有<code>AffirmativeBased</code>一票肯定，<code>UnanimousBased</code>一票否定，<code>ConsensusBased</code>少数服从多数。默认使用AffirmativeBased</li>
<li>若用户无权访问，AccessDecisionManager.decide()抛出<code>AccessDeniedException</code>异常，这个异常会被<code>ExceptionTranslationFilter</code>处理，这个后面再讲</li>
<li>AccessDecisionManager.decide()顺利执行完毕，表示用户有权访问，即授权成功，<strong>请求走出Security过滤器链</strong></li>
</ol>
<blockquote>
<p>若未登录用户直接访问URI，AccessDecisionManager会怎么判断？<br>这个要看URI的权限，如果URI的权限是“permitAll”，则未登录用户也可以访问。具体看AffirmativeBased类的源码。</p>
</blockquote>
<p>另外，请求走出Security过滤器链后，不一定就直接进入Controller，因为走完Security过滤器链之后可能还有过滤器。这部分内容见“过滤器链”一节。</p>
<p>授权成功流程：</p>
<img src="/2020/08/23/spring-security-auth/authorization_success.png" class="" title="授权成功">


<p>授权失败流程：</p>
<img src="/2020/08/23/spring-security-auth/authorization_fail.png" class="" title="授权失败">


<h2 id="AccessDecisionManager和FilterInvocationSecurityMetadataSource"><a href="#AccessDecisionManager和FilterInvocationSecurityMetadataSource" class="headerlink" title="AccessDecisionManager和FilterInvocationSecurityMetadataSource"></a>AccessDecisionManager和FilterInvocationSecurityMetadataSource</h2><p>接口源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * authentication是当前用户信息，里面包含用户拥有的权限</span></span><br><span class="line"><span class="comment">	 * object是被拦截URI</span></span><br><span class="line"><span class="comment">	 * configAttributes是被拦截URI对应的权限</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">			Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException,</span></span><br><span class="line"><span class="function">			InsufficientAuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回true表示此类失效</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>decide()方法参数介绍：</p>
<ol>
<li><code>authentication</code>是从SecurityContext中拿到的当前用户信息，里面包含用户拥有的权限</li>
<li><code>object</code>代表被拦截URI</li>
<li><code>configAttributes</code>是<code>FilterInvocationSecurityMetadataSource.getAttributes()</code>返回的，代表被拦截URI所需权限</li>
</ol>
<p>FilterInvocationSecurityMetadataSource.getAttributes()源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Collection&lt;ConfigAttribute&gt; <span class="title">getAttributes</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br></pre></td></tr></table></figure>

<p><code>getAttributes()</code>方法返回一个<code>Collection&lt;ConfigAttribute&gt;</code>对象，ConfigAttribute是个接口，一般使用它的实现类<code>SecurityConfig</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigAttribute</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回表示权限的String</span></span><br><span class="line">	<span class="function">String <span class="title">getAttribute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>Collection&lt;ConfigAttribute&gt;</code>是不是和认证流程中提到的<code>Collection&lt;GrantedAuthority&gt;</code>很像？它们都是权限字符串的集合，区别在于前者是被拦截URI的权限集合，后者是用户拥有的权限集合。</p>
<h2 id="ExceptionTranslationFilter"><a href="#ExceptionTranslationFilter" class="headerlink" title="ExceptionTranslationFilter"></a>ExceptionTranslationFilter</h2><p>ExceptionTranslationFilter在Security过滤器链中放在FilterSecurityInterceptor前一位，但它可以捕获过滤器链中，甚至过滤器链之后的，任一个Filter抛出的异常，这其中就包括FilterSecurityInterceptor抛出的异常。这是因为，它在doFilter方法中，把<code>chain.doFilter(request, response);</code>整个try-catch了。</p>
<p>虽然它捕获了过滤器链中所有类型的异常，但它只处理两种异常：<code>AuthenticationException</code>和<code>AccessDeniedException</code>，其它的异常它会继续抛出。</p>
<p>若异常为<code>AuthenticationException</code>，它会调用<code>AuthenticationEntryPoint.commence()</code>处理。一般的做法是重定向到登录页。若异常为<code>AccessDeniedException</code>，它分两种情况，若用户未登录，它调用<code>AuthenticationEntryPoint.commence()</code>处理；若用户已登录但无权限，它调用<code>AccessDeniedHandler.handle()</code>处理。</p>
<p>值得一提的是，在认证过程中抛出的<code>AuthenticationException</code>由<code>UsernamePasswordAuthenticationFilter</code>自己处理后返回，不会进入ExceptionTranslationFilter。即<strong>只有授权时抛出的异常会由它处理</strong>。</p>
<h2 id="自定义实现思路-1"><a href="#自定义实现思路-1" class="headerlink" title="自定义实现思路"></a>自定义实现思路</h2><ol>
<li>自定义<code>AccessDecisionManager.decide()</code>，实现自己的授权逻辑，比如直接判断用户权限是否包含此URI，而不是用Security提供的投票方式</li>
<li>自定义<code>FilterInvocationSecurityMetadataSource.getAttributes()</code>，实现自己的查找URI所需权限的方式，如从数据库查找</li>
<li>自定义ExceptionTranslationFilter处理异常的方法，<code>AuthenticationEntryPoint.commence()</code>和<code>AccessDeniedHandler.handle()</code></li>
</ol>
<p>以上自定义可以实现基本的授权需求，更高级的需要查阅其他资料。</p>
<h2 id="自定义实现示例-1"><a href="#自定义实现示例-1" class="headerlink" title="自定义实现示例"></a>自定义实现示例</h2><p>配置示例（只写出与授权有关的部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		http</span><br><span class="line">			.authorizeRequests()</span><br><span class="line">				.anyRequest().authenticated() <span class="comment">// 所有请求都需要认证授权</span></span><br><span class="line">				.withObjectPostProcessor(<span class="keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123; <span class="comment">// 设置FilterSecurityInterceptor属性</span></span><br><span class="line">					<span class="keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="function">O <span class="title">postProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">							O fsi)</span> </span>&#123;</span><br><span class="line">						fsi.setAccessDecisionManager(<span class="keyword">new</span> CustomAccessDecisionManager()); <span class="comment">// 自定义AccessDecisionManager</span></span><br><span class="line">						fsi.setSecurityMetadataSource(<span class="keyword">new</span> CustomFilterInvocationSecurityMetadataSource()); <span class="comment">// 自定义FilterInvocationSecurityMetadataSource</span></span><br><span class="line">						<span class="keyword">return</span> fsi;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">				.and()</span><br><span class="line">			.exceptionHandling() <span class="comment">// 以下两行设置ExceptionTranslationFilter属性</span></span><br><span class="line">				.accessDeniedHandler(<span class="keyword">new</span> CustomAccessDeniedHandler()) <span class="comment">// 自定义AccessDeniedHandler</span></span><br><span class="line">				.authenticationEntryPoint(<span class="keyword">new</span> CustomAuthenticationEntryPoint()) <span class="comment">// 自定义AuthenticationEntryPoint</span></span><br><span class="line">				.and()	</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">			;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义AccessDecisionManager示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAccessDecisionManager</span> <span class="keyword">implements</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// authentication是从spring的全局缓存SecurityContextHolder中拿到的，里面是用户的权限信息(权限编码)</span></span><br><span class="line">	<span class="comment">// object是被拦截URI</span></span><br><span class="line">	<span class="comment">// configAttributes是被拦截URI对应的权限(权限编码)</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"=========================AccessDecisionManager=============================="</span>);</span><br><span class="line">		<span class="keyword">if</span> (CollectionUtils.isEmpty(configAttributes)) &#123; <span class="comment">// 被拦截URI所需权限为空，直接返回</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br><span class="line">		<span class="comment">// 简单的判断用户权限中是否包含URI权限</span></span><br><span class="line">		<span class="keyword">for</span> (ConfigAttribute attr : configAttributes) &#123;</span><br><span class="line">			String attribute = attr.getAttribute();</span><br><span class="line">			<span class="keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">				String authority2 = authority.getAuthority();</span><br><span class="line">				<span class="keyword">if</span> (authority2.equals(attribute)) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(<span class="string">"无权访问"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h1><p>在Security配置类<code>WebSecurityConfigurerAdapter</code>的初始化方法中，会给<code>HttpSecurity</code>设置一些过滤器。这个动作在执行我们重写的<code>configure()</code>方法之前。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> HttpSecurity <span class="title">getHttp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!disableDefaults) &#123; <span class="comment">// 启用默认配置</span></span><br><span class="line">		http</span><br><span class="line">			.csrf().and() <span class="comment">// 4.CsrfFilter</span></span><br><span class="line">			.addFilter(<span class="keyword">new</span> WebAsyncManagerIntegrationFilter()) <span class="comment">// 1.WebAsyncManagerIntegrationFilter</span></span><br><span class="line">			.exceptionHandling().and() <span class="comment">//11.ExceptionTranslationFilter</span></span><br><span class="line">			.headers().and() <span class="comment">// 3.HeaderWriterFilter</span></span><br><span class="line">			.sessionManagement().and() <span class="comment">// 10.SessionManagementFilter</span></span><br><span class="line">			.securityContext().and() <span class="comment">// 2.SecurityContextPersistenceFilter</span></span><br><span class="line">			.requestCache().and() <span class="comment">//7.RequestCacheAwareFilter</span></span><br><span class="line">			.anonymous().and() <span class="comment">// 9.AnonymousAuthenticationFilter</span></span><br><span class="line">			.servletApi().and() <span class="comment">// 8.SecurityContextHolderAwareRequestFilter</span></span><br><span class="line">			.apply(<span class="keyword">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and()</span><br><span class="line">			.logout(); <span class="comment">// 5.LogoutFilter</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 其他略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面展示的部分源码，作用主要是注册了10个Filter，数字代表它们在过滤器链中的顺序。这些过滤器的顺序是在<code>FilterComparator</code>类中定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FilterComparator() &#123;</span><br><span class="line">	<span class="keyword">int</span> order = <span class="number">100</span>;</span><br><span class="line">	put(ChannelProcessingFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line">	order += STEP;</span><br><span class="line">	put(ConcurrentSessionFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line">	order += STEP;</span><br><span class="line">	put(WebAsyncManagerIntegrationFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line">	order += STEP;</span><br><span class="line">	put(SecurityContextPersistenceFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line">	order += STEP;</span><br><span class="line">	put(HeaderWriterFilter<span class="class">.<span class="keyword">class</span>, <span class="title">order</span>)</span>;</span><br><span class="line">	<span class="comment">// 太多了，其余略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那在我们什么配置都没有的情况下，<code>UsernamePasswordAuthenticationFilter</code>是在哪里注册并起作用的？<br>在默认的<code>WebSecurityConfigurerAdapter.configure()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	http</span><br><span class="line">		.authorizeRequests()</span><br><span class="line">			.anyRequest().authenticated()</span><br><span class="line">			.and()</span><br><span class="line">		.formLogin().and() <span class="comment">// UsernamePasswordAuthenticationFilter</span></span><br><span class="line">		.httpBasic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一行<code>formLogin()</code>，工作包括初始化UsernamePasswordAuthenticationFilter，并设置其成员变量<code>requiresAuthenticationRequestMatcher=POST /login</code>，这个成员变量就代表登录提交URI loginProcessingUrl，即要进入认证流程的URI。</p>
<p><strong>注意：</strong>Spring Security的这一整套过滤器，是以<strong>一个过滤器的身份</strong>被添加到<code>ApplicationFilterChain</code>中。ApplicationFilterChain就是Tomcat整理的过滤器链。这“一个过滤器”名叫“SpringSecurityFilterChain”。若我们自定义Filter没有添加到Security过滤器链中，这个Filter会排在Security过滤器链之后，即执行完Security所有过滤器后才会执行到这个Filter。</p>
<p>像下面这个自定义Filter就是没有加入到Security过滤器链中，只是加入了ApplicationFilterChain：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		chain.doFilter(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何把自定义Filter添加到Security过滤器链中？下面说明。</p>
<h2 id="添加自定义过滤器"><a href="#添加自定义过滤器" class="headerlink" title="添加自定义过滤器"></a>添加自定义过滤器</h2><p>想在Security的过滤器链中的某个位置加入自定义过滤器，可以使用HttpSecurity的3种方法：</p>
<ol>
<li>addFilterBefore(Filter filter, Class&lt;? extends Filter&gt; beforeFilter)</li>
<li>addFilterAfter(Filter filter, Class&lt;? extends Filter&gt; afterFilter)</li>
<li>addFilterAt(Filter filter, Class&lt;? extends Filter&gt; atFilter)</li>
</ol>
<p>这3个方法的前一个参数就是自定义Filter对象，后一个表示自定义Filter要放在哪个默认Filter的前面，或者后面，或者就放在默认Filter所在位置。</p>
<p>下面这个例子表示把自定义Filter放在UsernamePasswordAuthenticationFilter的前一个位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterBefore(<span class="keyword">new</span> BeforeLoginFilter(), UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure>

<p>有一个问题，若使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterAt(<span class="keyword">new</span> AtLoginFilter(), UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure>
<p>AtLoginFilter是在UsernamePasswordAuthenticationFilter的前面还是后面，还是把UsernamePasswordAuthenticationFilter覆盖？</p>
<p>答案是addFilterAt()不会覆盖UsernamePasswordAuthenticationFilter，且在它之前。具体原因是，<code>HttpSecurity</code>会用一个<code>List&lt;Filter&gt;</code>保存系统中所有自定义和默认的Filter，<strong>自定义过滤器是先于大部分默认过滤器被加入到List中的</strong>。在放入的同时，自定义Filter会被<code>FilterComparator</code>安排一个序号，这个序号等于UsernamePasswordAuthenticationFilter的序号。Spring在初始化过滤器链时，调用<code>HttpSecurity.performBuild()</code>方法，方法中使用FilterComparator对List中元素进行排序，<strong>序号一致的维持原序</strong>。因此使用addFilterAt()时，自定义Filter会在默认Filter之前。</p>
<h1 id="permitAll"><a href="#permitAll" class="headerlink" title="permitAll()"></a>permitAll()</h1><p>我在参考官方文档配置Spring Security时，看到两个<code>permitAll()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">	.authorizeRequests()</span><br><span class="line">		.antMatchers(<span class="string">"/favicon.ico"</span>).permitAll() <span class="comment">// 1</span></span><br><span class="line">		.and()</span><br><span class="line">	.formLogin()</span><br><span class="line">		.permitAll()<span class="comment">// 2</span></span><br><span class="line">	<span class="comment">// ...</span></span><br></pre></td></tr></table></figure>


<p>第一个permitAll是<code>ExpressionUrlAuthorizationConfigurer.AuthorizedUrl.permitAll()</code>，第二个是<code>FormLoginConfigurer&lt;HttpSecurity&gt;.permitAll()</code>。它们的作用都是，把这些指定的URI的权限字符串设置为“permitAll”，表示允许任何用户访问这些指定的URI，即这些URI无需权限访问，即使用户未登录。</p>
<p>第一个指定URI是自己添加的，第二个指定的URI是认证过程中会用到的loginPage、loginProcessingUrl、failureUrl这三个URI，它们有默认值。</p>
<p>无论使用哪个permitAll，这些URI最后会被添加到这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfigAttributeRequestMatcherRegistry</span>&lt;<span class="title">C</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">		<span class="title">AbstractRequestMatcherRegistry</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// URI和对应权限保存在此变量</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;UrlMapping&gt; urlMappings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlMapping</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> RequestMatcher requestMatcher; <span class="comment">// URI</span></span><br><span class="line">		<span class="keyword">private</span> Collection&lt;ConfigAttribute&gt; configAttrs; <span class="comment">// URI对应权限</span></span><br><span class="line"></span><br><span class="line">		UrlMapping(RequestMatcher requestMatcher, Collection&lt;ConfigAttribute&gt; configAttrs) &#123;</span><br><span class="line">			<span class="keyword">this</span>.requestMatcher = requestMatcher;</span><br><span class="line">			<span class="keyword">this</span>.configAttrs = configAttrs;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> RequestMatcher <span class="title">getRequestMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> requestMatcher;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getConfigAttrs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> configAttrs;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些URI保存后，在创建<code>ExpressionBasedFilterInvocationSecurityMetadataSource</code>时会被取出。这个类是Spring在授权时默认使用的<code>FilterInvocationSecurityMetadataSource</code>实现类。</p>
<p>被取出时的部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfigAttributeRequestMatcherRegistry</span>&lt;<span class="title">C</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">		<span class="title">AbstractRequestMatcherRegistry</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">final</span> LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; createRequestMap() &#123;</span><br><span class="line">	</span><br><span class="line">		LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; requestMap = <span class="keyword">new</span> LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (UrlMapping mapping : getUrlMappings()) &#123;</span><br><span class="line">			RequestMatcher matcher = mapping.getRequestMatcher();</span><br><span class="line">			Collection&lt;ConfigAttribute&gt; configAttrs = mapping.getConfigAttrs();</span><br><span class="line">			requestMap.put(matcher, configAttrs);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> requestMap;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取出后被封装为<code>LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt;</code>类型，保存了原本在List中的顺序，赋值给<code>ExpressionBasedFilterInvocationSecurityMetadataSource</code>的成员变量<code>requestMap</code>。</p>
<p>在Spring默认配置的授权流程中，有请求访问这些URI时，只要不是会进入认证过程的<code>POST loginProcessingUrl</code>，就会进入<code>FilterSecurityInterceptor</code>。FilterSecurityInterceptor调用<code>ExpressionBasedFilterInvocationSecurityMetadataSource.getAttribute()</code>方法，得到这些URI的权限字符串是“permitAll”，再通过<code>AccessDecisionManager.decide()</code>决定此URI允许访问（默认调用AffirmativeBased）。因此无论用户是否登录、是否有权限，都可访问此URI。</p>
<p>由于这些permitAll()方法是在Spring默认实现的AccessDecisionManager.decide()中起作用，若我们自定义的AccessDecisionManager.decide()不会使用“permitAll”权限字符串，则可以不用设置。</p>
<h1 id="WebSecurity"><a href="#WebSecurity" class="headerlink" title="WebSecurity"></a>WebSecurity</h1><p>WebSecurity一般用来设置不想被Security拦截的静态资源URI。如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	web.ignoring().antMatchers(<span class="string">"/css/**"</span>, <span class="string">"/webjars/**"</span>, <span class="string">"/img/**"</span>, <span class="string">"/js/**"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些URI会跳过Security的过滤器链，但不会跳过在Security过滤器链之后的Filter。</p>
<h1 id="Security保存登录用户信息原理"><a href="#Security保存登录用户信息原理" class="headerlink" title="Security保存登录用户信息原理"></a>Security保存登录用户信息原理</h1><p>在“授权”过程中我们提到，FilterSecurityInterceptor 通过 SecurityContext.getAuthentication() 取得当前用户的权限信息来做访问权限校验。那么在用户登录后的每次请求中，SecurityContext 如何准确获取该用户的认证信息？</p>
<p>首先说明， 在一次请求线程中，SecurityContext 整个对象都是是通过<code>SecurityContextHolder</code>来存取的。在默认配置下，SecurityContextHolder 用<code>ThreadLocal&lt;SecurityContext&gt; contextHolder</code>存储 SecurityContext 对象，使得该对象在一次请求中都有效且无线程安全问题。这个存储方式可配置修改，也可自定义，具体见 SecurityContextHolder 类源码。</p>
<p>那么请求结束后，线程销毁，SecurityContextHolder 如何在用户下一次请求时还能取得该对象？答案在 Security 过滤器 SecurityContextPersistenceFilter 中，这个过滤器在过滤器链中排第二。</p>
<p>SecurityContextPersistenceFilter 部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityContextPersistenceFilter</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> SecurityContextRepository repo;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">		HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="keyword">null</span>) &#123; <span class="comment">// 这是为了控制该过滤器只走一次</span></span><br><span class="line">			<span class="comment">// ensure that filter is only applied once per request</span></span><br><span class="line">			chain.doFilter(request, response);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">		request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (forceEagerSessionCreation) &#123; <span class="comment">// 这个值默认false，起个预读取session的作用</span></span><br><span class="line">			HttpSession session = request.getSession();</span><br><span class="line">			<span class="keyword">if</span> (debug &amp;&amp; session.isNew()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Eagerly created session: "</span> + session.getId());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		HttpRequestResponseHolder holder = <span class="keyword">new</span> HttpRequestResponseHolder(request, response);</span><br><span class="line">		<span class="comment">// 这一步就是从session中取SecurityContext对象，如果取不到会创建一个空对象</span></span><br><span class="line">		SecurityContext contextBeforeChainExecution = repo.loadContext(holder);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 把从session中取的SecurityContext对象保存到SecurityContextHolder中</span></span><br><span class="line">			SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">			<span class="comment">// 执行后面的过滤器</span></span><br><span class="line">			chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 后面所有过滤器执行完且程序也处理完请求后，回到这里</span></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 这次请求过后的SecurityContext对象</span></span><br><span class="line">			SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();</span><br><span class="line">			<span class="comment">// 清除threadLocal</span></span><br><span class="line">			SecurityContextHolder.clearContext();</span><br><span class="line">			<span class="comment">// 把新的SecurityContext对象保存到session</span></span><br><span class="line">			repo.saveContext(contextAfterChainExecution, holder.getRequest(),</span><br><span class="line">					holder.getResponse());</span><br><span class="line">					</span><br><span class="line">			request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">			<span class="keyword">if</span> (debug) &#123;</span><br><span class="line">				logger.debug(<span class="string">"SecurityContextHolder now cleared, as request processing completed"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个过滤器中可以看到，Security在每次请求过后，把用户的 SecurityContext 对象保存在 HttpSession 中。下一次用户请求中会带着<code>Cookie:JSESSIONID=xxxx</code>过来，Security 就能找到这个用户的 SecurityContext 对象了。</p>
<blockquote>
<p>如果用户禁用了Cookie，要怎么实现这个功能呢？<br>用户禁用了cookie也不妨碍我们使用session，关键是要拿到JSESSIONID。网上有教程介绍禁用cookie继续使用session的方法，一种方法就是把JSESSIONID放在每个URL之后。</p>
</blockquote>
</div></article><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/08/30/vue-component-build/"><i class="fa fa-chevron-left">  </i><span>Vue组件开发</span></a></div><div class="next-post pull-right"><a href="/2020/08/01/java-web-stream-note/"><span>Java Web 流处理笔记</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By yunnight</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>